import os,re,bitplanelib,ast,json
from PIL import Image,ImageOps


import collections



this_dir = os.path.dirname(__file__)
src_dir = os.path.join(this_dir,"../../src/amiga")
ripped_tiles_dir = os.path.join(this_dir,"../tiles")
dump_dir = os.path.join(this_dir,"dumps")

# adapted from MAME:
# https://github.com/mamedev/mame/blob/master/src/mame/galaxian/galaxian_v.cpp (around line 333)
RGB_MAXIMUM = 224
STAR_RNG_PERIOD = ((1 << 17) - 1)


minval = RGB_MAXIMUM * 130 // 150
midval = RGB_MAXIMUM * 130 // 100
maxval = RGB_MAXIMUM * 130 // 60

starmap= [
            0,
            minval,
            minval + (255 - minval) * (midval - minval) // (maxval - minval),
            255 ]

m_star_color = [0]*64
m_star_color_rgb4 = [0]*64

def rgb_t(r,g,b):
    return (r<<16)+(g<<8)+b
def rgb4(*args):
    return bitplanelib.to_rgb4_color(args)

def BIT(i,nb):
    return bool(i & (1<<nb))

def doit():

    for i in range(64):
        # bit 5 = red @ 150 Ohm, bit 4 = red @ 100 Ohm
        bit0 = BIT(i, 5)
        bit1 = BIT(i, 4)
        r = starmap[(bit1 << 1) | bit0]

        # bit 3 = green @ 150 Ohm, bit 2 = green @ 100 Ohm
        bit0 = BIT(i, 3)
        bit1 = BIT(i, 2)
        g = starmap[(bit1 << 1) | bit0]

        # bit 1 = blue @ 150 Ohm, bit 0 = blue @ 100 Ohm
        bit0 = BIT(i, 1)
        bit1 = BIT(i, 0)
        b = starmap[(bit1 << 1) | bit0]

        # set the RGB color
        m_star_color[i] = rgb_t(r, g, b)
        m_star_color_rgb4[i] = rgb4(r, g, b)

    stars = []
    shiftreg = 0
    for _ in range(STAR_RNG_PERIOD):
        # stars are enabled if the upper 8 bits are 1 and the low bit is 0
        enabled = ((shiftreg & 0x1fe01) == 0x1fe00)

        # color comes from the 6 bits below the top 8 bits
        color = (~shiftreg & 0x1f8) >> 3

        # store the color value in the low 6 bits and the enable in the upper bit
        stars.append(color | (enabled << 7))

        # the LFSR is fed based on the XOR of bit 12 and the inverse of bit 0 */
        shiftreg = (shiftreg >> 1) | ((((shiftreg >> 12) ^ ~shiftreg) & 1) << 16)


    with open(os.path.join(src_dir,"stars_palette.68k"),"w") as f:
        f.write("# generated by assets/{}\n".format(os.path.basename(__file__)))
        f.write("\n\t.global\t{0}\n{0}:".format("stars_palette_rgb4"))
        bitplanelib.dump_asm_bytes(m_star_color_rgb4,f,mit_format=True,nb_elements_per_row=8,size=2)



def dump_asm_bytes(*args,**kwargs):
    bitplanelib.dump_asm_bytes(*args,**kwargs,mit_format=True)

NB_POSSIBLE_SPRITES = 64

black = (0,0,0)
# brown only used for flagship
brown = (222,71,0)
# white used for shots
white = (239, 239, 151)
# cyan for aliens & ship
cyan = (0,222, 247)
# for ship & flags
gray = (195,195,217)
# pink for score & explosions
pink = (195,0,217)
yellow = (255,255,0)
red = (255,0,0)
violet = (151,0,247)
pink = (222,0,247)
blue = (0,104,247)
light_blue =  (0, 151, 168)
deep_blue = (0,0,247)
# 7 base colors
base_palette = [black,
red,
light_blue,
deep_blue,
blue,
yellow,
violet
]

# 4 first colors are dynamic
# 4 last colors: same so all are bullet color
tile_palette = [black]*4+[white]*4
bob_palette = base_palette + [brown]  # all aliens are represented



block_dict = {}

# hackish convert of c gfx table to dict of lists
# (Thanks to Mark Mc Dougall for providing the ripped gfx as C tables)
with open(os.path.join(this_dir,"..","galaxian_gfx.c")) as f:
    block = []
    block_name = ""
    start_block = False

    for line in f:
        if "uint8" in line:
            # start group
            start_block = True
            if block:
                txt = "".join(block).strip().strip(";")
                block_dict[block_name] = {"size":size,"data":ast.literal_eval(txt)}
                block = []
            block_name = line.split()[1].split("[")[0]
            size = int(line.split("[")[2].split("]")[0])
        elif start_block:
            line = re.sub("//.*","",line)
            line = line.replace("{","[").replace("}","]")
            block.append(line)

    if block:
        txt = "".join(block).strip().strip(";")
        block_dict[block_name] = {"size":size,"data":ast.literal_eval(txt)}

bg_cluts = []
cuclut = []
for clut in block_dict["clut"]["data"]:
    cuclut.append(clut)
    if len(cuclut)==4:
        bg_cluts.append(cuclut)
        cuclut = []


palette = tile_palette + bob_palette

with open(os.path.join(src_dir,"palette.68k"),"w") as f:
    bitplanelib.palette_dump(palette,f,pformat=bitplanelib.PALETTE_FORMAT_ASMGNU)


character_codes = list()

extraction_palette = bg_cluts[2]  # use a 4-color palette with 4 different colors!

for k,chardat in enumerate(block_dict["tile"]["data"]):
    img = Image.new('RGB',(8,8))
    d = iter(chardat)
    for i in range(8):
        for j in range(8):
            v = next(d)
            img.putpixel((j,i),extraction_palette[v])
    character_codes.append(bitplanelib.palette_image2raw(img,None,extraction_palette))
    #scaled = ImageOps.scale(img,5,0)
    #scaled.save(os.path.join(dump_dir,f"char_{k:02x}.png"))

with open(os.path.join(this_dir,"sprite_config.json")) as f:
    sprite_config = {int(k):v for k,v in json.load(f).items()}


sprites = collections.defaultdict(dict)

hw_sprite_table = [False]*NB_POSSIBLE_SPRITES
for k,data in sprite_config.items():
    sprdat = block_dict["sprite"]["data"][k]
    for m,clut_index in enumerate(data["cluts"]):
        spritepal = bg_cluts[clut_index]
        hw_sprite = data.get("hw_sprite")
        d = iter(sprdat)
        img = Image.new('RGB',(16,16))
        y_start = 8 if data["clip_right"] else 0
        for i in range(16):
            for j in range(16):
                v = next(d)
                if j >= y_start:
                    img.putpixel((j,i),spritepal[v])

        entry = dict()
        sprites[k][clut_index] = entry
        sprites[k]["name"] = data['name']

        outname = f"{k:02x}_{clut_index}_{data['name']}.png"
        if hw_sprite is None:
            kwargs = {"output_filename":None,"palette":bob_palette,"generate_mask":True,"blit_pad":True}
            left = bitplanelib.palette_image2raw(img,**kwargs)
            if data["mirror"]:
                right = bitplanelib.palette_image2raw(ImageOps.mirror(img),**kwargs)
        else:
            entry["palette"]=spritepal
            entry["hw_sprite"]=hw_sprite
            hw_sprite_table[k] = True

            left = bitplanelib.palette_image2sprite(img,None,spritepal)
            if data["mirror"]:
                right = bitplanelib.palette_image2sprite(ImageOps.mirror(img),None,spritepal)

        entry.update({"left":left,"right":right})

        #scaled = ImageOps.scale(img,5,0)
        #scaled.save(os.path.join(dump_dir,outname))

##grid = Image.open(os.path.join(this_dir,"grid.png"))
##p = bitplanelib.palette_extract(grid)
##grid_bitplanes = bitplanelib.palette_image2raw(grid,None,p,
##                                        generate_mask=True,blit_pad=True)

with open(os.path.join(src_dir,"graphics.68k"),"w") as f:
    f.write("\t.global\tcharacter_table\n")
    f.write("\t.global\tsprite_table\n")
    f.write("\t.global\thw_sprite_flag_table\n")
    f.write("\t.global\tbg_cluts\n")
    f.write("hw_sprite_flag_table:")
    bitplanelib.dump_asm_bytes(bytes(hw_sprite_table),f,mit_format=True)

    f.write("bg_cluts:")
    amiga_cols = [bitplanelib.to_rgb4_color(x) for clut in bg_cluts for x in clut]
    bitplanelib.dump_asm_bytes(amiga_cols,f,mit_format=True,size=2)

    f.write("character_table:\n")
    for i,c in enumerate(character_codes):
        if c is not None:
            f.write(f"\t.long\tchar_{i}\n")
        else:
            f.write("\t.long\t0\n")
    for i,c in enumerate(character_codes):
        if c is not None:
            f.write(f"char_{i}:")
            bitplanelib.dump_asm_bytes(c,f,mit_format=True)
    f.write("sprite_table:\n")

    sprite_names = [None]*NB_POSSIBLE_SPRITES
    for i in range(NB_POSSIBLE_SPRITES):
        sprite = sprites.get(i)
        f.write("\t.long\t")
        if sprite:
            name = f"{sprite['name']}_{i:02x}"
            sprite_names[i] = name
            f.write(name)
        else:
            f.write("0")
        f.write("\n")

    for i in range(NB_POSSIBLE_SPRITES):
        sprite = sprites.get(i)
        if sprite:
            name = sprite_names[i]
            f.write(f"{name}:\n")
            for j in range(8):
                slot = sprite.get(j)
                f.write("\t.long\t")
                if slot:
                    # clut is valid for this sprite
                    f.write(f"{name}_{j}")
                else:
                    f.write("0")
                f.write("\n")

    for i in range(NB_POSSIBLE_SPRITES):
        sprite = sprites.get(i)
        if sprite:
            name = sprite_names[i]
            for j in range(8):
                slot = sprite.get(j)
                if slot:
                    # clut is valid for this sprite
                    f.write(f"{name}_{j}:\n\t.word\t")

                    hw_sprite = slot.get("hw_sprite")

                    if hw_sprite is None:
                        f.write("0   | BOB\n")
                        # just bob pointers
                        left_ptr = f"\t.long\t{name}_{j}_left\n"
                        f.write(left_ptr)
                        if "right" in slot:
                            f.write(f"\t.long\t{name}_{j}_right\n")
                        else:
                            f.write(left_ptr)
                    else:
                        f.write("1   | HW_SPRITE\n")
                        f.write("* palette")
                        rgb4 = [bitplanelib.to_rgb4_color(x) for x in slot["palette"]]
                        bitplanelib.dump_asm_bytes(rgb4,f,mit_format=True,size=2)
                        f.write("\t.long\t0f\n")
                        f.write("* slots")
                        bitplanelib.dump_asm_bytes(bytes(hw_sprite),f,mit_format=True)
                        f.write("\t.byte\t0xff\n\t.align\t2\n")
                        # we chose HW sprites for sprites that only have 1 clut
                        # else this will generate multiply defined symbols
                        # but ATM this is sufficient
                        # also size is assumed 16x16

                        f.write(f"* frames\n0:\n")
                        for index in range(8):
                            if index in hw_sprite:
                                f.write(f"\t.long\t{name}_sprdata_{index}\n")
                            else:
                                f.write("\t.long\t0\n")
    f.write("\t.section\t.datachip\n")

    for i in range(256):
        sprite = sprites.get(i)
        if sprite:
            name = sprite_names[i]
            for j in range(8):
                slot = sprite.get(j)
                if slot:
                    # clut is valid for this sprite
                    hw_sprite = slot.get("hw_sprite")

                    if hw_sprite is None:
                        # just bob data
                        f.write(f"{name}_{j}_left:")
                        bitplanelib.dump_asm_bytes(slot["left"],f,mit_format=True)
                        if "right" in slot:
                            f.write(f"{name}_{j}_right:")
                            bitplanelib.dump_asm_bytes(slot["right"],f,mit_format=True)
                    else:
                        for index in range(8):
                            if index in hw_sprite:
                                f.write(f"{name}_sprdata_{index}:\n\t.long\t0\t| control word")
                                bitplanelib.dump_asm_bytes(slot["left"],f,mit_format=True)
                                f.write("\t.long\t0\n")
