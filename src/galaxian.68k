* Galaxian, amiga 68k transcode

FAST_INTRO_TEXT = 1

* exports

    * ROM

    .global galaxian_irq
    .global galaxian_reset
    .global infinite_lives_flag
    .global invincible_flag
	.global	bg_colorram
	.global	bg_videoram
	.global	vb_ticks_count


	.include "galaxian.inc"

galaxian_reset:
	bra		INITIALISE_SYSTEM

	

invincible_flag:
	.byte	0
infinite_lives_flag:
	.byte	0
vb_ticks_count:
	.byte	0
	
*
* Galaxian (C) 1979 NAMCO.
*
* Reverse engineering work by Scott Tunstall, Paisley, Scotland. 
* Tools used: MAME debugger & Visual Studio Code text editor.
* Date: 7 July 2019.  
* 
* Please send any questions, corrections and updates to scott.tunstall@ntlworld.com
*
* Be sure to check out my reverse engineering work for Robotron 2084 and Scramble too, 
* at http://seanriddle.com/robomame.asm and http://seanriddle.com/scramble.asm asm respectively.
*
* Finally:
* If you'd like to show appreciation for this work by buying me a coffee, feel free: https://ko-fi.com/scotttunstall
* I'd be equally happy if you donated to Parkinsons UK or Chest Heart And Stroke (CHAS) Scotland.
* Thanks.  

/*
Conventions: 

NUMBERS
=======

The term "@ $" means "at memory address in hexadecimal". 
e.g. @ $1234 means "refer to memory address 1234" or "program code @ memory location 1234" 

The term "#$" means "immediate value in hexadecimal". It's a habit I have kept from 6502 days.
e.g. #$60 means "immediate value of 60 hex" (96 decimal)

If I don't prefix a number with $ or #$ in my comments, treat the value as a decimal number.


LABELS
======
I have a labelling convention in place to help you identify the important parts of the code quicker.
Any subroutine labelled with the SCRIPT_ , DISPLAY_ or HANDLE_ prefix are critical "top-level" functions responsible 
for calling a series of "lower-level" functions to achieve a given result.   

If this helps you any, think of the "top level" as the main entry point to code that achieves a specific purpose.  

Routines prefixed HANDLE_ manage a particular aspect of the game.
    For example, HANDLE_PLAYER_MOVE is the core routine for reading the player joystick and moving the player ship. 
    HANDLE_PLAYER_SHOOT is the core routine for reading the player fire button and spawning a bullet.

I expect the purpose of DISPLAY_ is obvious.

SCRIPTS are documented below - see docs for SCRIPT_NUMBER ($4005)


ARRAYS, LISTS, TABLES
=====================

The terms "entry", "slot", "item", "record" when used in an array, list or table context all mean the same thing.
I try to be consistent with my terminology but obviously with a task this size that might not be the case.

Unless I specify otherwise, I all indexes into arrays/lists/tables are zero-based, 
meaning element [0] is the first element, [1] the second, [2] the third and so on.

FLAGS
=====
The terms "Clear", "Reset", "Unset" in a flag context all mean the flag is set to zero.
                                                                               

COORDINATES
===========

X,Y refer to the X and Y axis in a 2D coordinate system, where X is horizontal and Y is vertical.

The Galaxian monitor is rotated 90 degrees. This means that:
a) updating the hardware Y position of a sprite presents itself to the player as changing the horizontal position.
   To make a sprite appear to move left, you would increment its Y position.
   To make a sprite appear to move right, you would decrement its Y position.

b) updating the hardware X position of a sprite presents itself to the player as changing the vertical position. 
   To make a sprite appear to move up, you would decrement its X position.
   To make a sprite appear to move down, you would increment its X position.

So when you see code updating the Y coordinate when you would expect X to be updated, or vice versa, you now know why.

For info about the Galaxian video hardware see: https://github.com/mamedev/mame/blob/master/src/mame/video/galaxian.cpp


Copied from MAME4All documentation: https://github.com/squidrpi/mame4all-pi/blob/master/src/drivers/galaxian.cpp
Some corrections applied from: https://github.com/mamedev/mame/blob/master/src/mame/galaxian/galaxian.cpp

Galaxian/Moon Cresta memory map.
Compiled from information provided by friends and Uncles on RGVAC.

Add 0x4000 to all addresses except for the ROM for Moon Cresta.
            AAAAAA
            111111AAAAAAAAAA     DDDDDDDD   Schem   function
HEX         5432109876543210 R/W 76543210   name
0000-3FFF                                           Game ROM
4000-47FF                                           Working ram
5000-57FF   01010AAAAAAAAAAA R/W DDDDDDDD   !Vram   Character ram           
5800-583F   01011AAAAAAAAAAA R/W DDDDDDDD   !OBJRAM Screen attributes
5840-585F   01011AAAAAAAAAAA R/W DDDDDDDD   !OBJRAM Sprites
5860-5FFF   01011AAAAAAAAAAA R/W DDDDDDDD   !OBJRAM Bullets
6000        0110000000000000 R   -------D   !SW0    coin1
6000        0110000000000000 R   ------D-   !SW0    coin2
6000        0110000000000000 R   -----D--   !SW0    p1 left
6000        0110000000000000 R   ----D---   !SW0    p1 right
6000        0110000000000000 R   ---D----   !SW0    p1shoot
6000        0110000000000000 R   --D-----   !SW0    upright/cocktail
6000        0110000000000000 R   -D------   !SW0    test
6000        0110000000000000 R   D-------   !SW0    service
6000        0110000000000001 W   -------D   !DRIVER lamp 1
6001        0110000000000001 W   -------D   !DRIVER lamp 2
6002        0110000000000001 W   -------D   !DRIVER coin lockout
6003        0110000000000011 W   -------D   !DRIVER coin control
6004        0110000000000100 W   -------D   !DRIVER Background lfo freq bit0
6005        0110000000000101 W   -------D   !DRIVER Background lfo freq bit1
6006        0110000000000110 W   -------D   !DRIVER Background lfo freq bit2
6007        0110000000000111 W   -------D   !DRIVER Background lfo freq bit3
6800        0110100000000000 R   -------D   !SW1    1p start
6800        0110100000000000 R   ------D-   !SW1    2p start
6800        0110100000000000 R   -----D--   !SW1    p2 left
6800        0110100000000000 R   ----D---   !SW1    p2 right
6800        0110100000000000 R   ---D----   !SW1    p2 shoot
6800        0110100000000000 R   --D-----   !SW1    no used
6800        0110100000000000 R   -D------   !SW1    dip sw1
6800        0110100000000000 R   D-------   !SW1    dip sw2
6800        0110100000000000 W   -------D   !SOUND  reset background F1
                                                    (1=reset ?)
6801        0110100000000001 W   -------D   !SOUND  reset background F2
6802        0110100000000010 W   -------D   !SOUND  reset background F3
6803        0110100000000011 W   -------D   !SOUND  player hit
6804        0110100000000100 W   -------D   !SOUND  not used
6805        0110100000000101 W   -------D   !SOUND  shoot on/off
6806        0110100000000110 W   -------D   !SOUND  Vol of f1
6807        0110100000000111 W   -------D   !SOUND  Vol of f2

7000        0111000000000000 R   -------D   !DIPSW  dip sw 3
7000        0111000000000000 R   ------D-   !DIPSW  dip sw 4
7000        0111000000000000 R   -----D--   !DIPSW  dip sw 5
7000        0111000000000000 R   ----D---   !DIPSW  dip s2 6
7001/B000/1 0111000000000001 W   -------D   9Nregen NMIon
7002        Unused - thanks to Phil Murray for letting me know
7003        Unused
7004        0111000000000100 W   -------D   9Nregen stars on  
7006        0111000000000110 W   -------D   9Nregen hflip
7007        0111000000000111 W   -------D   9Nregen vflip
Note: 9n reg,other bits  used on moon cresta for extra graphics rom control.
7800        0111100000000000 R   --------   !wdr    watchdog reset
7800        0111100000000000 W   DDDDDDDD   !pitch  Sound Fx base frequency
*/

/*
DIP SWITCH SETTINGS

Taken from: http://arcarc.xmission.com/PDF_Arcade_Bally_Midway/Galaxian_Parts_and_Operating_Manual_(Feb_1980).pdf

METHOD OF PLAY:
                              SW.1          SW.2
1 COIN = 1 PLAY               OFF           OFF
2 COINS = 1 PLAY              ON            OFF
1 COIN = 2 PLAYS              OFF           ON
FREE PLAY                     ON            ON 


BONUS GALIXIP (PLAYER SHIP) - the manual above is not correct with the Namco Galaxian ROM. After doing some research,
here are the correct DIP switch settings: 


                              SW.3          SW.4
7000                          OFF           OFF  
10000                         ON            OFF
12000                         OFF           ON
20000                         ON            ON


NUMBER OF GALIXIP PER GAME
                               SW.5
2 GALIXIP PER GAME             OFF
3 GALIXIP PER GAME             ON

*/


/*
And now, the main game code.... enjoy.
*/

** variables

VARIABLES_START:
DIP_SWITCH_1_2_STATE:                |  $4000         ; holds state of dip switches 1 & 2 in bits 0 & 1.
	ds.b	0x01
COIN_COUNT:                          |  $4001         ; counts up to number of coins per credit as set by dip switches. When it reaches that value, resets to 0 
	ds.b	0x01
NUM_CREDITS:                         |  $4002         ; number of credits
	ds.b	0x01
COIN_CONTROL:                        |  $4003         ; is used to output to DRIVER|COIN CONTROL (see $1974)
	ds.b	0x01
UNPROCESSED_COINS:                   |  $4004         ; bumps up when coin inserted. See $190B and $1931.

*
* The game follows what I call "scripts". A SCRIPT is a predefined sequence of STAGES (ie: subroutines) that implement an overall goal.
* The whole game is script-driven, from attract mode to the game itself.
*
* The NMI interrupt handler uses SCRIPT_NUMBER ($4005) to identify what script to run and, depending on the script, SCRIPT_STAGE ($400A) to 
* determine what subroutine to call to do the work for that stage of the script.  When the subroutine has completed its work, 
* it increments SCRIPT_STAGE which is akin to, "OK, I'm done; proceed to next stage of script".
*
* For example, a script for HELLO WORLD might be implemented as three stages:
* 1. Display Hello World on screen. Set SCRIPT_STAGE to 2.
* 2. Wait for key. Set SCRIPT_STAGE to 3 after key pressed.
* 3. Terminate program.
*
* When I've finished working out what all the scripts do, I'll replace the Hello World above with a real example from the game.
*
*
* The main take-aways from the above are:
* 1. The whole game is driven by the NMI interrupt.
* 2. Script stage and number are really just indexes into jump tables. 
*
* see $00CA for the NMI script handler. 

	ds.b	0x01
SCRIPT_NUMBER:                       |  $4005         ; 0-based index into pointer table beginning @ $00CE
	ds.b	0x01
IS_GAME_IN_PLAY:                     |  $4006         ; If set to 1, game is in play with a human in control.
	ds.b	0x01
IS_GAME_OVER:                        |  $4007         ; Set to 1 when GAME OVER message appears. TODO: Check if set any other place than GAME OVER 
	ds.b	0x01
TEMP_COUNTER_1:                      |  $4008         ; temporary counter used for delays, such as waiting before transitioning to next stage of a script
	ds.b	0x01
TEMP_COUNTER_2:                      |  $4009         ; temporary counter used for delays								 |
	ds.b	0x01
SCRIPT_STAGE:                        |  $400A         ; Identifies what stage of the script we are at.  
                                     |                ; 0-based index into script tables located @ $0164, $0400, $0540, $0785
	ds.b	0x01
	.align	2
TEMP_CHAR_RAM_PTR:                   |  $400B         ; pointer to character RAM. Used by screen-related routines (e.g. power on colour test) to remember where to plot characters on next call.                                   |                                                                     
	.word	0
CURRENT_PLAYER:                      |  $400D         ; 0 = PLAYER ONE, 1 = PLAYER TWO
	ds.b	0x01
IS_TWO_PLAYER_GAME:                  |  $400E         ; 0 = One player game, 1 = 2 player game 
	ds.b	0x01
IS_COCKTAIL:                         |  $400F         ; 0 = upright, 1 = Cocktail 
	ds.b	0x01
PORT_STATE_6000:                     |  $4010         ; copy of state for memory address 6000 (SW0)          
	ds.b	0x01
PORT_STATE_6800:                     |  $4011         ; copy of state for memory address 6800 (SW1 & SOUND)
	ds.b	0x01
PORT_STATE_7000:                     |  $4012         ; copy of state for memory address 7000 (DIPSW)
	ds.b	0x01
PREV_PORT_STATE_6000:                |  $4013         ; holds the previous state of memory address 6000 (SW0)  
	ds.b	0x01
PREV_PORT_STATE_6800:                |  $4014         ; holds the previous state of memory address 6800 (SW1 & SOUND)
	ds.b	0x01
PREV_PREV_PORT_STATE_6000:           |  $4015         ; holds the previous, previous (!) state of memory address 6000 (SW0) 
	ds.b	0x01
PREV_PREV_PREV_STATE_6000:           |  $4016         ; holds the previous, previous, previous state of memory address 6000 (SW0)
									 |
	ds.b	0x02
DISPLAY_IS_COCKTAIL_P2:              |  $4018         ; set to 1 when in cocktail mode and it's player 2's turn, so the screen's upside down.
	ds.b	0x01
PUSH_START_BUTTON_COUNTER:           |  $4019         ; On inserting credit or GAME OVER: if you have credit, how long to wait before PUSH START BUTTON appears.  
	ds.b	0x01
DIAGNOSTIC_MESSAGE_TYPE:             |  $401A         ; Read by the NMI handler. Refer to code @1BCD for docs.  
									 |
	ds.b	0x04
RAND_NUMBER:                         |  $401E         ; TENTATIVE NAME. Random number used in tests and in-game 
	ds.b	0x01
DIP_SWITCH_5_STATE:                  |  $401F         ; holds cached state of dip switch 5 in bit 0

* Object RAM back buffer. 
* Colour attributes, scroll offsets and sprite state are held in this buffer and updated by the game. 
* When all the updates are complete and ready to be presented on screen to the player, 
* the back buffer is copied to the hardware's OBJRAM by an LDIR operation - see $0079.
* Effectively all colours, scroll and sprites are updated as part of a single operation.
* This back buffering technique is still used today in modern games.
*
* The back buffer is organised thus:
*
* From $4020 - 405f: column scroll and colour attributes. Maps directly to $5800 - $583F. 
*    Note: Even numbered addresses hold scroll offsets, odd numbered addresses colour attributes. 
* From $4060 - 407F: 8 entries of type INFLIGHT_ALIEN_SPRITE. Maps directly to $5840 - $585F.
* From $4080 - 409F: alien bullets and player bullet sprite state. Maps directly to $5860 - $587F. 

	ds.b	0x01
OBJRAM_BACK_BUF:                     |  $4020            
	ds.b	0x40
OBJRAM_BACK_BUF_SPRITES:             |  $4060 

*struct INFLIGHT_ALIEN_SPRITE
*{
*   BYTE Y;                      
*   BYTE Code;                   * bits 0..5: sprite frame. bit 6 set = XFlip. bit 7 set = YFlip
*   BYTE Colour;
*   BYTE X;                      
*} - sizeof(INFLIGHT_ALIEN_SPRITE) is 4 bytes


	ds.b	0x20
OBJRAM_BACK_BUF_BULLETS:             |  $4080
	ds.b	0x1d
OBJRAM_BUF_PLAYER_BULLET_Y:          |  $409D
	ds.b	0x02
OBJRAM_BUF_PLAYER_BULLET_X:          |  $409F
OBJRAM_BACK_BUF_END:                 |  $409F                        

	ds.b	0x01
	.align	2
CIRC_CMD_QUEUE_PTR:           		|  $40A0             ; pointer to a (hopefully) vacant entry in the circular queue. See $08F2 
	.long	0
CIRC_CMD_QUEUE_PROC:          |  $40A1             ; (low byte of a ) pointer to the next entry in the circular queue to be processed. See $200C
	.long	0
PLAYER_ONE_SCORE:                      |  $40A2       | stored as 3 BCD bytes, 2 digits per byte: $40A2 = last 2 digits of score (tens), $40A3 = 3rd & 4th digits, $40A4 = 1st & 2nd

                                                      | e.g. a score of 123456 would be stored like so:
                                                      | $40A2: 56
                                                      | $40A3: 34
                                                      | $40A4: 12
													  |
	ds.b	0x03
PLAYER_TWO_SCORE:                      |  $40A5       | stored as 3 BCD bytes, 2 digits per byte: same format & order as PLAYER_ONE_SCORE
	ds.b	0x03
HI_SCORE:                              |  $40A8       | ; stored as 3 BCD bytes, 2 digits per byte: same format & order as PLAYER_ONE_SCORE
													  |
	ds.b	0x03
CAN_BLINK_1UP_2UP:                     |  $40AB       | ; When IS_GAME_IN_PLAY is set to 1, this flag is set to 1 to allow 1UP or 2UP to "blink". See @$20A7
	ds.b	0x01
BONUS_GALIXIP_FOR:                     |  $40AC       | ; stored as BCD in 1 byte. e.g. 07 = bonus galixip for 7000, 20 = bonus galixip for 20000. 
	ds.b	0x01
PLAYER_ONE_AWARDED_EXTRA_LIFE:         |  $40AD       | Set to 1 if player one has been awarded an extra life. No more extra lives will be given. 
	ds.b	0x01
PLAYER_TWO_AWARDED_EXTRA_LIFE:         |  $40AE       | Set to 1 if player two has been awarded an extra life. No more extra lives will be given. 
													  |
													  |
	ds.b	0x02
IS_COLUMN_SCROLLING:                 |  $40B0         | Set to 1 if a column is being scrolled. For example when points are scrolled into view on the WE ARE THE GALAXIANS screen
	ds.b	0x01
	.align	2
COLUMN_SCROLL_ATTR_BACKBUF_PTR:      |  $40B1         | pointer to scroll attribute data to update in OBJRAM_BACK_BUF. 
	.word	0
COLUMN_SCROLL_NEXT_CHAR_PTR:         |  $40B3         | pointer to ordinal of next character to scroll on
	.word	0
COLUMN_SCROLL_CHAR_RAM_PTR:          |  $40B5         | pointer to character RAM where next character will be plotted. 
	.word	0

* Phil Murray (PhilMurr on UKVAC) gave me a heads up on this.  
*
* $40C0 to $40FF is reserved for a circular queue. The queue is comprised of byte pairs representing a command and parameter.
* NB: I term the byte pair a *Queue Entry* in the code @$08f2 and $200A.
*
* As 64 bytes are reserved for the queue, that means 32 commands and parameters can be stored. 
*
* The memory layout of the queue is quite simple.
* 
* $40C0: command A
* $40C1: parameter for command A 
* $40C2: command B
* $40C3: parameter for command B
* $40C4: command C
* $40C5: parameter for command C
* ..and so on.
*
* See docs @ $08f2 for info about what commands are available, and how to add commands to the queue.
* See docs @ $200A for info about how commands are processed.
*


	.align	2
CIRC_CMD_QUEUE_START:            |  $40C0
	ds.b	0x40
CIRC_CMD_QUEUE_END:              |  $4100


*
* ALIEN_SWARM_FLAGS (name subject to change) is an array 128 bytes in size.   
* Each byte contains a bit flag indicating the presence of an alien at a given position.
* If you start a new game in MAME, then open the debugger and view memory location 4100 (hex) you will see this:
*
* 4100:  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  
* 4110:  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  
* 4120:  00 00 00 01 01 01 01 01 01 01 01 01 01 00 00 00  
* 4130:  00 00 00 01 01 01 01 01 01 01 01 01 01 00 00 00  
* 4140:  00 00 00 01 01 01 01 01 01 01 01 01 01 00 00 00  
* 4150:  00 00 00 00 01 01 01 01 01 01 01 01 00 00 00 00  
* 4160:  00 00 00 00 00 01 01 01 01 01 01 00 00 00 00 00  
* 4170:  00 00 00 00 00 00 01 00 00 01 00 00 00 00 00 00     
*
* This is the representation of the swarm in memory! 01 means "an alien is here" and 00 means "nothing here".
* The memory representation is upside down *and* flipped horizontally.  
*
* To visualise it properly, turn the dump above upside down using your favourite text editor, erase the "00"s and you get:
* 4170:                    01       01                       ; flagships
* 4160:                 01 01 01 01 01 01                    ; red
* 4150:              01 01 01 01 01 01 01 01                 ; purple
* 4140:           01 01 01 01 01 01 01 01 01 01              ; blue
* 4130:           01 01 01 01 01 01 01 01 01 01              ; blue
* 4120:           01 01 01 01 01 01 01 01 01 01              ; blue
* 
* Look familiar? 
*
*  

ALIEN_SWARM_FLAGS:                   *  $4100         ; 128 bytes, occupying $4100 to $417F in RAM


* When it's player 1's turn, the packed swarm definition PLAYER_ONE_PACKED_SWARM_DEF is unpacked to ALIEN_SWARM_FLAGS and the fields comprising PLAYER_ONE_STATE ($4190-4197) 
* are written to their counterparts in CURRENT_PLAYER_STATE (see docs @$4218)                
	ds.b	0x81
PLAYER_ONE_PACKED_SWARM_DEF:           |  $4180       ; Used to track state of the swarm for player one, e.g. so swarm can be restored after player two's turn is over 
	ds.b	0x10
PLAYER_ONE_STATE:                      |  $4190
PLAYER_ONE_DIFFICULTY_COUNTER_1:       |  $4190         
	ds.b	0x01
PLAYER_ONE_DIFFICULTY_COUNTER_2:       |  $4191
	ds.b	0x01
PLAYER_ONE_DIFFICULTY_EXTRA_VALUE:     |  $4192           
	ds.b	0x01
PLAYER_ONE_DIFFICULTY_BASE_VALUE:      |  $4193         
	ds.b	0x01
PLAYER_ONE_LEVEL:                      |  $4194
	ds.b	0x01
PLAYER_ONE_LIVES:                      |  $4195
	ds.b	0x01
PLAYER_ONE_FLAGSHIP_SURVIVOR_COUNT:    |  $4196         
	ds.b	0x01
PLAYER_ONE_LFO_FREQ_BITS:              |  $4197         


* When it's player 2's turn, the packed swarm definition PLAYER_TWO_PACKED_SWARM_DEF is unpacked to ALIEN_SWARM_FLAGS and the fields comprising PLAYER_TWO_STATE ($41B0-41B7) 
* are written to their counterparts in CURRENT_PLAYER_STATE (see docs @$4218)                
	ds.b	0x09
PLAYER_TWO_PACKED_SWARM_DEF:           |  $41A0       ; Used to track state of the swarm for player two, e.g. so swarm can be restored after player one's turn is over
	ds.b	0x10
PLAYER_TWO_STATE:                      |  $41B0
PLAYER_TWO_DIFFICULTY_COUNTER_1:       |  $41B0         
	ds.b	0x01
PLAYER_TWO_DIFFICULTY_COUNTER_2:       |  $41B1
	ds.b	0x01
PLAYER_TWO_DIFFICULTY_EXTRA_VALUE:     |  $41B2           
	ds.b	0x01
PLAYER_TWO_DIFFICULTY_BASE_VALUE:      |  $41B3         
	ds.b	0x01
PLAYER_TWO_LEVEL:                      |  $41B4
	ds.b	0x01
PLAYER_TWO_LIVES:                      |  $41B5
	ds.b	0x01
PLAYER_TWO_FLAGSHIP_SURVIVOR_COUNT:    |  $41B6         
	ds.b	0x01
PLAYER_TWO_LFO_FREQ_BITS:              |  $41B7         


	ds.b	0x09
SOUND_VOL:                           |  $41C0         ; Bit 0 and 1 are written to !SOUND Vol of F1 and !SOUND Vol of F2 respectively. See $1712
	ds.b	0x01
PITCH_SOUND_FX_BASE_FREQ:            |  $41C1         ; used to write to !pitch  Sound Fx base frequency. See $171F
	ds.b	0x01
ENABLE_ALIEN_ATTACK_SOUND:           |  $41C2         ; When set to 1, turns on alien attack noise, see $17D0
	ds.b	0x01
UNKNOWN_SOUND_41C3:                  |  $41C3          
	ds.b	0x01
UNKNOWN_SOUND_41C4:                  |  $41C4         ; Seems to affect the pitch of the alien attack noise. 
									 |
	ds.b	0x03
PLAY_EXTRA_LIFE_SOUND:               |  $41C7         ; when set to 1, play the sound of an extra life being awarded. See $184F
	ds.b	0x01
EXTRA_LIFE_SOUND_COUNTER:            |  $41C8            
	ds.b	0x01
PLAY_PLAYER_CREDIT_SOUND:            |  $41C9         ; when set to 1, play the sound of player credits being added. See $1876
	ds.b	0x01
PLAYER_CREDIT_SOUND_COUNTER:         |  $41CA         ; The higher the value, the longer the player credit sound plays.:
                                     |  $41CB          
	ds.b	0x02
PLAY_PLAYER_SHOOT_SOUND:             |  $41CC         ; When set to 1, play the sound of the player's bullet. See $1723
	ds.b	0x01
IS_COMPLEX_SOUND_PLAYING:            |  $41CD         ; When set to 1, a sequence of sounds, or a melody, is playing. 
	ds.b	0x01
PLAYER_SHOOT_SOUND_COUNTER:          |  $41CE         ; The higher the value, the longer the player spaceship bullet sound plays.:
                                     |  $41CF 
	ds.b	0x02
RESET_SWARM_SOUND_TEMPO:             |  $41D0         ; When set to 1, resets the tempo of the "swarm" sound to slow again. See $1898
	ds.b	0x01
PLAY_GAME_START_MELODY:              |  $41D1         ; When set to 1, plays the game start tune.: 
                                     |  $41D2         ; sound related
	ds.b	0x02
COMPLEX_SOUND_POINTER:               |  $41D3         ; If music or complex sound effect is playing, this points to the current sound/musical note being played. See $1782:
                                     |  $41D5         ; Used to set !Pitch Sound FX base frequency
	ds.b	0x03
DELAY_BEFORE_NEXT_SOUND:             |  $41D6         ; counter. When counts to zero the next sound/musical note is played. See $177B
	ds.b	0x09
ALIEN_DEATH_SOUND:                   |  $41DF         ; Tentative name. When set to $06: plays alien death sound. When set to $16, plays flagship death sound. See @$1819:
                                     |  $41E8

* HAVE_ALIENS_IN_ROW_FLAGS is an array of 6 bytes. Each byte contains a bit flag specifying if there are any aliens on a given row.
	ds.b	0x09
HAVE_ALIENS_IN_ROW_FLAGS:            |  $41E8
NEVER_USED_ROW_1:                    |  $41E8
	ds.b	0x01
NEVER_USED_ROW_2:                    |  $41E9

	ds.b	0x01
HAVE_ALIENS_IN_6TH_ROW:              |  $41EA         ; flag set to 1 if there are any aliens in the bottom row (blue aliens)
	ds.b	0x01
HAVE_ALIENS_IN_5TH_ROW:              |  $41EB         ; flag set to 1 if there are any aliens in the 5th row (blue aliens)
	ds.b	0x01
HAVE_ALIENS_IN_4TH_ROW:              |  $41EC         ; flag set to 1 if there are any aliens in the 4th row (blue aliens)
	ds.b	0x01
HAVE_ALIENS_IN_3RD_ROW:              |  $41ED         ; flag set to 1 if there are any aliens in the 3rd row (purple aliens)
	ds.b	0x01
HAVE_ALIENS_IN_2ND_ROW:              |  $41EE         ; flag set to 1 if there are any aliens in the 2nd row (red aliens)
	ds.b	0x01
HAVE_ALIENS_IN_TOP_ROW:              |  $41EF         ; flag set to 1 if there are any aliens in the top row (flagships)


* ALIEN_IN_COLUMN_FLAGS is an array 16 bytes in size. Each byte contains a bit flag specifying if there are any aliens in a specific column. 
* IMPORTANT: The flags are ordered from rightmost column of aliens to the leftmost. Only 10 of the flags are used.
* 
* In a nutshell:
* $41F0..$41F2: unused. Always set to 0.
* $41F3: set to 1 if any aliens are in the rightmost column of the swarm.
* $41F4: set to 1 if any aliens are in the 2nd rightmost column of the swarm.
* $41F5: set to 1 if any aliens are in the 3rd rightmost column of the swarm.
* ..
* $41FC: set to 1 if any aliens are in the leftmost column of the swarm.
* $41FD..$41FF: unused. Always set to 0.
*
* The flags have three purposes: 
* 1: To halt the swarm when a bullet is getting too close (see $0936)
* 2: to calculate how far the swarm can scroll before it needs to change direction (see $093E)
* 3: to find aliens at the swarm edges to attack the player (see code from $137B onwards) 
*
*
* To further clarify in case there's any confusion, let's assume you've just started the game and you're on the first level. 
* You haven't shot anything yet. The alien swarm will be in the following formation:
*
*      F  F                     F = Flagship row  
*     RRRRRR                    R = Red alien row
*    PPPPPPPP                   P = Purple alien row
*   BBBBBBBBBB                  B = Blue alien row
*   BBBBBBBBBB
*   BBBBBBBBBB 
*
* Press PAUSE in MAME and open the memory debugger at location $41F0.
* The flags will look like so in the MAME memory window:
* 00 00 00 01 01 01 01 01 01 01 01 01 01 00 00 00
*
* You'll note that there are 10 flags set to TRUE (01) in a row. That is because the bottommost row has 10 blue aliens. 
* If you were to shoot the blue aliens in the rightmost column, you would see the first 01 (at memory address $41F3) turn into a 0, 
* meaning that column no longer contains any aliens. 
* 
* 0 is also written to the flags when the only alien in a column breaks off from the swarm to attack the player.
* 
                                           
	ds.b	0x01
ALIEN_IN_COLUMN_FLAGS:               |  $41F0          
	ds.b	0x0f
ALIEN_IN_COLUMN_FLAGS_END:           |  $41FF     


	ds.b	0x01
HAS_PLAYER_SPAWNED:                  |  $4200         | set to 1 when player has spawned. (Also set in attract mode) 
	ds.b	0x01
IS_PLAYER_DYING:                     |  $4201         | set to 1 when player is in the process of exploding horribly. See $1327
	ds.b	0x01
PLAYER_Y:                            |  $4202         | Player Y coordinate. Used to set scroll offsets for column containing ship characters. See $0865
													  |
	ds.b	0x02
IS_PLAYER_HIT:                       |  $4204         | When set to 1, player has been hit by a missile or collided with an alien.         
	ds.b	0x01
PLAYER_EXPLOSION_COUNTER:            |  $4205         | Only evaluated when IS_PLAYER_DYING is set to 1. Determines how long the player explosion animation lasts. 
                                                      | When it counts down to 0, explosion animation stops. See $132C
	ds.b	0x01
PLAYER_EXPLOSION_ANIM_FRAME:         |  $4206         | Set by $12FE 
	ds.b	0x02
HAS_PLAYER_BULLET_BEEN_FIRED:        |  $4208         | set 1 when the player has fired a bullet and the bullet is still onscreen. See $08BC
	ds.b	0x01
PLAYER_BULLET_X:                     |  $4209         | Current X coordinate of player bullet. 
	ds.b	0x01
PLAYER_BULLET_Y:                     |  $420A         | Current Y coordinate of player bullet. 
	ds.b	0x01
IS_PLAYER_BULLET_DONE:               |  $420B         | set 1 when player bullet goes as far as it can upscreen (see $08CD), or hits an alien (see $0B4F & $125B).
													  |
	ds.b	0x02
SWARM_DIRECTION:                     |  $420D         | Direction of swarm (really? ;) )  0 = Moving left, 1 = moving right . See $0945              
	ds.b	0x01
SWARM_SCROLL_VALUE:                  |  $420E         | 16 bit value. Used to set the scroll values for the character columns containing the swarm.                            
	ds.b	0x02
SWARM_SCROLL_MAX_EXTENTS:            |  $4210         | Used to limit the scrolling of the swarm so no alien goes "off screen". See $09CE 

* INFLIGHT_ALIEN_SHOOT_EXACT_X and MINFLIGHT_ALIEN_SHOOT_RANGE_MUL are used to determine if an alien can shoot a bullet. See $0E54 for information.
	ds.b	0x03
INFLIGHT_ALIEN_SHOOT_RANGE_MUL:      |  $4213         ; Range multiplier.   
	ds.b	0x01
INFLIGHT_ALIEN_SHOOT_EXACT_X:        |  $4214         ; Exact X coordinate that calculated value must match for alien to shoot.

	ds.b	0x01
ALIENS_ATTACK_FROM_RIGHT_FLANK:      |  $4215         ; Flag used to determine what side of swarm aliens break off from. (0=break from left, 1=break from right). See $136f and $1426: 
                                     |  $4217         ; 

* $4218 - $421F holds important, albeit transient, state for the current player such as number of lives and difficulty level.
	ds.b	0x03
CURRENT_PLAYER_STATE:                |  $4218                    

* These 2 counters are used to gradually increase the DIFFICULTY_EXTRA_VALUE over time. See $14F3 for algorithm details.
DIFFICULTY_COUNTER_1:                |  $4218         ; Counts down to zero. 
	ds.b	0x01
DIFFICULTY_COUNTER_2:                |  $4219         ; Counts down to zero. When it reaches zero, DIFFICULTY_EXTRA_VALUE is incremented.

* These values determine how often aliens attack (see $1524 and $1583), and how many can attack at one time (see $1352). 
	ds.b	0x01
DIFFICULTY_EXTRA_VALUE:              |  $421A         ; DIFFICULTY_EXTRA_VALUE is incremented during the level. Maximum value of 7. See $1509.  
	ds.b	0x01
DIFFICULTY_BASE_VALUE:               |  $421B         ; DIFFICULTY_BASE_VALUE is incremented when you complete a level. Maximum value of 7. See $1656.

	ds.b	0x01
PLAYER_LEVEL:                        |  $421C         ; Current player's level. Starts from 0. Add 1 to get true value. See $252C.
	ds.b	0x01
PLAYER_LIVES:                        |  $421D         ; current player's lives
	ds.b	0x01
FLAGSHIP_SURVIVOR_COUNT:             |  $421E         ; When starting a new level, how many surviving flagships can we bring over from the previous level? Maximum value 2.  See $166C
	ds.b	0x01
LFO_FREQ_BITS:                       |  $421F         ; Value used to set !DRIVER Background lfo frequency ports (0-3) for the "swarm" noise

CURRENT_PLAYER_STATE_END:            |  $421F                

	ds.b	0x01
HAVE_NO_ALIENS_IN_SWARM:             |  $4220         ; Set to 1 when $4100 - $417F are set to 0. Aliens are either all dead, or are in flight and out of the swarm. See $0A0F
	ds.b	0x01
HAVE_NO_BLUE_OR_PURPLE_ALIENS:       |  $4221         ; When set to 1, all the blue and purple aliens have died, or are in flight. See $09FA and $1571  
	ds.b	0x01
LEVEL_COMPLETE:                      |  $4222         ; When set to 1, the level is treated as complete. See @$1621, $1637
	ds.b	0x01
NEXT_LEVEL_DELAY_COUNTER:            |  $4223         ; After all aliens have fled or been killed, this counts down to give the player breathing space. When it hits 0, the next wave starts. See $1637
	ds.b	0x01
HAVE_AGGRESSIVE_ALIENS:              |  $4224         ; when set to 1, inflight aliens will not return to swarm and keep attacking player until they die - or you die. See $16B8
	ds.b	0x01
HAVE_NO_INFLIGHT_OR_DYING_ALIENS:    |  $4225         ; When set to 1, there are no aliens inflight, or dying. See $06BC
	ds.b	0x01
HAVE_NO_INFLIGHT_ALIENS:             |  $4226         ; When set to 1, no aliens have broken off from the swarm to attack the player.
	ds.b	0x02
CAN_ALIEN_ATTACK:                    |  $4228         ; When set to 1, a single alien should break off from the swarm to attack the player. See $1344.
	ds.b	0x01
CAN_FLAGSHIP_OR_RED_ALIENS_ATTACK:   |  $4229         ; When set to 1, a flagship should attack the player, with an escort if possible. If no flagships alive, send red aliens.  See $140C.
	ds.b	0x01
FLAGSHIP_ESCORT_COUNT:               |  $422A         ; Number of red aliens escorting the flagship. Max value of 2. See $0D58.

* When you shoot an enemy flagship in flight that this puts the aliens into a state of "shock" where they are afraid to leave the swarm for a while.
* No aliens will leave the swarm while $422B is set to 1 and $422C is non-zero. 
	ds.b	0x01
IS_FLAGSHIP_HIT:                     |  $422B         ; Set to 1 when you've shot a flagship in flight. See $127C  
	ds.b	0x01
ALIENS_IN_SHOCK_COUNTER:             |  $422C         ; When $422B is set to 1, this counter decrements. When it hits 0, $422B will be set to 0, meaning aliens can leave the swarm again.  
	ds.b	0x01
FLAGSHIP_SCORE_FACTOR:               |  $422D         ; When you shoot a flagship, this is used to compute your score. Couldn't think of a better name! See $127C

	ds.b	0x01
ENABLE_FLAGSHIP_ATTACK_SECONDARY_COUNTER:      |  $422E         ; when set to 1, FLAGSHIP_ATTACK_SECONDARY_COUNTER is allowed to decrement.             
	ds.b	0x01
FLAGSHIP_ATTACK_SECONDARY_COUNTER:   |  $422F         ; Counts down to 0. When reaches zero, CAN_FLAGSHIP_OR_RED_ALIENS_ATTACK will be set to 1.

	ds.b	0x09
DISABLE_SWARM_ANIMATION:             |  $4238         ; When set to 1, alien swarm won't animate. See $2067 for docs. 
	ds.b	0x07
ATTRACT_MODE_FAKE_CONTROLLER:        |  $423F         ; used to simulate a players movements on the ATTRACT MODE screen. Contains bit values that map to SW0.
	ds.b	0x02
ATTRACT_MODE_SCROLL_ID:              |  $4241         ; Identifies what points values are being scrolled in on attract mode. 1:Flagship. 2: Red Alien. 3: Purple alien. 4: Blue alien. 

* These 2 counters are used to determine when a flagship is permitted to attack.  See $156A.
	ds.b	0x04
FLAGSHIP_ATTACK_MASTER_COUNTER_1:    |  $4245          
	ds.b	0x01
FLAGSHIP_ATTACK_MASTER_COUNTER_2:    |  $4246          

* ALIEN_ATTACK_COUNTERS is an array of BYTE counters that control when aliens (but not flagships) break off from the swarm to attack. 
* ALIEN_ATTACK_MASTER_COUNTER at $424A is the first element of the array. The secondary counters are stored in $424B to $425A. 
* The ALIEN_ATTACK_MASTER_COUNTER acts as a gateway to the secondary counters; only when the master counter reaches zero will the secondary counters in the array be decremented.
* If any of the secondary counters reach zero, an alien will attack the player. See $1532 for more info.
	ds.b	0x04
ALIEN_ATTACK_COUNTERS:               |  $424A  
ALIEN_ATTACK_MASTER_COUNTER:         |  $424A
	ds.b	0x11
ALIEN_ATTACK_SECONDARY_COUNTERS:     |  $425B         
	ds.b	0x04
ALIEN_ATTACK_SECONDARY_COUNTERS_END: |  $425F     


TIMING_VARIABLE:                     |  $425F         ; Perpetually decremented by the NMI handler. Routines use this variable to determine when to execute.
                                                         

* ENEMY_BULLETS is an array of type ENEMY_BULLET. 
*
* The array occupies memory locations $4260 - $42A5; It is thus 70 bytes in size. 
* As an ENEMY_BULLET record only requires 5 bytes, this means that there's room for 14 enemy bullets in the array.
*

* struct ENEMY_BULLET

*IsActive = 0
*X = 1
*YL = 2                                       | low byte of the Y coordinate. Used to represent "fractional part" of Y coordinate
*YH = 3                                       | high byte of the Y coordinate.  
*YDelta = 4                                   | packed delta to add to YH *and* YL. Bit 7 = sign bit. Bits 0-6 = delta. See @$0AA1.                                  
* - sizeof(ENEMY_BULLET) is 5 bytes

	ds.b	0x01
ENEMY_BULLETS:                       |  $4260
ENEMY_BULLETS_START:                 |  $4260                                                                        
	ds.b	0x45
ENEMY_BULLETS_END:                   |  $42A5

	* macro to stop program with a direct error code
	* when using whdload (amiga)
	.macro	TODOM	item
	tst.l	0xFF000000+\item
	.endm
	
* INFLIGHT_ALIENS is an array of type INFLIGHT_ALIEN. 
* An "Inflight alien" is my term for an alien that has broken off from the main swarm body to attack the player. 
*
* The array occupies memory locations $42B0 - $43AF; It is thus 256 bytes in size. 
* As the INFLIGHT_ALIEN type is 32 bytes in size, this means that there's room for 8 entries in the array. 
*
* Slot 0 in the array is actually reserved for misc use, such as when you shoot an alien in the swarm body and an 
* explosion animation needs a free sprite to play. (See: $0B52 for an example of this)
*
* Slot  1 is reserved for the flagship. 
* Slots 2 and 3 are reserved for the flagship's escorts.
* Slots 4,5,6,7 are reserved for individual attacking aliens.
*
* This means there can be 7 aliens in flight maximum. 
*
*  

*
* struct INFLIGHT_ALIEN

IsActive              = 0x0            | Set to 1 when the alien is to be processed. 
IsDying               = 0x1            | Set to 1 when the alien is in the process of exploding.
StageOfLife           = 0x2            | See $0CD6 for details. 
inf_alien_X                     = 0x3            | X coordinate
inf_alien_Y                     = 0x4            | Y coordinate. 
AnimationFrame        = 0x5            |
ArcClockwise          = 0x6            | Set to 1 if the alien will rotate clockwise as it leaves the swarm or loops the loop. See $0D71 and $101F
IndexInSwarm          = 0x7            | index of alien within ALIEN_SWARM_FLAGS array
PivotYValue           = 0x9            | When alien is attacking, this value + $19 produces INFLIGHT_ALIEN.Y coordinate. See $0DF6
AnimFrameStartCode    = 0xF            | Base animation frame number to which a number is added to compute sprite "code"
TempCounter1          = 0x10           | Counter used for various timing purposes
TempCounter2          = 0x11           | Secondary counter for various timing purposes
DyingAnimFrameCode    = 0x12           | when IsDying is set to 1, specifies the animation frame to display. See @$0C9F
ArcTableLsb           = 0x13           | LSB of pointer into INFLIGHT_ALIEN_ARC_TABLE @$1E00. See docs @$0D71 and $1E00.
Colour                = 0x16           |
SortieCount           = 0x17           | Number of times the alien has reached the bottom of the screen then resumed attack on the player. Reset to 0 when rejoins swarm. See $0E9D.
Speed                 = 0x18           | Value from 0..3. The higher the number the faster the alien moves. See $116B. 
PivotYValueAdd        = 0x19           | Signed number which is added to INFLIGHT_ALIEN.PivotYValue to produce INFLIGHT_ALIEN.Y. See $0DF6

inflight_alien_size   = 0x20
          
*  - sizeof(INFLIGHT_ALIEN) is 32 bytes


	ds.b	0x0b
	.align	2
INFLIGHT_ALIENS:                     |  $42B0
	ds.b	inflight_alien_size*8
INFLIGHT_ALIENS_END:                 |  $43B0
VARIABLES_END:

	.align	0x100
bg_videoram:
CHARACTER_RAM:						| $5000
	ds.b	0x800
bg_colorram:
ATTRIBUTE_RAM:						| $5800
	ds.b	0x800

* start of code

*
* A very primitive pseudo-random number generator.
* (seems that it just multiplies by 5, adds 1 and wraps)
*

GENERATE_RANDOM_NUMBER:
	move.b	RAND_NUMBER(pc),d0
	move.b	d0,d1
	add.b	d0,d0
	add.b	d0,d0
	add.b	d0,d1
	addq.b	#1,d0
	move.b	d0,RAND_NUMBER
	rts

*
* Used by the aliens to determine what way to face when flying down, and what delta enemy bullets take
*
* (I have no idea how it works, just transcoded it as is)
*
* Expects:
* A = distance
* D = X coordinate
*

CALCULATE_TANGENT:
	move.w	d4,-(a7)
	moveq	#0,d2
	moveq.w	#8-1,d1	| do it 8 ties
0:
	cmp.b	d3,d0
	bcs.b	1f
	sub.b	d3,d0
1:
	* inverts carry (JOTD: clumsy & slow, but works)
	* z80 ccf instruction
	clr.b	d4
	roxl.b	#1,d4	| get carry in bit 0
	bchg	#0,d4	| change bit
	roxr.b	#1,d4	| put carry back
	roxl.b	#1,d2
	roxr.b	#1,d3
	dbf		d1,0b
	move.w	(a7)+,d4
	rts

galaxian_irq:
*TODO
* update screen in one go - IMPORTANT
*0079: 21 20 40      ld   hl,0x4020            | pointer to OBJRAM_BACK_BUF buffer held in RAM
*007C: 11 00 58      ld   de,0x5800            | start of screen attribute RAM
*007F: 01 80 00      ld   bc,0x0080            | number of bytes to copy from OBJRAM_BACK_BUF 
*0082: ED B0         ldir                     | update screen & sprites in one go

* read ports and stash values read in RAM
*0084: 3A 00 78      ld   a,(0x7800)           | kick the watchdog
*0087: 3A 15 40      ld   a,(0x4015)           | read previous, previous state of port 6000 (SW0)
*008A: 32 16 40      ld   (0x4016),a           | and write to PREV_PREV_PREV_STATE_6000 
*008D: 3A 13 40      ld   a,(0x4013)           | read previous state of port 6000 (SW0)
*0090: 32 15 40      ld   (0x4015),a           | and write to PREV_PREV_PORT_STATE_6000  
*0093: 2A 10 40      ld   hl,(0x4010)          | read state of 6000 (SW0) and 6800 (SW1 & SOUND)
*0096: 22 13 40      ld   (0x4013),hl          | and write to previous state value
*0099: 3A 00 70      ld   a,(0x7000)           | read state of DIPSW
*009C: 32 12 40      ld   (0x4012),a           | and write to PORT_STATE_7000 holder
*009F: 3A 00 68      ld   a,(0x6800)           | read start button, p2 control, dipsw 1/2 state 
*00A2: 32 11 40      ld   (0x4011),a           | and write to PORT_STATE_6800 holder
*00A5: 3A 00 60      ld   a,(0x6000)           | read coin, p1 control, test & service state
*00A8: 32 10 40      ld   (0x4010),a           | and write to PORT_STATE_6000 holder

		subq.b	#1,TIMING_VARIABLE             | decrement value
*TODO
*		jbsr CHECK_IF_COIN_INSERTED               | 
*jbsr HANDLE_UNPROCESSED_COINS
*jbsr HANDLE_SOUND
*jbsr HANDLE_SWARM_SOUND
*jbsr HANDLE_TEXT_SCROLL

* invoke script [SCRIPT_NUMBER]
	moveq	#0,d0
	move.b	SCRIPT_NUMBER(pc),d0
	add.w	d0,d0
	add.w	d0,d0
	lea		SCRIPT_TABLE(pc),a0
	move.l	(a0,d0.w),a0
	jmp		(a0)
	

SCRIPT_TABLE:
     .long	SCRIPT_ZERO   
     .long	SCRIPT_ONE
     .long	SCRIPT_TWO
     .long	SCRIPT_THREE
     .long	SCRIPT_FOUR
	

SCRIPT_ZERO:
		move.w	TEMP_CHAR_RAM_PTR(pc),d6	| Read TEMP_CHAR_RAM_PTR. This holds character RAM to start clearing from
		move.w	#0x20-1,d1                  | #0x20 (32 decimal) bytes to fill in a row
		move.w	#0x10,d0				| ordinal of empty character
0:
		jbsr	osd_w_bg_videoram
		addq.w	#1,d6
		dbf		d1,0b
		
		move.w	d6,TEMP_CHAR_RAM_PTR       | save in TEMP_CHAR_RAM_PTR
		subq.b	#1,TEMP_COUNTER_1        | decrement value
		beq.b	1f
		rts                          | if counter hasn't hit zero, return
1:
		move.b	#1,IS_GAME_OVER		| point HL to IS_GAME_OVER (set to 1)
		clr.b   IS_GAME_IN_PLAY     | point HL to IS_GAME_IN_PLAY
		move.b	#1,SCRIPT_NUMBER    | point HL to SCRIPT_NUMBER
		clr.b	SCRIPT_STAGE   | reset SCRIPT_STAGE to 0

*TODO
*0103: 3A 11 40      ld   a,(0x4011)           | read PORT_STATE_6800
*0106: 07            rlca                     | move dip sw1 & dip sw2 state...
*0107: 07            rlca                     | ...into bits 0 & 1 of register a
*0108: E6 03         and  0x03
*010A: 32 00 40      ld   (0x4000),a           | and store into DIP_SWITCH_1_2_STATE
*
*010D: 3A 12 40      ld   a,(0x4012)           | read PORT_STATE_7000 
*0110: E6 04         and  0x04                 | mask in state of dip switch 5
*0112: 0F            rrca                     | move bit into...
*0113: 0F            rrca                     | bit 0 of register a
*0114: 32 1F 40      ld   (0x401F),a           | and store it in DIP_SWITCH_5_STATE
*
			lea	PACKED_DEFAULT_SWARM_DEFINITION(pc),a1  | load DE with address of PACKED_DEFAULT_SWARM_DEFINITION
			bsr UNPACK_ALIEN_SWARM                      | call UNPACK_ALIEN_SWARM
*
** set IS_COCKTAIL flag from !SW0    upright/cocktail
*011D: 3A 10 40      ld   a,(0x4010)           | read PORT_STATE_6000
*0120: E6 20         and  0x20                 | read upright/cocktail bit                  
*0122: 07            rlca                     | move bit from bit 5.. 
*0123: 07            rlca
*0124: 07            rlca                     | ..to bit 0.
*0125: 32 0F 40      ld   (0x400F),a           | and store to IS_COCKTAIL

* read DIP switches to calculate value of BONUS GALIXIP
*0128: 3A 00 70      ld   a,(0x7000)           | read state of dip switch 3,4,5,6
*012B: E6 03         and  0x03                 | mask in state of dip switches 3 & 4
*012D: 21 52 01      ld   hl,0x0152   see below table
*0130: E7            rst  0x20                 | call routine to fetch value @ HL + A 
*0131: 32 AC 40      ld   BONUS_GALIXIP_FOR,a           | write BONUS GALIXIP @ value  

* Set screen attribute colours then display "1UP" and "HIGH SCORE" 
		jbsr	SET_COLOUR_ATTRIBUTES_TABLE_1 | call SET_COLOUR_ATTRIBUTES_TABLE_1
		move.b	#1,d0
		move.w	#0x5340,d6
		jbsr	osd_w_bg_videoram		| poke "1" to character RAM
		move.b	#0x25,d0
		move.w	#0x5320,d6		          
		jbsr	osd_w_bg_videoram		| poke "U" to character RAM
		move.b	#0x20,d0
		move.w	#0x5300,d6		          
		jbsr	osd_w_bg_videoram		| poke "P" to character RAM - text "1UP" now drawn
		move.w	#0x0604,d3		      | command: PRINT_TEXT_COMMAND, parameter: 4 (index of "HIGH SCORE")
		jbsr	QUEUE_COMMAND
		move.w	#0x0503,d3              | command: DISPLAY_SCORE_COMMAND , parameter: 3 (Displays player scores and high score)
		jra		QUEUE_COMMAND
  
* Values for BONUS GALIXIP. 7 = 7000, 10 = 10000, 12 =12000, 20 = 20000
table_0152: 
	.byte	0x07,0x10,0x12,0x20 

*
* Script ONE is responsible for managing the attract mode.
*
*
*

SCRIPT_ONE:
	bsr	HANDLE_SWARM_MOVEMENT	| even on "game over"!   
	bsr	SET_ALIEN_PRESENCE_FLAGS
	moveq	#0,d0
	lea		script_one_jump_table(pc),a0
	move.b	SCRIPT_STAGE(pc),d0		| read SCRIPT_STAGE   
	add.w	d0,d0
	add.w	d0,d0
	move.l	(a0,d0.w),a0
	jsr		(a0)

	tst.b	NUM_CREDITS   | 03D7
	bne.b	1f			| return if no credits
	rts
1:
	addq.b	#1,SCRIPT_NUMBER        | advance to next script
	clr.b	IS_GAME_OVER 			| set IS_GAME_OVER to 0
	clr.b	SCRIPT_STAGE               | set SCRIPT_STAGE to 0
	clr.b	ENABLE_ALIEN_ATTACK_SOUND  | set ENABLE_ALIEN_ATTACK_SOUND to 0
	clr.b	ALIEN_DEATH_SOUND          | set ALIEN_DEATH_SOUND to 0
	clr.b	IS_COLUMN_SCROLLING        | clear IS_COLUMN_SCROLLING flag
	rts

script_one_jump_table: 
	.long	DISPLAY_GAME_OVER_AND_REMAINING_CREDIT_1
	.long	SET_PUSH_START_BUTTON_COUNTER
	.long	HIDE_SWARM_AND_PREPARE_TO_CLEAR_SCREEN 
	.long	CLEAR_SCREEN_BEFORE_WE_ARE_THE_GALAXIANS_INTRO
	.long	DISPLAY_WE_ARE_THE_GALAXIANS_INTRO
	.long	SCROLL_ON_CONVOY_CHARGER_POINTS
	.long	DISPLAY_NAMCO_LOGO
	.long	BLINK_CONVOY_CHARGER_POINTS
	.long	HIDE_SWARM_AND_PREPARE_TO_CLEAR_SCREEN 
	.long	CLEAR_WE_ARE_GALAXIANS_SCREEN_AND_DISPLAY_GAME_OVER
	.long	DISPLAY_GAME_OVER_AND_REMAINING_CREDIT_2
	.long	WAIT_FOR_TEMP_COUNTER_2_THEN_ADVANCE_TO_NEXT_STAGE 
	.long	CLEAR_ALIEN_SWARM_AND_SUSPEND_SWARM_ANIMATION
	.long	CREATE_ATTRACT_MODE_ALIEN_SWARM
	.long	HANDLE_SPAWN_PLAYER
	.long	HANDLE_MAIN_GAME_LOGIC
	.long	HANDLE_PLAYER_ONE_KILLED
	.long	WAIT_FOR_TEMP_COUNTER_2_THEN_ADVANCE_TO_NEXT_STAGE
	.long	SET_SCRIPT_STAGE_TO_1

SCRIPT_TWO:
	TODOM	0x1002
	rts
SCRIPT_THREE:
	TODOM	0x1003
	rts
SCRIPT_FOUR:
	TODOM	0x1004
	rts
	

* This routine does two things:
*
* 1. Stops the swarm from moving if the player bullet gets too close to an alien in the swarm 
* 2. Sets the scroll registers for the columns containing the swarm
* 
* Before I investigated this code, I never noticed the swarm stops - now I can't not notice it.
* If you want the aliens to just not care about their own safety, type the following into the debugger: maincpu.mw@0x093C=0 
*

HANDLE_SWARM_MOVEMENT:
090D: 21 08 42      ld   hl,0x4208            | point HL to HAS_PLAYER_BULLET_BEEN_FIRED flag
0910: CB 46         bit  0,(hl)              | test bit 0. 
0912: 28 2A         jr   z,0x093E             | If player hasn't fired, goto 0x093E 
0914: 2C            inc  l                   | point HL to PLAYER_BULLET_X
0915: 7E            ld   a,(hl)              | read X coordinate of bullet
0916: D6 22         sub  0x22
0918: FE 50         cp   0x50                 | compare to 0x50 (80 decimal)
091A: 30 22         jr   nc,0x093E            | if greater than 0x50, goto 0x093E

091C: 2C            inc  l                   | point HL to PLAYER_BULLET_Y
091D: 3A 0E 42      ld   a,(0x420E)           | read SWARM_SCROLL_VALUE
0920: 96            sub  (hl)                | subtract from value in PLAYER_BULLET_Y
0921: ED 44         neg                      | A = 256-A   
0923: 47            ld   b,a
0924: C6 02         add  a,0x02
0926: E6 0F         and  0x0F
0928: FE 03         cp   0x03
092A: 30 12         jr   nc,0x093E            | if A >= #0x03 goto 0x093E

092C: 78            ld   a,b
092D: 0F            rrca
092E: 0F            rrca
092F: 0F            rrca
0930: 0F            rrca
0931: E6 0F         and  0x0F                 | now A identifies the column of the swarm the player bullet is in
0933: 5F            ld   e,a
0934: 16 00         ld   d,0x00
0936: 21 F0 41      ld   hl,0x41F0            | load HL with address of ALIEN_IN_COLUMN_FLAGS
0939: 19            add  hl,de              
093A: CB 46         bit  0,(hl)              | are there any aliens in this column?
093C: 20 4A         jr   nz,0x0988            | yes, make the swarm stand still!

* move the swarm, and make it change direction once its hit a screen edge 
093E: 2A 0E 42      ld   hl,(0x420E)          | read SWARM_SCROLL_VALUE
0941: ED 5B 10 42   ld   de,(0x4210)          | read SWARM_SCROLL_MAX_EXTENTS
0945: 3A 0D 42      ld   a,(0x420D)           | read SWARM_DIRECTION
0948: A7            and  a                   | test if its zero
0949: 20 12         jr   nz,0x095D            | if not zero, swarm is moving right, goto 0x095D

* swarm is moving left
094B: CB 7C         bit  7,h                 
094D: 20 04         jr   nz,0x0953
094F: 7D            ld   a,l
0950: BB            cp   e
0951: 30 2A         jr   nc,0x097D            | jp to MAKE_SWARM_MOVE_RIGHT
0953: 3A 5F 42      ld   a,(0x425F)           | read TIMING_VARIABLE
0956: E6 03         and  0x03                 | mask in bits 0 & 1
0958: C0            ret  nz                  | if either bit is set, return
0959: 23            inc  hl                  | increment scroll value. Swarm will move left (but in reality, a pixel down).
095A: C3 6C 09      jp   0x096C

* swarm is moving right
095D: CB 7C         bit  7,h                 | test bit 7
095F: 28 04         jr   z,0x0965
0961: 7D            ld   a,l
0962: BA            cp   d
0963: 38 1E         jr   c,0x0983             | jp to MAKE_SWARM_MOVE_LEFT
0965: 3A 5F 42      ld   a,(0x425F)           | read TIMING_VARIABLE
0968: E6 03         and  0x03                 | mask in bits 0 & 1
096A: C0            ret  nz                  | if either bit is set, return. 
096B: 2B            dec  hl                  | decrement scroll value. Swarm will move right (in reality, a pixel up).


* if you want the swarm to be static, or tinker with the scroll, fill 0x096C to 0x096E with NOP instructions. 
096C: 22 0E 42      ld   (0x420E),hl          | set SWARM_SCROLL_VALUE 
096F: 7D            ld   a,l                 
0970: ED 44         neg                      | A = 256-A



*
* Enables starfield, displays GAME OVER and the amount of credit remaining.
*
*
DISPLAY_GAME_OVER_AND_REMAINING_CREDIT_1:      
	move.w	#0x0701,d3            | command: BOTTOM_OF_SCREEN_INFO_COMMAND, parameter: 1 (invokes DISPLAY_AVAILABLE_CREDIT)
	jbsr	QUEUE_COMMAND		| call QUEUE_COMMAND
	move.w	#0x0600,d3          | command: PRINT_TEXT_COMMAND, parameter: 0 (index of GAME OVER)
	jbsr	QUEUE_COMMAND               | call QUEUE_COMMAND
	moveq  #1,d0
	move.b	d0,IS_GAME_OVER           | set IS_GAME_OVER flag
	bsr		osd_stars_on         | enable stars
	addq.b	#1,SCRIPT_STAGE   | advance to next stage
	clr.b	PUSH_START_BUTTON_COUNTER
	clr.b	CURRENT_PLAYER           | set CURRENT_PLAYER to 0 (player one)
	clr.b	IS_TWO_PLAYER_GAME
	clr.b	IS_GAME_IN_PLAY
	move.b	#0x60,TEMP_COUNTER_1
	.ifdef	FAST_INTRO_TEXT
    move.b	#1,TEMP_COUNTER_2
	.else
	move.b	#0x10,TEMP_COUNTER_2     | set TEMP_COUNTER_1 and TEMP_COUNTER_2 
	.endif
	rts

	
HIDE_SWARM_AND_PREPARE_TO_CLEAR_SCREEN:
    lea		ALIEN_SWARM_FLAGS(pc),a0            | load HL with address of 
    move.w	#0x80-1,d1               | sizeof(ALIEN_SWARM_FLAGS) array
0:
	clr.b	(a0)+             | Clear all alien swarm flags 
	dbf		d1,0b
	
    clr.b	TIMING_VARIABLE          
    clr.b   HAVE_AGGRESSIVE_ALIENS 		| reset HAVE_AGGRESSIVE_ALIENS flag
	move.w	#0x5002,TEMP_CHAR_RAM_PTR       | address of column 2 in character RAM
	.ifdef	FAST_INTRO_TEXT
    move.b	#1,TEMP_COUNTER_2
	.else
    move.b	#0x20,TEMP_COUNTER_2
	.endif
    addq.b	#1,SCRIPT_STAGE                | advance to next part of script.
	rts
	
*
* This piece of code clears all of the screen except the HUD (score, credits inserted etc)
*

CLEAR_SCREEN_BEFORE_WE_ARE_THE_GALAXIANS_INTRO:
	move.w	TEMP_CHAR_RAM_PTR(pc),d6  | load HL with contents of TEMP_CHAR_RAM_PTR
     move.w	#0x1C-1,d1               | We want to clear #0x1C (28 characters) on this row 
     move.b	#0x10,d0               | ordinal for empty character
0:
	 jbsr	osd_w_bg_videoram
	 dbf		D1,0b         | Clear 28 characters from row
                              | As a row is 32 characters wide, to get to start of next row...
     add.w	#4,d6              | ... we need to add 4 characters.
     move.w	d6,TEMP_CHAR_RAM_PTR         | write to TEMP_CHAR_RAM_PTR
	 subq.b	#1,TEMP_COUNTER_2     | decrement value of counter
     beq.b	1f                  | if value is not zero then exit 
	rts
1:
	addq.b	#1,SCRIPT_STAGE		| advance to next part of script.
	move.b	#0x40,TEMP_COUNTER_1
	move.b	#0x04,TEMP_COUNTER_2	| set TEMP_COUNTER_1 and TEMP_COUNTER_2

	lea		HAS_PLAYER_SPAWNED(pc),a0
	move.w	#FLAGSHIP_ATTACK_SECONDARY_COUNTER-HAS_PLAYER_SPAWNED,d1
0:
	clr.b	(a0)+
	dbf		d1,0b    | Clear from 0x4200-422F
	  
      | reset regen hflip (not done)
      | reset regen vflip (not done)
      | reset DISPLAY_IS_COCKTAIL_P2  (not done)
      move.b	#1,DISABLE_SWARM_ANIMATION           | set  flag
      lea	COLOUR_ATTRIBUTE_TABLE_3(pc),a0
      bra	SET_COLOUR_ATTRIBUTES               | jump to SET_COLOUR_ATTRIBUTES

*
* The alien swarm scrolling in the attract mode has changed scroll values for some columns, 
* and these scroll values need to be reset before we can print text like "WE ARE THE GALAXIANS" "MISSION: DESTROY ALIENS"
* in those columns. If we don't reset the scroll values, the text will probably be off-centre and not look good.
*

HANDLE_ALIEN_SWARM_SCROLL_RESET:
    moveq	#0,d0                   | reset scroll offset to 0
    jra     SET_SWARM_SCROLL_OFFSET

*
* This is used to scroll the alien swarm from side to side.
*
* Expects:
* register A: Scroll offset value
*

SET_SWARM_SCROLL_OFFSET:
    lea	OBJRAM_BACK_BUF+8,a0     | pointer to attribute and column scroll data held in OBJRAM_BACK_BUF
    move.w	#8,d1                | we're doing 9 columns.
0:
	move.b	d0,(a0)
    addq.w	#2,a0        | bump HL to next scroll offset address in OBJRAM_BACK_BUF
    dbf		d1,0b
    rts


MAKE_SWARM_MOVE_RIGHT:
	move.b	#1,SWARM_DIRECTION   | Swarm now moves right.
	rts

MAKE_SWARM_MOVE_LEFT:
	clr.b	SWARM_DIRECTION   | Swarm now moves left
	rts

*0988: 2A 0E 42      ld   hl,(0x420E)          | read SWARM_SCROLL_VALUE
*098B: C3 6F 09      jp   0x096F


*
* This routine sets the following flags:  
*
* ALIEN_IN_COLUMN_FLAGS
* HAVE_ALIENS_IN_6TH_ROW
* HAVE_ALIENS_IN_5TH_ROW
* HAVE_ALIENS_IN_4TH_ROW
* HAVE_ALIENS_IN_3RD_ROW
* HAVE_ALIENS_IN_2ND_ROW
* HAVE_ALIENS_IN_TOP_ROW
* HAVE_NO_BLUE_OR_PURPLE_ALIENS
* HAVE_NO_ALIENS_IN_SWARM 
* HAVE_NO_INFLIGHT_ALIENS
* HAVE_NO_INFLIGHT_OR_DYING_ALIENS
* 
* It also sets the values for SWARM_SCROLL_MAX_EXTENTS. 

SET_ALIEN_PRESENCE_FLAGS:     // TENTATIVE NAME - If anyone can think of anything better, give me a shout
098E: AF            xor  a
098F: 11 E8 41      ld   de,0x41E8     
0992: 12            ld   (de),a              | clear 0x41E8
0993: 1C            inc  e                    
0994: 12            ld   (de),a              | clear 0x41E9
0995: 1C            inc  e                   | DE now = 0x41EA (address of HAVE_ALIENS_IN_IN_ROW_FLAGS)

* This part of the code determines if there are any aliens on a given row.
* It will set the corresponding flag in the HAVE_ALIENS_IN_ROW_FLAGS array.
* it works from the bottom row of aliens to the top.
0996: 0E 06         ld   c,0x06               | there are 6 rows of aliens. Used as a row counter.
0998: 21 23 41      ld   hl,0x4123            | pointer to bottom right alien in ALIEN_SWARM_FLAGS

099B: 06 0A         ld   b,0x0A               | There's 0x0A (10 decimal) aliens max per row
099D: AF            xor  a                   | clear A. 
099E: B6            or   (hl)                | If an alien is present, A will now be set to 1.
099F: 2C            inc  l                   | move to next flag
09A0: 10 FC         djnz 0x099E               | repeat tests until B == 0.

09A2: 12            ld   (de),a              | store alien presence flag in HAVE_ALIENS_IN_[]_ROW flag
09A3: 1C            inc  e                   | bump DE to point to next HAVE_ALIENS_IN_[]_ROW flag
09A4: 7D            ld   a,l          
09A5: C6 06         add  a,0x06
09A7: 6F            ld   l,a                 | Add 6 to HL. Now HL points to flags for row of aliens above previous    
09A8: 0D            dec  c                   | decrement row counter
09A9: C2 9B 09      jp   nz,0x099B            | if not all rows of aliens have been processed, goto 0x099B

* when we get here, DE points to 0x41F0, which is the start of the ALIEN_IN_COLUMN_FLAGS array.
09AC: AF            xor  a
09AD: 12            ld   (de),a              | clear first entry of ALIEN_IN_COLUMN_FLAGS. 
09AE: 1C            inc  e
09AF: 12            ld   (de),a              | clear second entry of ALIEN_IN_COLUMN_FLAGS.
09B0: 1C            inc  e
09B1: 12            ld   (de),a              | clear second entry of ALIEN_IN_COLUMN_FLAGS.
09B2: 1C            inc  e

09B3: 21 23 41      ld   hl,0x4123            | pointer to bottom right alien in ALIEN_SWARM_FLAGS 
09B6: 0E 0A         ld   c,0x0A               | There's 0x0A (10 decimal) columns of aliens 

* Working from the rightmost column of aliens to the left, check each column for presence of aliens and
* set/clear respective flag in ALIEN_IN_COLUMN_FLAGS array accordingly. 
09B8: D5            push de
09B9: 11 10 00      ld   de,0x0010            | offset to add to HL to point to alien in row above, same column.
09BC: 06 06         ld   b,0x06               | 6 rows of aliens. Used as a row counter.
09BE: AF            xor  a
09BF: B6            or   (hl)                | If an alien is present, A will now be set to 1.
09C0: 19            add  hl,de               | Point HL to alien in row above, same column.
09C1: 10 FC         djnz 0x09BF               | Repeat until all 6 rows of aliens have been scanned
09C3: D1            pop  de
09C4: 12            ld   (de),a              | set/clear flag in ALIEN_IN_COLUMN_FLAGS
09C5: 1C            inc  e                   | bump DE to point to next entry in ALIEN_IN_COLUMN_FLAGS

* we've scanned all the aliens in a column. 
* We now want to scan the next column of aliens to the immediate *left* of the column we just scanned. 
09C6: 7D            ld   a,l
09C7: D6 5F         sub  0x5F
09C9: 6F            ld   l,a                 | now HL points to bottom alien in next column of aliens to check  
09CA: 0D            dec  c                   | decrement counter for number of columns left to process            
09CB: C2 B8 09      jp   nz,0x09B8            | if we've not done all the columns, goto 0x09B8

* the following code works out how far to the left the swarm can move. Or should I say, how far the swarm can be scrolled down.
* TODO: I'll come back to this code later, but at the moment there's bigger fish to fry with this game, so I'll just leave bare bones here.
09CE: 21 FC 41      ld   hl,0x41FC            | load HL with a pointer to flag for the leftmost column of aliens in ALIEN_IN_COLUMN_FLAGS
09D1: 06 0A         ld   b,0x0A               | There's 0x0A (10 decimal) columns of aliens 
09D3: 1E 22         ld   e,0x22
09D5: CB 46         bit  0,(hl)              | Test the flag. Is there an alien in the column?
09D7: 20 09         jr   nz,0x09E2            | yes, goto 0x09E2
09D9: 2D            dec  l                   | bump HL to point to flag for column to left
09DA: 7B            ld   a,e
09DB: C6 10         add  a,0x10
09DD: 5F            ld   e,a
09DE: 10 F5         djnz 0x09D5

* now work out how far to the right the swarm can move. 
09E0: 1E 22         ld   e,0x22
09E2: 21 F3 41      ld   hl,0x41F3            | load HL with a pointer to flag for the rightmost column of aliens in ALIEN_IN_COLUMN_FLAGS
09E5: 06 0A         ld   b,0x0A               | There's 0x0A (10 decimal) columns of aliens
09E7: 16 E0         ld   d,0xE0
09E9: CB 46         bit  0,(hl)              | Test the flag. Is there an alien in the column?
09EB: 20 09         jr   nz,0x09F6            | yes, goto 0x09F6
09ED: 2C            inc  l
09EE: 7A            ld   a,d
09EF: D6 10         sub  0x10
09F1: 57            ld   d,a
09F2: 10 F5         djnz 0x09E9
09F4: 16 E0         ld   d,0xE0
09F6: ED 53 10 42   ld   (0x4210),de          | set SWARM_SCROLL_MAX_EXTENTS

* Check if any of the bottom 4 rows of aliens (blue & purple) have any aliens in them. *Aliens from those rows that are in flight don't count*
09FA: 21 EA 41      ld   hl,0x41EA            | load HL with pointer to HAVE_ALIENS_IN_6TH_ROW
09FD: 0E 01         ld   c,0x01
09FF: 06 04         ld   b,0x04               | we want to do 4 rows of aliens
0A01: AF            xor  a
0A02: B6            or   (hl)                | test if there's an alien present on the row
0A03: 2C            inc  l                   | bump HL to point to flag for row above 
0A04: 10 FC         djnz 0x0A02               | repeat until b==0
0A06: A9            xor  c                   | 
0A07: 32 21 42      ld   (0x4221),a           | set HAVE_NO_BLUE_OR_PURPLE_ALIENS flag

* HL = pointer to HAVE_ALIENS_IN_2ND_ROW
0A0A: A9            xor  c                   | if A was 1, set it to 0, and vice versa
0A0B: B6            or   (hl)                | if any aliens in red row set A to 1  *Red aliens in flight don't count*
0A0C: 2C            inc  l                   | bump HL to point to HAVE_ALIENS_IN_TOP_ROW
0A0D: B6            or   (hl)                | if any aliens in flagship row set A to 1   *Flagships that are in flight don't count*
0A0E: A9            xor  c                   | if A was 1, set it to 0, and vice versa
0A0F: 32 20 42      ld   (0x4220),a           | set/reset HAVE_NO_ALIENS_IN_SWARM flag.

* Check if we have any aliens "in-flight" attacking the player.
* We skip the first entry in the INFLIGHT_ALIENS array because the first entry is reserved for misc use (see docs above INFLIGHT_ALIEN struct)
* and should not be treated as a "real" flying alien.
0A12: 21 D0 42      ld   hl,0x42D0            | pointer to INFLIGHT_ALIENS_START+sizeof(INFLIGHT_ALIEN). Effectively skipping first INFLIGHT_ALIEN. 
0A15: 11 20 00      ld   de,0x0020            | sizeof(INFLIGHT_ALIEN)
0A18: 06 07         ld   b,0x07               | 7 aliens to process in the list
0A1A: AF            xor  a                   | clear A
0A1B: B6            or   (hl)                | Set A to 1 if alien is active
0A1C: 19            add  hl,de               | bump HL to point to next INFLIGHT_ALIEN structure in the array
0A1D: 10 FC         djnz 0x0A1B               | repeat until B==0
0A1F: A9            xor  c                   | if no aliens are in flight, A will be set to 1.  Else A is set 0. 
0A20: 32 26 42      ld   (0x4226),a           | set/reset HAVE_NO_INFLIGHT_ALIENS flag 

* Check if we have any aliens "in-flight" or dying 
0A23: A9            xor  c                   | 
0A24: 21 B1 42      ld   hl,0x42B1            | pointer to first IsDying flag of INFLIGHT_ALIENS array.
0A27: 06 08         ld   b,0x08               | test all 8 slots
0A29: B6            or   (hl)                | if INFLIGHT_ALIEN.IsDying is set to 1, set A to 1.
0A2A: 19            add  hl,de               | bump HL to point to next INFLIGHT_ALIEN structure in the array
0A2B: 10 FC         djnz 0x0A29               | repeat until B==0
0A2D: A9            xor  c                   | 
0A2E: 32 25 42      ld   (0x4225),a           | set/reset HAVE_NO_INFLIGHT_OR_DYING_ALIENS
0A31: C9            rts




HANDLE_PLAYER_SHOOT:
0A32: 3A 00 42      ld   a,(0x4200)           | read HAS_PLAYER_SPAWNED flag
0A35: 0F            rrca                     | move bit 0 into carry
0A36: D0            rts  nc                  | if player has not spawned, return
0A37: 3A 08 42      ld   a,(0x4208)           | read HAS_PLAYER_BULLET_BEEN_FIRED flag
0A3A: 0F            rrca                     | move bit 0 into carry
0A3B: D8            rts  c                   | if carry is set, missile has already been fired, can't shoot again.
0A3C: 3A 06 40      ld   a,(0x4006)           | read IS_GAME_IN_PLAY flag
0A3F: 0F            rrca                     | move bit 0 into carry
0A40: 30 26         jr   nc,0x0A68            | if no carry, game is not in play, so this is demo mode, goto 0x0A68
0A42: 3A 18 40      ld   a,(0x4018)           | read DISPLAY_IS_COCKTAIL_P2 flag
0A45: 0F            rrca                     | move bit 0 into carry
0A46: 38 15         jr   c,0x0A5D             | if we're player 2 and we're playing on a cocktail machine, goto 0x0A5D 
0A48: 3A 13 40      ld   a,(0x4013)           | read PREV_PORT_STATE_6000 
0A4B: 2F            cpl
0A4C: 47            ld   b,a
0A4D: 3A 10 40      ld   a,(0x4010)           | read PORT_STATE_6000
0A50: A0            and  b
0A51: E6 10         and  0x10                 | test state of SHOOT button
0A53: C8            rts  z                   | return if not held down
0A54: 3E 01         ld   a,0x01
0A56: 32 08 42      ld   (0x4208),a           | set HAS_PLAYER_BULLET_BEEN_FIRED flag
0A59: 32 CC 41      ld   (0x41CC),a           | set PLAY_PLAYER_SHOOT_SOUND flag 
0A5C: C9            rts

* We come here if it's player 2's turn and the game is in cocktail mode.
0A5D: 3A 14 40      ld   a,(0x4014)           | read PREV_PORT_STATE_6800
0A60: 2F            cpl
0A61: 47            ld   b,a
0A62: 3A 11 40      ld   a,(0x4011)           | read PORT_STATE_6800
0A65: C3 50 0A      jp   0x0A50               | go check if shoot button for player 2's controls is held down.


* We're in demo mode. We need to simulate the player firing at the aliens.
0A68: 3A 5F 42      ld   a,(0x425F)           | read TIMING_VARIABLE
0A6B: E6 1F         and  0x1F                 | mask in bits 0..5
0A6D: C0            rts  nz                  | if result is not zero, then return
0A6E: 3E 01         ld   a,0x01
0A70: 32 08 42      ld   (0x4208),a           | set HAS_PLAYER_BULLET_BEEN_FIRED flag
0A73: C9            rts



*
* Move enemy bullets and position enemy bullet sprites
*
*
*

HANDLE_ENEMY_BULLETS:
0A74: DD 21 60 42   ld   ix,0x4260            | load IX with address of ENEMY_BULLETS_START
0A78: 3A 5F 42      ld   a,(0x425F)           | read TIMING_VARIABLE
0A7B: 0F            rrca                     | move bit 0 into carry
0A7C: 38 0B         jr   c,0x0A89             | if TIMING_VARIABLE is an odd number, goto 0x0A89
0A7E: DD 34 01      inc  (ix+0x01)            | Increment ENEMY_BULLET.X by 2.. 
0A81: DD 34 01      inc  (ix+0x01)            | 

0A84: 11 05 00      ld   de,0x0005            | sizeof(ENEMY_BULLET)
0A87: DD 19         add  ix,de
0A89: FD 21 81 40   ld   iy,0x4081            | pointer to OBJRAM_BACK_BUF_BULLETS
0A8D: 06 07         ld   b,0x07               | number of bullets

* main bullet loop
0A8F: DD CB 00 46   bit  0,(ix+0x00)          | test ENEMY_BULLET.IsActive flag
0A93: 28 27         jr   z,0x0ABC             | if enemy bullet is not active, goto 0x0ABC
0A95: DD 7E 01      ld   a,(ix+0x01)          | read ENEMY_BULLET.X 
0A98: C6 02         add  a,0x02               | bullet will move 2 pixels
0A9A: DD 77 01      ld   (ix+0x01),a          | update ENEMY_BULLET.X
0A9D: C6 04         add  a,0x04               | tentatively add 4 to the X coordinate. If a carry occurs, enemy bullet is at bottom of screen 
0A9F: 38 1B         jr   c,0x0ABC             | enemy bullet is at bottom of screen so needs to be deactivated, goto 0x0ABC

* split ENEMY_BULLET.YDelta into its sign and delta, then add to YH and YL respectively. 
0AA1: DD 6E 02      ld   l,(ix+0x02)          | read ENEMY_BULLET.YL
0AA4: DD 66 03      ld   h,(ix+0x03)          | read ENEMY_BULLET.YH
0AA7: DD 5E 04      ld   e,(ix+0x04)          | read ENEMY_BULLET.YDelta 
0AAA: CB 13         rl   e                   | move bit 7 of E (sign bit) into carry. Shift YDelta bits left into bits 1..7.                  
0AAC: 9F            sbc  a,a                 | A = 0 - carry
0AAD: 57            ld   d,a                 | if bit 7 of E was set, D will be 0xFF, else 0.
0AAE: 19            add  hl,de               
0AAF: DD 75 02      ld   (ix+0x02),l          | set ENEMY_BULLET.YL
0AB2: DD 74 03      ld   (ix+0x03),h          | set ENEMY_BULLET.YH
0AB5: 7C            ld   a,h                 | get ENEMY_BULLET.YH coordinate into A
0AB6: C6 10         add  a,0x10               | add #0x10 (16 decimal) . 
0AB8: FE 20         cp   0x20                 | compare to 0x20 (32 decimal)
0ABA: 30 0A         jr   nc,0x0AC6            | if >= 32 decimal, bullet is still onscrene, goto 0x0AC6

* bullet is offscreen, deactivate it
0ABC: AF            xor  a
0ABD: DD 77 00      ld   (ix+0x00),a          | set ENEMY_BULLET.IsActive flag (disables bullet)
0AC0: DD 77 01      ld   (ix+0x01),a          | set ENEMY_BULLET.X to 0 
0AC3: DD 77 03      ld   (ix+0x03),a          | set ENEMY_BULLET.YH to 0

* we now need to position the actual enemy bullet sprites.
0AC6: 3A 18 40      ld   a,(0x4018)           | read DISPLAY_IS_COCKTAIL_P2
0AC9: 0F            rrca                     | move flag into carry
0ACA: 38 29         jr   c,0x0AF5             | if carry is set, it's a cocktail setup and player 2's turn, goto 0x0AF5

0ACC: DD 7E 01      ld   a,(ix+0x01)          | read ENEMY_BULLET.X 
0ACF: 2F            cpl                      | A = (255 - A) 
0AD0: 3D            dec  a                   | A = A-1
0AD1: FD 77 02      ld   (iy+0x02),a          | write to OBJRAM_BACK_BUF_BULLETS sprite state

* looks to me like there's a hardware "feature" where the Y coordinate of alien bullets 5-7 needs adjusted by 1 so the sprite is positioned correctly.
* if anyone can tell me why, drop me a line. Thanks!
0AD4: DD 7E 03      ld   a,(ix+0x03)          | read ENEMY_BULLET.YH 
0AD7: 2F            cpl                      | A = (255 - A) 
0AD8: 4F            ld   c,a
0AD9: 78            ld   a,b                 | get index of enemy bullet we are processing into A
0ADA: FE 05         cp   0x05                 | are we processing bullet #5 or more?
0ADC: 38 01         jr   c,0x0ADF             | no, goto 0x0ADF
0ADE: 0C            inc  c                   | adjust Y coordinate
0ADF: FD 71 00      ld   (iy+0x00),c          | write to OBJRAM_BACK_BUF_BULLETS sprite Y coordinate

0AE2: 11 05 00      ld   de,0x0005            | sizeof(ENEMY_BULLET)
0AE5: DD 19         add  ix,de               | bump IX to point to next ENEMY_BULLET in ENEMY_BULLETS array
0AE7: DD 34 01      inc  (ix+0x01)            | increment ENEMY_BULLET.X
0AEA: DD 34 01      inc  (ix+0x01)            | twice, to make it move 2 pixels

0AED: DD 19         add  ix,de               | bump IX to point to next ENEMY_BULLET in ENEMY_BULLETS array
0AEF: 1D            dec  e                   | DE is now 4  
0AF0: FD 19         add  iy,de               | bump IY to point to state of next sprite in OBJRAM_BACK_BUF_BULLETS
0AF2: 10 9B         djnz 0x0A8F               | repeat until B ==0
0AF4: C9            rts

* called if we have a cocktail display and it's player 2's turn. 
0AF5: DD 7E 01      ld   a,(ix+0x01)
0AF8: D6 04         sub  0x04
0AFA: FD 77 02      ld   (iy+0x02),a
0AFD: DD 7E 03      ld   a,(ix+0x03)
0B00: 2F            cpl
0B01: 4F            ld   c,a
0B02: 78            ld   a,b
0B03: FE 05         cp   0x05
0B05: 38 D8         jr   c,0x0ADF
0B07: 0D            dec  c
0B08: C3 DF 0A      jp   0x0ADF



*
* Check if the player's bullet has hit any aliens in the swarm.
* If so, delete the shot alien from the swarm, kick off a dying animation, and update player score with relevant points value. 
*

HANDLE_SWARM_ALIEN_TO_PLAYER_BULLET_COLLISION_DETECTION:
0B0B: 21 08 42      ld   hl,0x4208            | pointer to HAS_PLAYER_BULLET_BEEN_FIRED  
0B0E: CB 46         bit  0,(hl)              | test bit 0. If it's set, player is shooting.
0B10: C8            rts  z                   | if zero flag is set, that means player is not shooting. Return.
0B11: 23            inc  hl                  | bump HL to point to PLAYER_BULLET_X
0B12: 7E            ld   a,(hl)              | read value of PLAYER_BULLET_X
0B13: FE 68         cp   0x68                 | 
0B15: D0            rts  nc                  | if X coordinate >= #0x68 (104 decimal) then bullet is not near swarm yet, so exit
0B16: D6 1E         sub  0x1E                 | if X coordinate < #0x1E (30 decimal) then bullet has passed the swarm, this subtraction will cause a carry.. 
0B18: D8            rts  c                   | .. so exit.

* OK, we have to check if an alien has been hit
0B19: 06 06         ld   b,0x06               | number of rows of aliens
0B1B: D6 07         sub  0x07
0B1D: D8            rts  c
0B1E: D6 05         sub  0x05
0B20: 38 03         jr   c,0x0B25             
0B22: 10 F7         djnz 0x0B1B
0B24: C9            rts

* B =  row index from 1 to 6. Identifies which row of aliens to check for player bullet collisions. 
* 1 = blue row of aliens closest to player| 6 = flagship row
0B25: 23            inc  hl                  | bump HL to point to PLAYER_BULLET_Y
0B26: 3A 0E 42      ld   a,(0x420E)           | read SWARM_SCROLL_VALUE
0B29: 96            sub  (hl)
0B2A: ED 44         neg.b   d0
0B2C: 4F            ld   c,a
0B2D: E6 0F         and  0x0F                 | mask in low nibble
0B2F: D6 02         sub  0x02
0B31: FE 0B         cp   0x0B
0B33: D0            rts  nc
0B34: 04            inc  b
0B35: 79            ld   a,c
0B36: E6 F0         and  0xF0                 | mask in high nibble
0B38: 80            add  a,b
0B39: 0F            rrca
0B3A: 0F            rrca
0B3B: 0F            rrca
0B3C: 0F            rrca
0B3D: 5F            ld   e,a                
0B3E: 16 00         ld   d,0x00               | DE is now an offset into the ALIEN_SWARM_FLAGS table
0B40: 21 00 41      ld   hl,0x4100            | load HL with address of ALIEN_SWARM_FLAGS
0B43: 19            add  hl,de               | add offset to HL. Now HL points to a flag which determines if an alien is present
0B44: CB 46         bit  0,(hl)              | test flag. If bit 0 is set, our bullet has hit an alien. 
0B46: C8            rts  z                   | bit 0 is not set, we haven't shot an alien, so exit
0B47: 72            ld   (hl),d              | We've hit an alien! Clear flag to indicate alien is dead.
0B48: 16 01         ld   d,0x01               | command id for DELETE_ALIEN_COMMAND
0B4A: 5D            ld   e,l                 | parameter: index of alien to delete from swarm
0B4B: CD F2 08      call 0x08F2               | call QUEUE_COMMAND 
0B4E: 7A            ld   a,d
0B4F: 32 0B 42      ld   (0x420B),a           | set IS_PLAYER_BULLET_DONE flag to 1, so player can shoot again

* we'll use the misc entry in the INFLIGHT_ALIENS array to display our explosion as a sprite
0B52: 32 B1 42      ld   (0x42B1),a           | set INFLIGHT_ALIEN.IsDying to 1
0B55: AF            xor  a
0B56: 32 B2 42      ld   (0x42B2),a           | set INFLIGHT_ALIEN.StageOfLife to 0
0B59: 2A 09 42      ld   hl,(0x4209)          | read PLAYER_BULLET_X and PLAYER_BULLET_Y  in one go
0B5C: 22 B3 42      ld   (0x42B3),hl          | set INFLIGHT_ALIEN.X and INFLIGHT_ALIEN.Y  to bullet coordinates
0B5F: 16 03         ld   d,0x03               | command id for UPDATE_PLAYER_SCORE_COMMAND (see 0x08f2)
0B61: 7B            ld   a,e                 | read index of alien that was just killed
0B62: FE 50         cp   0x50                 | was the alien killed in the bottom 3 ranks? (Blue aliens, most common type)
0B64: 38 0C         jr   c,0x0B72             | if index is < 0x50 (128 decimal) then yes, its a blue alien, goto 0x0B72

* only get here if you've shot a higher-ranking alien
0B66: E6 70         and  0x70                 | Mask out the column number of the killed alien from the index. 
* Now A is 0x50 (purple alien row),0x60 (red row),0x70 (flagship row)
0B68: 0F            rrca
0B69: 0F            rrca
0B6A: 0F            rrca
0B6B: 0F            rrca                     | Divide A by 16 decimal. 
0B6C: D6 04         sub  0x04                 | Subtract 4 to compute parameter for UPDATE_PLAYER_SCORE_COMMAND  
0B6E: 5F            ld   e,a                 | set parameter for UPDATE_PLAYER_SCORE_COMMAND 
0B6F: C3 F2 08      jp   0x08F2               | jump to QUEUE COMMAND. Player score will be updated.

* You've just shot a lowly blue alien. 
0B72: 1E 00         ld   e,0x00               | parameter for UPDATE_PLAYER_SCORE_COMMAND - adds 30 points to player score
0B74: C3 F2 08      jp   0x08F2               | jump to QUEUE COMMAND. Player score will be updated.


*
* Iterate through list of active enemy bullets and test if they have hit the player.
* 

HANDLE_PLAYER_TO_ENEMY_BULLET_COLLISION_DETECTION:
0B77: 3A 00 42      ld   a,(0x4200)           | read HAS_PLAYER_SPAWNED flag
0B7A: 0F            rrca                     | move bit 0 into carry
0B7B: D0            rts  nc                  | if carry is not set, then player has not spawned. Return.
0B7C: DD 21 60 42   ld   ix,0x4260            | point IX to ENEMY_BULLETS_START
0B80: 11 05 00      ld   de,0x0005            | sizeof(ENEMY_BULLET) struct
0B83: 06 0E         ld   b,0x0E               | length of ENEMY_BULLETS array 
0B85: CD 8D 0B      call 0x0B8D               | call TEST_IF_ENEMY_BULLET_HIT_PLAYER
0B88: DD 19         add  ix,de
0B8A: 10 F9         djnz 0x0B85
0B8C: C9            rts


*
* Check if an enemy bullet hit the player's ship.
*
* Expects: 
* E = 5
* IX  = pointer to ENEMY_BULLET structure
*

TEST_IF_ENEMY_BULLET_HIT_PLAYER:
0B8D: DD CB 00 46   bit  0,(ix+0x00)          | read ENEMY_BULLET.IsActive
0B91: C8            rts  z                   | return if bullet is not active

0B92: DD 7E 01      ld   a,(ix+0x01)          | read ENEMY_BULLET.X coordinate 
0B95: C6 1F         add  a,0x1F               | player ship is 32 pixels high.. 
0B97: 93            sub  e                   | subtract 5
0B98: 38 10         jr   c,0x0BAA
0B9A: D6 09         sub  0x09
0B9C: D0            rts  nc
0B9D: 3A 02 42      ld   a,(0x4202)           | read PLAYER_Y 
0BA0: DD 96 03      sub  (ix+0x03)            | subtract ENEMY_BULLET.Y coordinate
0BA3: 83            add  a,e                 | add 5
0BA4: FE 0B         cp   0x0B
0BA6: D0            rts  nc
0BA7: C3 B4 0B      jp   0x0BB4               | bullet has hit player
0BAA: 3A 02 42      ld   a,(0x4202)           | read PLAYER_Y
0BAD: DD 96 03      sub  (ix+0x03)            | subtract ENEMY_BULLET.Y coordinate
0BB0: C6 02         add  a,0x02
0BB2: BB            cp   e
0BB3: D0            rts  nc

* Player's been hit.. deactivate enemy bullet and set hit flag.
0BB4: DD 36 00 00   ld   (ix+0x00),0x00        | clear ENEMY_BULLET.IsActive flag. 
0BB8: 3E 01         ld   a,0x01
0BBA: 32 04 42      ld   (0x4204),a           | set IS_PLAYER_HIT flag. Player will explode.          
0BBD: C9            rts



*
* Displays the following:
*
* WE ARE THE GALAXIANS
* MISSION: DESTROY ALIENS
* - SCORE ADVANCE TABLE -
* CONVOY CHARGER

DISPLAY_WE_ARE_THE_GALAXIANS_INTRO:
     bsr	HANDLE_ALIEN_SWARM_SCROLL_RESET
     subq.b	#1,TEMP_COUNTER_1
     beq.b	0f
	 rts 
0:
     move.b	#0x50,TEMP_COUNTER_1            | reset counter
     move.w	#0x0600,d3               | Command: PRINT_TEXT

* HL now points to a number between 1 and 4. This identifies a text string we want to print: 
* 1: CONVOY CHARGER             
* 2: SCORE ADVANCE TABLE
* 3: MISSION: DESTROY ALIENS    
* 4: WE ARE THE GALAXIANS
	move.b	TEMP_COUNTER_2(pc),d3
	add.b	#6,d3      | add 6 to it to give us an index for PRINT_TEXT
    jbsr	QUEUE_COMMAND
    subq.b	#1,TEMP_COUNTER_2              | bump TEMP_COUNTER_2 to index of next string to print
    beq.b	1f
	rts
1:
	addq.b	#1,SCRIPT_STAGE     | advance to next stage
	move.b	#0x20,TEMP_COUNTER_1
	move.b	#0x04,TEMP_COUNTER_2  | set TEMP_COUNTER_1 and TEMP_COUNTER_2

* hide all sprites 
	lea		INFLIGHT_ALIENS(pc),a0
	move.w	#0x3F,d1
0:
	clr.l	(a0)+
	dbf		d1,0b     | Fill the entire INFLIGHT_ALIENS array with zero
    clr.b	ATTRACT_MODE_SCROLL_ID
    rts

SCROLL_ON_CONVOY_CHARGER_POINTS:
	jbsr	HANDLE_ALIEN_SWARM_SCROLL_RESET
	jbsr	HANDLE_INFLIGHT_ALIEN_SPRITE_UPDATE
	jbsr	HANDLE_INFLIGHT_ALIENS

	jbsr	HANDLE_DRAW_CONVOY_CHARGER_POINTS
	subq.b	#1,TEMP_COUNTER_1
	beq.b	0f
	rts
0:
	move.b	#0xD2,TEMP_COUNTER_1

* get ready to scroll the next alien sprite and associated points values on screen
	jbsr	INIT_CONVOY_CHARGER_SPRITE
	addq.b	#1,ATTRACT_MODE_SCROLL_ID     | set id to next thing to scroll on
	subq.b	#1,TEMP_COUNTER_2			  | dec TEMP_COUNTER_2
	beq.b	0f
	rts
0:
	move.b	#0xD2,TEMP_COUNTER_2
	addq.b	#1,SCRIPT_STAGE
	clr.b	OBJRAM_BACK_BUF+0x38		      | write to scroll offset in OBJRAM_BACK_BUF (0x4058)
	rts


*
* This important routine is responsible for handling the enemy sprites in the game. 
* It reads the position, colour and animation frame of each item in the INFLIGHT_ALIENS array and 
* projects it into the relevant INFLIGHT_ALIEN_SPRITE of OBJRAM_BACK_BUF_SPRITES. 
*
* In plain English: the sprite back buffer is filled by this routine :) 
* 
* JOTD: removed cocktail mode

HANDLE_INFLIGHT_ALIEN_SPRITE_UPDATE:
	lea		INFLIGHT_ALIENS(pc),a2
	lea		OBJRAM_BACK_BUF_SPRITES(pc),a3
*
** for the first 3 alien sprites, their Y coordinates need to be offset 7 pixels vertically so that the hardware can render them correctly.
	move.w	#3-1,d1                            | number of sprites to set sprite state for
	moveq	#7,d2							   | set pixel offset to 7
0:
	jbsr	SET_SPRITE_STATE
	add.w	#inflight_alien_size,a2
	addq.w	#0x4,a3
	dbf		d1,0b
*
** for the next 5 alien sprites, their Y coordinates need to be offset 8 pixels vertically.
	move.w	#5-1,d1                            | number of sprites to set sprite state for
	moveq	#8,d2							   | set pixel offset to 8
0:
	jbsr	SET_SPRITE_STATE
	add.w	#inflight_alien_size,a2
	addq.w	#0x4,a3
	dbf		d1,0b
	rts
*
* Extract the colour, position, animation frame information from an INFLIGHT_ALIEN structure
* and project it into a INFLIGHT_ALIEN_SPRITE.
*
* Expects:
* C = pixel adjustment for Y coordinate
* IX = pointer to INFLIGHT_ALIEN structure to extract information from
* IY = pointer to INFLIGHT_ALIEN_SPRITE structure to be filled
*

SET_SPRITE_STATE:
	tst.b	(IsActive,a2)       | test INFLIGHT_ALIEN.IsActive
	jeq		SET_INACTIVE_OR_DYING_SPRITE_STATE   | if alien is not active, goto 
	move.b	(Colour,a2),(2,a3)		| read INFLIGHT_ALIEN.Colour, write to INFLIGHT_ALIEN_SPRITE.Colour
	move.b	(inf_alien_X,a2),d0          | read INFLIGHT_ALIEN.X
	subq.b	#8,d0
	move.b	d0,(3,a3)    | write to INFLIGHT_ALIEN_SPRITE.X
	move.b	(inf_alien_Y,a2),d0    | read INFLIGHT_ALIEN.Y 
	not.b	d0          | flip bits  
    sub.b	d2,d0                 | subtract pixel adjustment
    move.b	d0,(a3)          | write to INFLIGHT_ALIEN_SPRITE.Y 
*
** Determine what way the alien is facing and set the sprite XFlip/YFlip/Code properties accordingly
**
** Important point to remember: non-flagship aliens are like bats. They hang upside down in the swarm.
** If you want to see what the sprites look like before being flipped, refer to my sprite grabs @ 
** http://seanriddle.com/galaxiansprites.html
*
	move.b	(AnimationFrame,a2),d0       | read INFLIGHT_ALIEN.AnimationFrame
l_C40:
	bpl.b	0f
	cmp.b   #0xFA,d0                 | compare to -6 
	bmi.b	1f

** alien is between an angle of 90 and 180 degrees (as player sees it)
	not.b	d0
	add.b  #0x12,d0
	or.b	#0x40,d0                           | set X-Flip bit for sprite
	add.b	d0,(AnimFrameStartCode,a2)         | add in INFLIGHT_ALIEN.AnimFrameStartCode
	move.b	d0,(1,a3)                          | write to INFLIGHT_ALIEN_SPRITE.Code
    addq.b	#1,(3,a3)           			   | increment INFLIGHT_ALIEN_SPRITE.X
	rts
0:
	cmp.b	#6,d0
	bpl.b	2f

** alien is between an angle of 180 and 270 degrees (as player sees it)
	add.b	#0x11,d0
	or.b	#0xC0,d0        | set X-Flip and Y-Flip bits for sprite
	add.b	d0,(AnimFrameStartCode,a2)          | add in INFLIGHT_ALIEN.AnimFrameStartCode
	move.b	d0,(1,a3)        				   | write to INFLIGHT_ALIEN_SPRITE.Code
    addq.b	#1,(3,a3)           			   | increment INFLIGHT_ALIEN_SPRITE.X
    addq.b	#1,(a3)           			       | increment INFLIGHT_ALIEN_SPRITE.Y
	rts
2:
	cmp.b	#0xC,d0
	bpl.b	3f

** alien is between an angle of 270-360 degrees (as player sees it)
	not.b	d0
	add.b	#0x1E,d0
	bset	#7,d0                               | set Y-Flip bit for sprite
	add.b	d0,(AnimFrameStartCode,a2)          | add in INFLIGHT_ALIEN.AnimFrameStartCode
	move.b	d0,(1,a3)        				   | write to INFLIGHT_ALIEN_SPRITE.Code
    addq.b	#1,(a3)           			       | increment INFLIGHT_ALIEN_SPRITE.Y
	rts

1:
	cmp.b	#0xF4,d0
	bmi.b	4f

** alien is between an angle of 0-90 degrees (as player sees it)
	add.w	#0x1D,d0
	add.b	d0,(AnimFrameStartCode,a2)          | add in INFLIGHT_ALIEN.AnimFrameStartCode
	move.b	d0,(1,a3)        				   | write to INFLIGHT_ALIEN_SPRITE.Code
	rts
*
3:
	sub.b	#0x18,d0
	bra.b	l_C40
4:
	add.b	#0x18,d0
	bra.b	l_C40


*
* Jumped to from SET_SPRITE_STATE when the INFLIGHT_ALIEN is inactive or dying.
*
* Expects:
* C = pixel adjustment for Y coordinate
* IX = pointer to INFLIGHT_ALIEN structure
* IY = pointer to INFLIGHT_ALIEN_SPRITE structure

SET_INACTIVE_OR_DYING_SPRITE_STATE:
	tst.b	(IsDying,a2)		| test INFLIGHT_ALIEN.IsDying flag
	beq.b	0f					| if the alien has finally expired, goto 0x0CBA

* alien is dying
	move.b	#7,(2,a3)        | set INFLIGHT_ALIEN_SPRITE.Colour
	move.b	(inf_alien_X,a2),d0		   | read INFLIGHT_ALIEN.X
	subq.b	#8,d0
	move.b	d0,(3,a3)     | set INFLIGHT_ALIEN_SPRITE.X
	move.b	(inf_alien_Y,a2),d0		  | read INFLIGHT_ALIEN.Y 
	not.b	d0
	sub.b	d2,d0		       | subtract pixel adjustment value
	move.b	d0,(a3)			 | set INFLIGHT_ALIEN_SPRITE.Y 

	move.b	(DyingAnimFrameCode,a2),(1,a3)	| read INFLIGHT_ALIEN.DyingAnimFrameCode
											| and set INFLIGHT_ALIEN_SPRITE.Code 
	rts
0:
* This alien has died. Move sprite off-screen
	move.b	#0xF8,(3,a3)     | set INFLIGHT_ALIEN_SPRITE.X to value offscreen
	move.b	#0xF8,(0,a3)     | set INFLIGHT_ALIEN_SPRITE.Y to value offscreen
	rts
	

DISPLAY_NAMCO_LOGO:
	jbsr	HANDLE_ALIEN_SWARM_SCROLL_RESET
	jbsr	HANDLE_INFLIGHT_ALIEN_SPRITE_UPDATE
	jbsr	HANDLE_INFLIGHT_ALIENS
	jbsr	HANDLE_DRAW_CONVOY_CHARGER_POINTS

* wait until TEMP_COUNTER_2 reaches 0
	subq.b	#1,TEMP_COUNTER_2
	beq.b	0f
	rts
0:
	addq.b	#1,SCRIPT_STAGE		| advance to next stage
	clr.b	OBJRAM_BACK_BUF+0x38		      | write to scroll offset in OBJRAM_BACK_BUF (0x4058)
	move.b	#0x11,TEMP_COUNTER_2
	move.b	#0x40,TEMP_COUNTER_1
	addq.b	#1,ATTRACT_MODE_SCROLL_ID
	bsr		osd_break
	move.w	#0x060F,d3            | command: PRINT_TEXT, parameter: #0x0F (Displays NAMCO logo)
	jra		QUEUE_COMMAND               


*
*
*
*
*

BLINK_CONVOY_CHARGER_POINTS:
	jbsr	HANDLE_ALIEN_SWARM_SCROLL_RESET
	jbsr	HANDLE_INFLIGHT_ALIEN_SPRITE_UPDATE
	jbsr	HANDLE_INFLIGHT_ALIENS
	jbsr	HANDLE_DRAW_CONVOY_CHARGER_POINTS
	jra		WAIT_FOR_TEMP_COUNTERS

CLEAR_WE_ARE_GALAXIANS_SCREEN_AND_DISPLAY_GAME_OVER:
	TODOM	8
DISPLAY_GAME_OVER_AND_REMAINING_CREDIT_2:
	TODOM	9
CLEAR_ALIEN_SWARM_AND_SUSPEND_SWARM_ANIMATION:
	TODOM	10
CREATE_ATTRACT_MODE_ALIEN_SWARM:
	TODOM	11
HANDLE_SPAWN_PLAYER:
	TODOM	12
HANDLE_MAIN_GAME_LOGIC:
	TODOM	13
HANDLE_PLAYER_ONE_KILLED:
	TODOM	14

*
* In the demo mode, this erases all of the points values underneath the text "CHARGER"
*
* in D1: number of rows

CLEAR_DEMO_CONVOY_CHARGER_POINTS:
     move.w	#0x5193,d6            | address in character RAM
     move.w	#-32,d3            | offset to add to character RAM address  (-32 decimal.)
	 and.w	#0xFF,d1
	 subq.w	#1,d1
0:
     move.b	#3,d2               | 3 characters to erase
     move.b	#0x10,d0               | ordinal of empty character
1:
     jbsr	osd_w_bg_videoram           | write empty character to screen       
     add.w	d3,d6               | add offset. HL now points to character a row above, same column               
     subq.b	#1,d2               | decrement count of characters to erase
     bne.b	1b            | if not done goto 0x03CA
     add.w	#0x62,d6
     dbf	d1,0b
     rts


*
* Handles the drawing and blinking of the CONVOY CHARGER points values in the demo.
*

HANDLE_DRAW_CONVOY_CHARGER_POINTS:
	tst.b	ATTRACT_MODE_SCROLL_ID
	bne.b	0f
	rts					| if its zero, not time to scroll anything in yet, return
0:
	subq.b	#1,d0		| JOTD: if its one, seems that it's the same!
	bne.b	1f
	rts
1:
	move.b	d0,d1
	move.b	TIMING_VARIABLE(pc),d0
	move.b	d0,d2				 | save it in C 
	and.w	#0x3F,d0                 | mask in bits 0..5. Now A is a value from 0..63 decimal.
	bne.b	2f
	jbsr	CLEAR_DEMO_CONVOY_CHARGER_POINTS 	| if bits 0..5 are not set, call CLEAR_DEMO_CONVOY_CHARGER_POINTS
2:
	cmp.b	#0x20,d0
	bne.b	3f		| If A is not exactly 0x20 exit
	rts
3:

* When we get here, we need to compute what flagship scores we are going to draw. 
* We basically take the value in TIMING_VARIABLE, AND the value by 3 to give an index value in range of 0..3, then
* multiply the index by 3 to give an offset into the flagship score table @0x039A.  
* The end result is cycling flagship values.

	roxl.b	#2,d2		| TIMING_VARIABLE saved in d2
	and.w	#3,d2		| now d2 is a value from 0..3. d2 is now an index into table @0x039A 
	move.w	d2,d0
	add.w	d2,d2
	add.w	d0,d2		| multiply d2 by 3
	lea		flagship_table_039A,a0
	move.w	#0x5193,d3      | address in character RAM
	jbsr	DRAW_3_CHARACTERS
	subq.b	#1,d1
	bne.b	4f
	rts
4:
	subq.b	#1,d1
	and.w	#0xFF,d1
* The alien scores are static and don't cycle, so we just draw them straight from the table 
	lea	alien_table_03A6(pc),a0				| pointer to Alien score table
5:
	jbsr	DRAW_3_CHARACTERS
	dbf		d1,5b
	rts


*
* This routine is responsible for positioning alien sprites off screen ready to be scrolled onto the CONVOY CHARGER points table.
* Once the positioning is done, the sprite is "handed over" to the routine @ 0x109B.
*
* Expects: HL(a0) points to TEMP_COUNTER_2
*
* The value in TEMP_COUNTER_2 specifies what type of alien we are scrolling on:
*
* 4: Flagship
* 3: Red alien
* 2: Purple alien
* 1: Blue alien
*

INIT_CONVOY_CHARGER_SPRITE:
	moveq	#0,d0
	move.b	TEMP_COUNTER_2(pc),d0     | read type of alien to scroll on
	subq.b	#1,d0		| convert A into a 0-based index 
	move.b	d0,d1
	
	lsr.w	#5,d0		| multiply A by 32 (which is sizeof(INFLIGHT_ALIEN))
	lea		INFLIGHT_ALIENS(pc),a0	  | HL = address of INFLIGHT_ALIENS[3]
	add.w	d0,a0					   | Add offset to HL. HL now points to INFLIGHT_ALIEN record we're using to scroll sprite on with
	move.b	#1,(a0)+            | set INFLIGHT_ALIEN.IsActive to 1 
	clr.b	(a0)+				| reset INFLIGHT_ALIEN.IsDying 
	move.b	#0xD,(a0)+			| set INFLIGHT_ALIEN.StageOfLife to INFLIGHT_ALIEN_CONVOY_CHARGER_SET_COLOUR_POS_ANIM
	addq.w	#1,a0
	clr.b	(a0)+               | set INFLIGHT_ALIEN.Y to position offscreen
	move.b	#0xC,(a0)+		        | set INFLIGHT_ALIEN.AnimationFrame
	addq.w	#1,a0
	move.b	d1,(a0)				     | set INFLIGHT_ALIEN.IndexInSwarm 
	rts


SET_SCRIPT_STAGE_TO_1:
	move.b	#1,SCRIPT_STAGE         | set SCRIPT_STAGE to 1
	move.b	#3,TEMP_COUNTER_1
	move.b	#3,TEMP_COUNTER_2
	rts

*
* Decrements value in TEMP_COUNTER_2. When counter value hits zero, advance script to next stage.
* 

WAIT_FOR_TEMP_COUNTER_2_THEN_ADVANCE_TO_NEXT_STAGE:
	subq.b	#1,TEMP_COUNTER_2        | decrement value of TEMP_COUNTER_2 counter
	beq.b	0f
	rts
0:
	addq.b	#1,SCRIPT_STAGE		| advance script to next stage
	rts

*
* Draw 3 characters in the same *column*.
* Because the Galaxian monitor is turned on its side, the characters look like they are on the same row.
* 
* Expects:
* A0 to point to 3 bytes defining the characters to draw 
* D3 to point to character RAM to draw to
*

DRAW_3_CHARACTERS:
    move.b	#3,d2               | number of characters to draw
	move.w	d3,d6
0:    
	move.b	(a0)+,d0           | read character to draw  
    bsr		osd_w_bg_videoram  | write to character RAM
    sub.w	#0x20,d6           | subtract #0x20 (32 decimal) from it. Now DE points to character in same column, row above 
    subq.b	#1,d2              | decrement counter of characters to draw. 
    bne.b	0b                 | if counter !=0, more characters are to be drawn, goto 0x03B1
    add.w	#0x62,d6           | Add #0x62 (98 decimal) to DE. Now DE is back on row we started drawing from.
	move.w	d6,d3
    rts


*
* Decrements value in TEMP_COUNTER_1. When counter value hits zero, reset value of TEMP_COUNTER_1 to 0x3C (60 decimal)
* and then decrement value of TEMP_COUNTER_2. 
*
* When value of TEMP_COUNTER_2 hits zero, advance script to next stage.
*

WAIT_FOR_TEMP_COUNTERS:
	subq.b	#1,TEMP_COUNTER_1        | decrement value of TEMP_COUNTER_1 counter
	beq.b	0f
	rts
0:
	move.b	#0x3C,TEMP_COUNTER_1             | reset counter to 0x3C (50 decimal)
	bra.b	WAIT_FOR_TEMP_COUNTER_2_THEN_ADVANCE_TO_NEXT_STAGE	| and go check if that counter 2 has counted down to 0 yet 


SET_PUSH_START_BUTTON_COUNTER:
	move.b	#1,PUSH_START_BUTTON_COUNTER
	bra.b	WAIT_FOR_TEMP_COUNTERS
	
* < A1: player score which replaces high score
UPDATE_HIGH_SCORE:
		bsr	LEA_DE_OF_CURRENT_PLAYER_SCORE	| Now DE = pointer to current player score
		lea	HI_SCORE(pc),a0		| address of high score
		moveq	#2,d2			| high score occupies 3 bytes
0:
		move.b	(a1)+,(a0)+
		dbf		d2,0b
		subq.w	#1,a1
l_21F8: move.w	#0x5241,d6            | character RAM address where HIGH SCORE will be drawn
		jbra	PLOT_SCORE_CHARACTERS

*
* This routine is responsible for processing all 8 elements in the INFLIGHT_ALIENS array. 
*

HANDLE_INFLIGHT_ALIENS:
	lea		INFLIGHT_ALIENS(pc),a2           | load IX with address of 
    move.w	#inflight_alien_size,d2                         | sizeof(INFLIGHT_ALIEN)
	move.w	#8-1,d1							| 1 misc + 7 attacking aliens to process
0:
	movem.l	d1/d2,-(a7)
	jbsr	HANDLE_INFLIGHT_ALIEN_STAGE_OF_LIFE
	movem.l	(a7)+,d1/d2
	add.w	d2,a2		        | bump IX to point to next INFLIGHT_ALIEN structure
	dbf		d1,0b               | do while b!=0
	rts

*
* Like humans, inflight aliens go through stages of life. They leave home, attack humans, maybe do a loop the loop,
* then (maybe) return home. Just like we do!
* 
* This routine is used to invoke actions appropriate for the alien's stage of life.
*
* Expects:
* IX = pointer to INFLIGHT_ALIEN structure.
*

HANDLE_INFLIGHT_ALIEN_STAGE_OF_LIFE:
	tst.b	(IsDying,a2)          | test INFLIGHT_ALIEN.IsDying flag
	jne		HANDLE_INFLIGHT_ALIEN_DYING    | if alien is dying, goto 
	tst.b	(IsActive,a2)          | test INFLIGHT_ALIEN.IsActive flag 
	bne.b	0f		| exit if not active
	rts
0:
* We need to determine what stage of life the inflight alien is at, then call the appropriate function to
* tell it how to behave. 
	moveq	#0,d0
	move.b	(StageOfLife,a2),d0 	| read INFLIGHT_ALIEN.StageOfLife
	add.w	d0,d0
	add.w	d0,d0
	lea		table_0CE6(pc),a0
	move.l	(a0,d0.w),a0
	jmp		(a0)

table_0CE6: 
      .long		INFLIGHT_ALIEN_PACKS_BAGS
      .long		INFLIGHT_ALIEN_FLIES_IN_ARC
      .long		INFLIGHT_ALIEN_READY_TO_ATTACK
      .long		INFLIGHT_ALIEN_ATTACKING_PLAYER
      .long		INFLIGHT_ALIEN_NEAR_BOTTOM_OF_SCREEN
      .long		INFLIGHT_ALIEN_REACHED_BOTTOM_OF_SCREEN
      .long		INFLIGHT_ALIEN_RETURNING_TO_SWARM
      .long		INFLIGHT_ALIEN_CONTINUING_ATTACK_RUN_FROM_TOP_OF_SCREEN 
      .long		INFLIGHT_ALIEN_FULL_SPEED_CHARGE 
      .long		INFLIGHT_ALIEN_ATTACKING_PLAYER_AGGRESSIVELY
      .long		INFLIGHT_ALIEN_LOOP_THE_LOOP
      .long		INFLIGHT_ALIEN_COMPLETE_LOOP
      .long		INFLIGHT_ALIEN_UNKNOWN_1091
      .long		INFLIGHT_ALIEN_CONVOY_CHARGER_SET_COLOUR_POS_ANIM
      .long		INFLIGHT_ALIEN_CONVOY_CHARGER_START_SCROLL  
      .long		INFLIGHT_ALIEN_CONVOY_CHARGER_DO_SCROLL


*
* Called when the alien is dying.
*

HANDLE_INFLIGHT_ALIEN_DYING:
	moveq	#0,d0
	move.b	(StageOfLife,a2),d0 	| read INFLIGHT_ALIEN.StageOfLife
	add.w	d0,d0
	add.w	d0,d0
	lea		table_10E8(pc),a0
	move.l	(a0,d0.w),a0
	jmp		(a0)

table_10E8:
    .long	INFLIGHT_ALIEN_DYING_SETUP_ANIM_AND_SOUND    
    .long	INFLIGHT_ALIEN_DYING_DISPLAY_EXPLOSION
    .long	INFLIGHT_ALIEN_DYING_FINALLY_BUYS_FARM
    .long	JUST_RTS

JUST_RTS:
	rts
	
INFLIGHT_ALIEN_PACKS_BAGS:
	TODOM	0x100
INFLIGHT_ALIEN_FLIES_IN_ARC:	
	TODOM	0x101

INFLIGHT_ALIEN_CONVOY_CHARGER_SET_COLOUR_POS_ANIM:
	TODOM	0x104
INFLIGHT_ALIEN_CONVOY_CHARGER_START_SCROLL:
	TODOM	0x104
INFLIGHT_ALIEN_CONVOY_CHARGER_DO_SCROLL:
	TODOM	0x104
INFLIGHT_ALIEN_DYING_SETUP_ANIM_AND_SOUND:    	
	TODOM	0x104
INFLIGHT_ALIEN_DYING_DISPLAY_EXPLOSION:
	TODOM	0x104
INFLIGHT_ALIEN_DYING_FINALLY_BUYS_FARM:
	TODOM	0x104

	

*
* An alien that has just completed an arc animation (see docs @ 0x0D71 and 0x101F) is now ready to attack the player. 
*
* Expects:
* IX = pointer to INFLIGHT_ALIEN that will attack
*

INFLIGHT_ALIEN_READY_TO_ATTACK:
	addq.b	#1,(inf_alien_X,a2)				  | increment INFLIGHT_ALIEN.X
	move.b	(IndexInSwarm,a2),d0			 | read INFLIGHT_ALIEN.IndexInSwarm
	and.b	#0x70,d0                          | keep the row, remove the column
	cmp.b	#0x60,d0                          | is this a red alien?
	jbeq	l_0E20							   | yes, goto 0x0E20

INFLIGHT_ALIEN_DEFINE_FLIGHTPATH:
	move.b	PLAYER_Y(pc),d1		| read PLAYER_Y 
	move.b	(inf_alien_Y,a2),d0 | read INFLIGHT_ALIEN.Y 
	sub.b	d1,d0               | A = INFLIGHT_ALIEN.Y  - PLAYER_Y
	jcs		l_0E0F             | if alien is to right of player, goto 0x0E0F

* alien is to left of player
* A = signed number representing distance in pixels between alien Y and player Y. 
	asr.b	#1,d0	 				| divide distance by 2     
	add.b	#0x10,d0               | add 0x10 (16 decimal) to product
* clamp A between 0x30 and 0x70
	cmp.b   #0x30,d0                 | compare to 48 (decimal)
	jcc		0f            | if A>=48 goto 0x0DF0
	move.b   #0x30,d0
0:
	cmp.b   #0x70,d0                 | compare to 112 (decimal)  NB: 112 is half the screen height in pixels
	jcs		l_0DF6
	move.b	#0x70,d0

* PivotYValue is a Y coordinate to pivot around. You could think of it like the "origin" Y coordinate. 
* PivotYValueAdd is a delta (offset) to add to PivotYValue to produce the correct Y coordinate of the alien.
*
* PivotYValueAdd will increment if the player is to the left of the alien when it leaves the swarm,
* or decrement if the player is to the right. 

l_0DF6:
	move.b	d0,(PivotYValueAdd,a2)          | set INFLIGHT_ALIEN.PivotYValueAdd
	sub.b	(inf_alien_Y,a2),d0            | subtract INFLIGHT_ALIEN.Y 
	neg.b	d0
	move.b	d0,(a2,PivotYValue)          | set INFLIGHT_ALIEN.PivotYValue. Now PivotYValue + PivotYValueAdd = INFLIGHT_ALIEN.Y
	clr.b	(0x1a,a2)
	clr.b	(0x1b,a2)			| ???? unknown stuff, but probably useful!!
	clr.b	(0x1c,a2)

	addq.b	#1,(StageOfLife,a2)    | set stage of life to INFLIGHT_ALIEN_ATTACKING_PLAYER or INFLIGHT_ALIEN_ATTACKING_PLAYER_AGGRESSIVELY
	rts

* alien is to right of player
* A = signed number representing distance in pixels between alien and player.
	
l_0E0F:
	asr.b	#1,d0              | perform a shift right, with sign bit preserved
    sub  #0x10,d0
* clamp A between -48 and -112 decimal
	cmp.b   #0xD0,d0                  | compare to -48 (decimal)
	bcs.b	0f
	move.b	#0xD0,d0
0:           
	cmp.b   #0x90,d0                  | compare to -112 (decimal)  NB: 112 is half the screen height in pixels
	bcc.b	l_0DF6
	move.b	#0x90,d0		| clamp to 0x90 (-16)
	jra		l_0DF6


l_0E20:
	tst.b	INFLIGHT_ALIENS+inflight_alien_size+IsActive      | address of INFLIGHT_ALIENS[1].IsActive
	jeq		INFLIGHT_ALIEN_DEFINE_FLIGHTPATH                  | if not set then we are not part of a convoy, goto INFLIGHT_ALIEN_DEFINE_FLIGHTPATH

* make the alien accompany the flagship as part of a convoy. The PivotYValueAdd of the alien is the same as the flagship,
* so it will fly the same path.
	move.b	INFLIGHT_ALIENS+inflight_alien_size+PivotYValueAdd(pc),d0	| read flagship INFLIGHT_ALIENS[1].PivotYValueAdd  
	jra		l_0DF6

*
* This is probably the most important routine for the INFLIGHT_ALIEN. 
*
* It is responsible for making an INFLIGHT_ALIEN fly down the screen, dropping bombs when it can.
*
* Expects:
* IX = pointer to INFLIGHT_ALIEN structure
*

INFLIGHT_ALIEN_ATTACKING_PLAYER:
	addq.b	#1,(inf_alien_X,a2)       | increment INFLIGHT_ALIEN.X 
	jbsr	UPDATE_INFLIGHT_ALIEN_YADD
	move.b	(PivotYValue,a2),d0         | load A with INFLIGHT_ALIEN.PivotYValue
	add.b	(PivotYValueAdd,a2),d0      | add in INFLIGHT_ALIEN.PivotYValueAdd to produce a Y coordinate      
	move.b	d0,(inf_alien_Y,a2)         | write to INFLIGHT_ALIEN.Y 
	addq.b	#7,d0
	cmp.b	#14,d0
	bcs.b	2f                          | if the alien has gone off the side of the screen, return to swarm
	move.b	(inf_alien_X,a2),d0			| load A with INFLIGHT_ALIEN.X
	add.b	#0x48,d0
	bcs.b	3f                          | if the alien is nearing the bottom of the screen, speed it up!
	tst.b	HAS_PLAYER_SPAWNED
	bne.b	0f
	rts		| return if player has not spawned
0:
	jbsr	CALCULATE_INFLIGHT_ALIEN_LOOKAT_ANIM_FRAME
* alien won't shoot at you if a flagship has been hit
	tst.b	IS_FLAGSHIP_HIT
	beq.b	1f		    | return if flagship was hit
	rts
1:
* Can this alien start shooting at you?
*
* code from 0x0E54-0E63 is akin to:
*
* byte yToCheck = INFLIGHT_ALIEN.X|
* for (byte l=0| l<INFLIGHT_ALIEN_SHOOT_RANGE_MUL|l++)
* {
*     if (yToCheck == INFLIGHT_ALIEN_SHOOT_EXACT_X)
*        goto TRY SPAWN_ENEMY_BULLET|
*     else
*        yToCheck+=0x19|
* }
*
	jra		l_0E54			| avoids code duplication


* If only one of these INCs are called (see 0x0E45), INFLIGHT_ALIEN.StageOfLife will be set to INFLIGHT_ALIEN_NEAR_BOTTOM_OF_SCREEN.
* If both these INCs are called (see 0x0E3E), set INFLIGHT_ALIEN.StageOfLife to INFLIGHT_ALIEN_REACHED_BOTTOM_OF_SCREEN. 
2:
	addq.b	#1,(StageOfLife,a2)
3:   
	addq.b	#1,(StageOfLife,a2)
	rts

*
* When an alien is close to the horizontal plane where the player resides, it speeds up to zoom by (or into) the player.
*
* Expects:
* IX = pointer to INFLIGHT_ALIEN structure
*

INFLIGHT_ALIEN_NEAR_BOTTOM_OF_SCREEN:
	move.b	TIMING_VARIABLE(pc),d0
	and.b	#1,d0							| ..now A is either 0 or 1.
	addq.b	#1,d0		                    | ..now A is either 1 or 2. 
	add.b	(inf_alien_X,a2),d0
	move.b	d0,(inf_alien_X,a2)		        | Add either 1 or 2 pixels to INFLIGHT_ALIEN.X
	subq.b	#6,d0
	cmp.b	#3,d0                            | has alien gone off the bottom of the screen?
	jcs		0f
	jbsr		UPDATE_INFLIGHT_ALIEN_YADD
	move.b	(PivotYValueAdd,a2),d0           | read INFLIGHT_ALIEN.PivotYValueAdd
											 | set flags - we are interested if its a minus value
	bmi.b	1f								| if the PivotYValueAdd is a negative value, goto 0x0E90
	add.b	(a2,PivotYValue),d0             | add INFLIGHT_ALIEN.PivotYValue
	bcs.b	0f                              | carry flag set if alien has gone off side of screen,  goto 0x0E95
2:
	move.b	d0,(inf_alien_Y,a2)			            | set INFLIGHT_ALIEN.Y 
	rts
1:
	add.b	(a2,PivotYValue),d0             | add INFLIGHT_ALIEN.PivotYValue
	bcs.b	2b
	
* alien's went off the bottom or the side of the screen. 
0:
	addq.b	#1,(StageOfLife,a2)       | now call INFLIGHT_ALIEN_REACHED_BOTTOM_OF_SCREEN stage of life.
	rts


*
* An inflight alien has flown past the player and left the bottom of the visible screen. 
* 
*
* If the alien is not a flagship, it will always return to the top of the screen.
* Then, its behaviour is determined by flag state:
* 
*    If the HAS_PLAYER_SPAWNED flag is clear, the alien will rejoin the swarm. 
*
*    If both of the HAVE_AGGRESSIVE_ALIENS and HAVE_NO_BLUE_OR_PURPLE_ALIENS flags are clear, 
*    the alien will rejoin the swarm.
*
*    Otherwise, if the criteria above is not satisfied, the alien will keep attacking the player.  
*    
*        
* If the alien is a flagship, then the rules described @ 0x0EDA (INFLIGHT_ALIEN_FLAGSHIP_REACHED_BOTTOM_OF_SCREEN) apply. 
*
* Expects:
* IX = pointer to INFLIGHT_ALIEN structure
*

INFLIGHT_ALIEN_REACHED_BOTTOM_OF_SCREEN:
	move.b	#0x08,(inf_alien_Y,a2)          | set INFLIGHT_ALIEN.X to position at very top of screen
	addq.b	#1,(SortieCount,a2)             | increment INFLIGHT_ALIEN.SortieCount
	clr.b	(AnimationFrame,a2)             | clear INFLIGHT_ALIEN.AnimationFrame

* what type of alien are we dealing with?
	move.b	(IndexInSwarm,a2),d0			  | read INFLIGHT_ALIEN.IndexInSwarm  
	and.b	#0x70,d0                          | remove the column number from the index, keep the row
	cmp.b 	#0x70,d0						  | is this alien a flagship?
	jeq	INFLIGHT_ALIEN_FLAGSHIP_REACHED_BOTTOM_OF_SCREEN  | yes, goto INFLIGHT_ALIEN_FLAGSHIP_REACHED_BOTTOM_OF_SCREEN

l_0EAD:
*if the player has not spawned, the alien will return to the swarm.
	tst.b	HAS_PLAYER_SPAWNED
	jeq		0f	| if player has not spawned yet, goto 0x0ED6 - aliens return to swarm

*  if HAVE_AGGRESSIVE_ALIENS OR HAVE_NO_BLUE_OR_PURPLE_ALIENS flags are set, the alien will keep attacking (see 0x0EBF).
*  otherwise the alien returns to the swarm (see 0x0ED3 and 0x0F07)
	tst.b	HAVE_AGGRESSIVE_ALIENS
	jne		1f					| if aliens are aggressive, make alien reappear at top of screen, keep attacking 
	tst.b	HAVE_NO_BLUE_OR_PURPLE_ALIENS		| read HAVE_NO_BLUE_OR_PURPLE_ALIENS
	jeq		0f             | if we do have any blue or purple aliens, goto 0x0ED6 - aliens return to swarm

* alien reappears at top of screen and will keep attacking - it will not return to swarm. 
* add some unpredictability to where it reappears, so that player can't wait for it and shoot it easily
1:
	move.b	(inf_alien_Y,a2),d0              | read INFLIGHT_ALIEN.Y 
	lsr.b	#1,d0							 | divide by 2 (don't worry about carry, it was cleared by AND above)
	move.b	d0,d2
	jbsr	GENERATE_RANDOM_NUMBER
	and.b	#0x1F,d0                 | ensure random number is between 0..31 decimal
	add.b	d2,d0
	add.b	#0x20,d0
	move.b	d0,(inf_alien_Y,a2)        | set INFLIGHT_ALIEN.Y
	move.b	#0x28,(TempCounter1,a2)    | set INFLIGHT_ALIEN.TempCounter1 for INFLIGHT_ALIEN_UNKNOWN_OF3C to use.

* if both of these incs are called, the stage of life will be set to INFLIGHT_ALIEN_CONTINUING_ATTACK_RUN_FROM_TOP_OF_SCREEN. 
* if only the inc @ 0x0ED6 is invoked (see 0x0EB1), then the stage of life will be set to INFLIGHT_ALIEN_RETURNING_TO_SWARM.
	addq.b	#1,(StageOfLife,a2)		| increment INFLIGHT_ALIEN.StageOfLife
0:
	addq.b	#1,(StageOfLife,a2)		| increment INFLIGHT_ALIEN.StageOfLife
	rts

*
* A flagship has gone off screen.
*
* If the flagship had an escort, it will return to the top of the screen to fight again.
* If the flagship had no escort, it will flee the level. 
* A maximum of 2 fleeing flagships can be carried over to the next level.
*
* Expects:
* IX = pointer to INFLIGHT_ALIEN structure
*

INFLIGHT_ALIEN_FLAGSHIP_REACHED_BOTTOM_OF_SCREEN:
	tst.b	FLAGSHIP_ESCORT_COUNT        | test if flagship actually had any escort!
	jne	INFLIGHT_ALIEN_COUNT_FLAGSHIP_ESCORTS  | if flagship has escort, goto INFLIGHT_ALIEN_COUNT_FLAGSHIP_ESCORTS

* This flagship has no escort. It has escaped the level. 
* Deactivate the INFLIGHT_ALIEN record, and check if this flagship can be carried over to the next wave.
	clr.b	(IsActive,a2)			       | reset INFLIGHT_ALIEN.IsActive
	move.b	FLAGSHIP_SURVIVOR_COUNT(pc),d0
	addq.b	#1,d0                  | add another one to the survivor count!
	cmp.b	#3,d0				   | have we got 3 surviving flagships?
	bcs.b	0f                     | if we have less than 3, that's OK, goto 0x0EEE

* We seem to have 3 flagships but only 2 flagships are allowed to be carried over...
	move.b	#2,d0				  | clamp surviving flagship count to 2.
0:
	move.b	d0,FLAGSHIP_SURVIVOR_COUNT
	rts


* count how many aliens were escorting the flagship. 
INFLIGHT_ALIEN_COUNT_FLAGSHIP_ESCORTS:
	moveq	#0,d0
	tst.b	(inflight_alien_size,a2)          | test IsActive flag of first escort  
	beq.b	0f 
	addq.b	#1,d0		| increment escort count
0:
	tst.b	(inflight_alien_size*2,a2)          | test IsActive flag of second escort  
	beq.b	1f 
	addq.b	#1,d0		| increment escort count
1:
	move.b	d0,FLAGSHIP_ESCORT_COUNT
	jra	l_0EAD         | make flagship reappear at top of screen



*
* An alien has either flown off the side or the bottom of the screen, and is returning to the swarm.
* 
* Expects:
* IX = pointer to INFLIGHT_ALIEN structure           
*

INFLIGHT_ALIEN_RETURNING_TO_SWARM:
	move.b	(inf_alien_X,a2),d1     | keep copy of INFLIGHT_ALIEN.X in B as SET_INFLIGHT_ALIEN_START_POSITION changes it 
    addq.b	#1,d1
    jbsr	SET_INFLIGHT_ALIEN_START_POSITION               | to determine where alien needs to go  

* INFLIGHT_ALIEN.Y  and INFLIGHT_ALIEN.X have been changed by SET_INFLIGHT_ALIEN_START_POSITION
	move.b	(inf_alien_X,a2),d0             | A = destination INFLIGHT_ALIEN.X
	move.b	d1,(inf_alien_X,a2)				| restore INFLIGHT_ALIEN.X back to what it was before
	sub.b	d1,d0                           | OK, how far away is this alien from where it wants to be?
	jbeq	INFLIGHT_ALIEN_BACK_IN_SWARM    | distance is zero, it's got where it wants to be, goto INFLIGHT_ALIEN_BACK_IN_SWARM
	cmp.b	#0x19,d0                 | 25 pixels away?
	bcs.b	0f
	rts		     | if distance is more than 0x19 (25 decimal), not near enough to destination, so exit
0:
	btst	#0,d0            | is distance an odd number?
	beq.b	1f
	rts						    | yes, so exit
1:
* Alien is less than 25 pixels away from its destination back in the swarm.
* We now need to determine what way to rotate the sprite so that it returns to the swarm upside-down, bat-style. 
	tst.b	(ArcClockwise,a2)       | read INFLIGHT_ALIEN.ArcClockwise
	bne.b	2f
	addq.b	#1,(AnimationFrame,a2)    | update INFLIGHT_ALIEN.AnimationFrame to rotate the alien right
	rts
2:
	subq.b	#1,(AnimationFrame,a2)    | update INFLIGHT_ALIEN.AnimationFrame to rotate the alien left
	rts
	
* alien has returned to swarm. Remove sprite and substitute sprite with characters.
INFLIGHT_ALIEN_BACK_IN_SWARM:
	clr.b	(IsActive,a2)                     | set INFLIGHT_ALIEN.IsActive to 0 - will hide sprite (see 0x0C98)
	lea		ALIEN_SWARM_FLAGS(pc),a3          | MSB of ALIEN_SWARM_FLAGS address 
	moveq	#0,d6
	move.b	(IndexInSwarm,a2),d6                                              | Now a3+d6 = pointer to address in ALIEN_SWARM_FLAGS where alien belongs
	moveq	#0,d3							  | command: DRAW_ALIEN_COMMAND
	move.b	#1,(a3,d6.w)                      | mark flag in ALIEN_SWARM_FLAGS as "occupied". Our alien's back in the swarm!
	move.b	d6,d3							  | E = index of alien in swarm
	jra		QUEUE_COMMAND                     | jump to QUEUE COMMAND. Alien will be drawn in its place in the swarm.

*
* Called when aliens are aggressive and refuse to return to the swarm.
*
* This routine makes the alien fly from the top of the screen for [TempCounter1] pixels vertically.
* During this time it won't shoot, but it will gravitate towards the player's horizontal position (as the player sees it).
* 
* The trigger for this stage of life is when:
*     HAVE_AGGRESSIVE_ALIENS is set OR 
*     HAVE_NO_BLUE_OR_PURPLE_ALIENS flag is set 
* 
*

INFLIGHT_ALIEN_CONTINUING_ATTACK_RUN_FROM_TOP_OF_SCREEN:
	addq.b	#1,(inf_alien_X,a2)		| increment INFLIGHT_ALIEN.X
	move.b	PLAYER_Y(pc),d0			  | read PLAYER_Y     
	sub.b	(inf_alien_Y,a2),d0		  | subtract INFLIGHT_ALIEN.Y 
	neg.b	d0
	add.b	d0,d0                     | A = A * 2
	move.b	d0,d4
	subx.b	d0,d0					 | A= 0 - Carry flag
	move.b	d0,d3
	lsl.w	#8,d3
	move.b	d4,d3
	add.w	d3,d3                    | DE = DE * 2
	move.b	(inf_alien_Y,a2),d4
	lsl.w	#8,d4
	move.b	(PivotYValue,a2),d4
	sub.w	d3,d4
	move.b	d4,(PivotYValue,a2)    | update INFLIGHT_ALIEN.Y 
	lsr.w	#8,d4                  
	move.b	d4,(inf_alien_X,a2)    | update INFLIGHT_ALIEN.PivotYValue
	subq.b	#1,(TempCounter1,a2)   | counter was set @ 0x0ECF
	beq.b	0f
	rts
0:
	addq.b	#1,(StageOfLife,a2)				| set INFLIGHT_ALIEN.StageOfLife to INFLIGHT_ALIEN_FULL_SPEED_CHARGE
	rts


*
* The inflight alien is now going to fly at full speed and zigzag to make it harder to shoot. 
* It won't drop bombs, but it will gravitate towards the player.
*
* When the alien gets to the vertical (as the player sees it) centre of the screen, the alien will loop
* the loop if there's enough space to do so. 
*
* After the loop is complete, the alien will start shooting.
*

INFLIGHT_ALIEN_FULL_SPEED_CHARGE:
	addq.b	#1,(inf_alien_X,a2)		| increment INFLIGHT_ALIEN.X

* first check the X coordinate to see if the alien is in the centre
	move.b	(inf_alien_X,a2),d0         | read INFLIGHT_ALIEN.X 
	sub.b  #0x60,d0                       
	cmp.b   #0x40,d0
	bcc.b	l_0F7B           | if INFLIGHT_ALIEN.X-0x60 >= 0x40, we're not centre horizontally   

* next thing we need to do is check if we have enough space for a loop.
	move.b	(inf_alien_Y,a2),d0          | read INFLIGHT_ALIEN.Y 
	sub.b  #0x60,d0                       
	cmp.b   #0x40,d0
	bcs.b	1f                 | yes, we have space, make alien loop the loop
l_0F7B:
* otherwise, make the alien veer erratically. 
	jbsr	INFLIGHT_ALIEN_DEFINE_FLIGHTPATH
	move.b	#3,(Speed,a2)                     | set INFLIGHT_ALIEN.Speed to maximum!
	move.b	#0x64,(TempCounter1,a2)            | set INFLIGHT_ALIEN.TempCounter1
	rts   
1:
	addq.b	#2,(StageOfLife,a2)                | set INFLIGHT_ALIEN.StageOfLife to INFLIGHT_ALIEN_LOOP_THE_LOOP 
	move.b	#3,(TempCounter1,a2)               | set INFLIGHT_ALIEN.TempCounter1 to delay before changing animation frame
	move.b	#0xc,(TempCounter2,a2)             | set INFLIGHT_ALIEN.TempCounter2 to number of animation frames in total
	clr.b	(AnimationFrame,a2)                | set INFLIGHT_ALIEN.AnimationFrame
	clr.b	(ArcTableLsb,a2)				  | set INFLIGHT_ALIEN.ArcTableLsb 
	move.b	PLAYER_Y(pc),d0					| read PLAYER_Y 
	sub.b   (inf_alien_Y,a2),d0             | subtract INFLIGHT_ALIEN.Y 
	bcs.b	2f								| if player to right of alien, make alien loop the loop clockwise

* alien will perform an anti-clockwise loop
	clr.b	(ArcClockwise,a2)      | reset INFLIGHT_ALIEN.ArcClockwise
	rts
2:
	move.b	#1,(ArcClockwise,a2)      | set INFLIGHT_ALIEN.ArcClockwise
	rts


*
* You've killed a lot of the alien's friends. It's going to keep coming after you until one of you dies.
*
*
*

INFLIGHT_ALIEN_ATTACKING_PLAYER_AGGRESSIVELY:
	addq.b	#1,(inf_alien_X,a2)          | increment INFLIGHT_ALIEN.X
	jbsr	UPDATE_INFLIGHT_ALIEN_YADD
	move.b	(SortieCount,a2),d0           | read INFLIGHT_ALIEN.SortieCount           
	cmp.b	#4,d0						  | has the alien made it past the player 4 times?
	beq.b	4f							  | yes, exactly 4 times, *maybe* make alien closer to player                                                                 
	bcc.b	5f							| more than 4 times, make aliens hug player closer 
l_0FBE:
	move.b	(PivotYValue,a2),d0         | INFLIGHT_ALIEN.PivotYValue
	add.b	(PivotYValueAdd,a2),d0      | Add INFLIGHT_ALIEN.PivotYValueAdd 
	move.b	d0,(inf_alien_Y,a2)         | set INFLIGHT_ALIEN.Y 
* has alien wandered off left or right side of screen as player sees it?
	add.b	#7,d0
	cmp.b	#0xE,d0
	bcs.b	1f                          | alien has gone off side of screen, goto 0x0FF6

* is alien near bottom of the screen?
      move.b	(inf_alien_X,a2),d0          | read INFLIGHT_ALIEN.X
      add.b	#0x40,d0               | 
      bcs.b	2f             | if adding 0x40 pixels to X gives a result >255, then alien is near bottom of screen, goto 0x0FFB
      subq.b	#1,(TempCounter1,a2)
      beq.b	3f
	  tst.b	HAS_PLAYER_SPAWNED
      bne.b	11f
      rts                  | return if player has not spawned
11:
      jbsr	CALCULATE_INFLIGHT_ALIEN_LOOKAT_ANIM_FRAME
      tst.b	IS_FLAGSHIP_HIT
      beq.b	l_0E54
      rts                   | return if flagship has been hit
l_0E54:
* OK, can this alien start firing at you? Exact duplicate of code @0x0E54, look there for docs on how algorithm works. 
* Can this alien start shooting at you?
*
* code from 0x0E54-0E63 is akin to:
*
* byte yToCheck = INFLIGHT_ALIEN.X;
* for (byte l=0; l<INFLIGHT_ALIEN_SHOOT_RANGE_MUL;l++)
* {
*     if (yToCheck == INFLIGHT_ALIEN_SHOOT_EXACT_X)
*        goto TRY SPAWN_ENEMY_BULLET;
*     else
*        yToCheck+=0x19;
* }
*

	move.b	INFLIGHT_ALIEN_SHOOT_EXACT_X(pc),d5
	move.b	INFLIGHT_ALIEN_SHOOT_RANGE_MUL(pc),d6
	move.b	(inf_alien_X,a2),d0
10:
	cmp.b	d5,d0		| compare A to INFLIGHT_ALIEN_SHOOT_EXACT_X 
	jeq	TRY_SPAWN_ENEMY_BULLET	| if equal, jump to TRY_SPAWN_ENEMY_BULLET
	add.b	#0x19,d0				| add 0x19 (25 decimal) to A
	subq.b	#1,d6		| and try again...
	bne.b	10b
	rts
1:
	move.b	#0x05,(StageOfLife,a2)        | set INFLIGHT_ALIEN.StageOfLife to INFLIGHT_ALIEN_REACHED_BOTTOM_OF_SCREEN
    rts
2:
	move.b	#0x04,(StageOfLife,a2)        | set INFLIGHT_ALIEN.StageOfLife to INFLIGHT_ALIEN_NEAR_BOTTOM_OF_SCREEN
    rts
3:
	subq.b	#1,(StageOfLife,a2)
	rts
4:
* If we get here, the alien has survived exactly 4 continuous sorties.     
	btst	#0,TIMING_VARIABLE      | is the number odd?
	jeq		l_0FBE             | no, the number's even, it's business as usual, goto 0x0FBE
5:
* If we get here, the alien is going to "hug" the player a little bit closer than he might like.
* Note: This routine is *always* called if the alien survives 5 continuous sorties or more. 
	move.b	PLAYER_Y(pc),d0		| read PLAYER_Y 
	sub.b  (a2,PivotYValue),d0  | subtract INFLIGHT_ALIEN.PivotYValue
	bcs.b	6f					|   if a carry occurred, alien is, as player sees it, to left of player ship

* Make the alien's pivot Y coordinate a bit closer to the player...
	addq.b	#1,(PivotYValue,a2)            | Update INFLIGHT_ALIEN.PivotYValue
	jra		l_0FBE
6:
	subq.b	#1,(PivotYValue,a2)            | Update INFLIGHT_ALIEN.PivotYValue
	jra		l_0FBE


*
* Aggressive aliens sometimes do a 360 degree loop to taunt the player.
*
* This routine rotates the alien 270 degrees. The remaining 90 degrees is done by the INFLIGHT_ALIEN_FLIES_IN_ARC routine. 
*
* Expects:  
* IX = pointer to INFLIGHT_ALIEN structure
*

INFLIGHT_ALIEN_LOOP_THE_LOOP:
	moveq	#0,d6
	move.b	(ArcTableLsb,a2),d6
	lea		INFLIGHT_ALIEN_ARC_TABLE(pc),a3
	add.w	d6,a3
* Now a3 is a pointer to an entry in the INFLIGHT_ALIEN_ARC_TABLE (see docs @ 0x1E00)
	move.b	(inf_alien_X,a2),d0
	sub.b	(a3)+,d0
	move.b	d0,(inf_alien_X,a2)     | subtract X component from table  

	tst.b	(ArcClockwise,a2)         | is this alien going to do a clockwise loop?
	jne		INFLIGHT_ALIEN_LOOPING_CLOCKWISE

* Alien is performing a counter-clockwise loop-the-loop maneuvre
	move.b	(inf_alien_Y,a2),d0			   | read INFLIGHT_ALIEN.Y
	sub.b	(a3),d0					      | subtract Y component from INFLIGHT_ALIEN_ARC_TABLE
	move.b	d0,(inf_alien_Y,a2)            | set INFLIGHT_ALIEN.Y 
* now update to next X,Y pair in INFLIGHT_ALIEN_ARC_TABLE
	addq.b	#2,d6
	move.b	d6,(ArcTableLsb,a2)             | set INFLIGHT_ALIEN.ArcTableLsb
	subq.b	#1,(TempCounter1,a2)            | decrement INFLIGHT_ALIEN.TempCounter1 
	beq.b	0f
	rts
0:

* When INFLIGHT_ALIEN.TempCounter1 counts down to zero, its time to change the animation frame
	move.b	#4,(TempCounter1,a2)    | reset INFLIGHT_ALIEN.TempCounter1 
	subq.b	#1,(AnimationFrame,a2)            | change sprite frame to appear to rotate LEFT

* INFLIGHT_ALIEN.TempCounter2 is used to count down number of animation frames left
	subq.b	#1,(TempCounter2,a2)            | decrement INFLIGHT_ALIEN.TempCounter2
	beq.b	2f                  | return if we haven't done 
	rts
2:
* we've done 270 degrees rotation, hand off the remaining 90 to the INFLIGHT_ALIEN_FLIES_IN_ARC 
	addq.b	#1,(StageOfLife,a2)   | bump INFLIGHT_ALIEN.StageOfLife to INFLIGHT_ALIEN_COMPLETE_LOOP
	move.b	#3,(TempCounter1,a2)        | set INFLIGHT_ALIEN.TempCounter1 to delay before changing animation frame
	move.b	#0xC,(TempCounter2,a2)        | set INFLIGHT_ALIEN.TempCounter2 to number of animation frames
	move.b	#0xC,(AnimationFrame,a2)       | set INFLIGHT_ALIEN.AnimationFrame
	clr.b	(a2,ArcTableLsb)          | set INFLIGHT_ALIEN.ArcTableLsb
	rts


* Alien is performing a clockwise loop-the-loop maneuvre
INFLIGHT_ALIEN_LOOPING_CLOCKWISE:
	move.b	(inf_alien_Y,a2),d0          | read INFLIGHT_ALIEN.Y
	add.b	(a3),d0              | add Y component from INFLIGHT_ALIEN_ARC_TABLE
	move.b	d0,(inf_alien_Y,a2)             | set INFLIGHT_ALIEN.Y
	                               | bump HL to point to next X,Y pair in INFLIGHT_ALIEN_ARC_TABLE
	addq.b	#2,d6
	move.b	d6,(ArcTableLsb,a2)             | set INFLIGHT_ALIEN.ArcTableLsb
	subq.b	#1,(TempCounter1,a2)            | decrement INFLIGHT_ALIEN.TempCounter1 
	beq.b	1f
	rts
1:

* When INFLIGHT_ALIEN.TempCounter1 counts down to zero, its time to change the animation frame
	move.b	#4,(TempCounter1,a2)           |  reset INFLIGHT_ALIEN.TempCounter1 
	addq.b	#1,(AnimationFrame,a2)         | change sprite frame to appear to rotate RIGHT
	subq.b	#1,(TempCounter2,a2)
	beq.b	2f
	rts
2:
* we've done 270 degrees rotation, hand off the remaining 90 to the INFLIGHT_ALIEN_FLIES_IN_ARC
	addq.b	#1,(StageOfLife,a2)            | bump INFLIGHT_ALIEN.StageOfLife to INFLIGHT_ALIEN_COMPLETE_LOOP
	move.b	#3,(TempCounter1,a2)        | set INFLIGHT_ALIEN.TempCounter1 to delay before changing animation frame
	move.b	#0xC,(TempCounter2,a2)        | set INFLIGHT_ALIEN.TempCounter2 to number of animation frames
	move.b	#0xF4,(AnimationFrame,a2)        | set INFLIGHT_ALIEN.AnimationFrame
	clr.b	(a2,ArcTableLsb)        | set INFLIGHT_ALIEN.ArcTableLsb
	rts


INFLIGHT_ALIEN_COMPLETE_LOOP:
		jra		INFLIGHT_ALIEN_FLIES_IN_ARC


INFLIGHT_ALIEN_UNKNOWN_1091:
	addq.b	#1,(inf_alien_X,a2)               | update INFLIGHT_ALIEN.X
	move.b	#8,(StageOfLife,a2)        | set INFLIGHT_ALIEN.StageOfLife to INFLIGHT_ALIEN_FULL_SPEED_CHARGE
	jra		l_0F7B               

*
* To monitor the input parameters type the following into the MAME debugger:
* bp 117E,1,{printf "IX=%04X:   H=%01X L=%01X D=%01X E=%01X", IX,H,L,D,E| g}
*

UPDATE_INFLIGHT_ALIEN_YADD:
	move.b	(Speed,a2),d0   | read INFLIGHT_ALIEN.Speed
    and.b  #0x03,d0
	addq.b	#1,d0         | now A is between 1 and 4.
	move.b	d0,d1

    move.b	(PivotYValueAdd,a2),d5          | read INFLIGHT_ALIEN.PivotYValueAdd in h
    move.b	(PivotYValueAdd+1,a2),d6		| in l
    move.b	(PivotYValueAdd+2,a2),d3
    move.b	(PivotYValueAdd+3,a2),d4
10:
	move.b	d6,d0  

* Part 1 - do H
	move.b	d5,d2                 | preserve H in C
	add.b	d0,d0
	bcc.b	0f

    subq.b	#1,d5
0:
    add.b	d0,d3
	move.b	d0,d3
    clr		d0
    addx.b	d5,d0

* I *think* this is to ensure that the signed byte in H never loses its sign.
* If it's positive it'll stay positive. If it's negative, it'll stay negative.
    cmp.b	#0x80,d0
	bne.b	1f
	move.b	d2,d0
1:
    move.b	d0,d5

* Part 2 - now do L
	move.b	d6,d2        | preserve L in C
	neg.b	d0
    add.b	d0,d0
	bcc.b	2f

    subq.b	#1,d6
2:
	add.b	d0,d4
	clr		d0
	addx.b	d6,d0
    cmp.b	#0x80,d0
	bne.b	3f
	move.b	d2,d0
3:
	move.b	d0,d6     | restore L from C
    dbf		D1,10b

    move.b	d5,(PivotYValueAdd,a2)          | stpre INFLIGHT_ALIEN.PivotYValueAdd
    move.b	d6,(PivotYValueAdd+1,a2)
    move.b	d3,(PivotYValueAdd+2,a2)
    move.b	d4,(PivotYValueAdd+3,a2)

	rts


*
* Calculate the animation frame that makes an attacking alien "look" directly at the player. 
* 
* Expects:
* IX = pointer to INFLIGHT_ALIEN structure with valid X and Y fields.
*
* Returns:
*  INFLIGHT_ALIEN.AnimationFrame is updated
*

CALCULATE_INFLIGHT_ALIEN_LOOKAT_ANIM_FRAME:
11B0: 3E F0         ld   a,0xF0               |  
11B2: DD 96 03      sub  (ix+0x03)            | subtract from INFLIGHT_ALIEN.X
11B5: 57            ld   d,a
11B6: 3A 02 42      ld   a,(0x4202)           | read PLAYER_Y 
11B9: DD 96 04      sub  (ix+0x04)            | subtract from INFLIGHT_ALIEN.Y 
11BC: 38 07         jr   c,0x11C5             
11BE: CD D0 11      call 0x11D0
11C1: DD 77 05      ld   (ix+0x05),a          | set INFLIGHT_ALIEN.AnimationFrame          
11C4: C9            rts

11C5: ED 44         neg.b   d0
11C7: CD D0 11      call 0x11D0
11CA: ED 44         neg.b   d0
11CC: DD 77 05      ld   (ix+0x05),a          | set INFLIGHT_ALIEN.AnimationFrame
11CF: C9            rts


	jbsr	CALCULATE_TANGENT
11D3: 79            ld   a,c
11D4: A7            and  a
11D5: F2 DA 11      jp   p,0x11DA
11D8: 3E 80         ld   a,0x80
11DA: 07            rlca
11DB: 07            rlca
11DC: 07            rlca
11DD: E6 07         and  0x07
11DF: C9            rts


*
* Try to spawn an enemy bullet. 
*
* Expects:
* IX = pointer to INFLIGHT_ALIEN struct
*
* Cheat:
* If you want to stop the aliens from firing, type the following into the MAME debugger:
* maincpu.mb@11E0 = C9 

TRY_SPAWN_ENEMY_BULLET:
11E0: 11 05 00      ld   de,0x0005            | sizeof(ENEMY_BULLET)
11E3: 21 60 42      ld   hl,0x4260            | load HL with address of ENEMY_BULLETS_START
11E6: 06 0E         ld   b,0x0E               | there are 14 elements in the ENEMY_BULLETS_START array
11E8: CB 46         bit  0,(hl)              | test if bullet is active
11EA: 28 04         jr   z,0x11F0             | if its not active, then we can use this slot to spawn an enemy bullet, goto 0x11F0
11EC: 19            add  hl,de               | otherwise bump HL to point to next enemy bullet in the array
11ED: 10 F9         djnz 0x11E8               | repeat until B==0
11EF: C9            rts


*
* Spawn an enemy bullet.
*
* Expects:
* IX = pointer to INFLIGHT_ALIEN structure. Identifies the alien firing the bullet.
* HL = pointer to ENEMY_BULLET structure. Contains info about the spawned bullet. 
*

SPAWN_ENEMY_BULLET:
11F0: 36 01         ld   (hl),0x01            | set ENEMY_BULLET.IsActive to 1 (true)
11F2: 23            inc  hl                  | bump HL to point to ENEMY_BULLET.X
11F3: DD 7E 03      ld   a,(ix+0x03)          | read INFLIGHT_ALIEN.X coordinate
11F6: 77            ld   (hl),a              | set X coordinate of bullet to be same as alien
11F7: 3E F0         ld   a,0xF0               | load A with -16 (decimal)
11F9: 96            sub  (hl)                | A = X coordinate of bullet + 16 
11FA: 57            ld   d,a
11FB: 23            inc  hl
11FC: 23            inc  hl                  | bump HL to point to ENEMY_BULLET.YH
11FD: DD 7E 04      ld   a,(ix+0x04)          | read INFLIGHT_ALIEN.Y  coordinate
1200: 77            ld   (hl),a              | set Y coordinate of bullet to be same as alien
1201: 23            inc  hl                  | bump HL to point to ENEMY_BULLET.YDelta
1202: 3A 02 42      ld   a,(0x4202)           | read PLAYER_Y   
1205: DD 96 04      sub  (ix+0x04)            | subtract from INFLIGHT_ALIEN.Y  coordinate       
1208: 38 05         jr   c,0x120F             | 
120A: CD 18 12      call 0x1218               | call COMPUTE_ENEMY_BULLET_DELTA
120D: 77            ld   (hl),a              | set ENEMY_BULLET.YDelta 
120E: C9            rts


120F: ED 44         neg.b   d0                      | A = Math.Abs(A)
1211: CD 18 12      call 0x1218               | call COMPUTE_ENEMY_BULLET_DELTA
1214: ED 44         neg.b   d0                      | make bullet fly to right 
1216: 77            ld   (hl),a              | set ENEMY_BULLET.YDelta 
1217: C9            rts


*
* Unlike the player's bullet, enemy bullets don't always fly in a straight line. 
*

COMPUTE_ENEMY_BULLET_DELTA:
1218: CD 48 00      call 0x0048               | call CALCULATE_TANGENT
121B: CD 3C 00      call 0x003C               | call GENERATE_RANDOM_NUMBER
121E: E6 1F         and  0x1F                 | clamp number to 0..31 decimal
1220: 81            add  a,c
1221: C6 06         add  a,0x06
1223: F0            rts  p
1224: 3E 7F         ld   a,0x7F
1226: C9            rts




HANDLE_INFLIGHT_ALIEN_TO_PLAYER_BULLET_COLLISION_DETECTION:
1227: 3A 08 42      ld   a,(0x4208)           | read HAS_PLAYER_BULLET_BEEN_FIRED flag
122A: 0F            rrca                     | move flag into carry
122B: D0            rts  nc                  | return if player is not shooting
122C: DD 21 D0 42   ld   ix,0x42D0            | pointer to INFLIGHT_ALIENS_START
1230: 11 20 00      ld   de,0x0020            | sizeof(INFLIGHT_ALIEN)
1233: 06 07         ld   b,0x07               | length of INFLIGHT_ALIENS array
1235: D9            exx
1236: CD 3F 12      call 0x123F               | call TEST_IF_PLAYER_BULLET_HIT_INFLIGHT_ALIEN   
1239: D9            exx
123A: DD 19         add  ix,de               | bump IX to point to next INFLIGHT_ALIEN
123C: 10 F7         djnz 0x1235
123E: C9            rts




*
* Player bullet to attacking alien collision detection.
*
* IX = pointer to INFLIGHT_ALIEN structure
*

TEST_IF_PLAYER_BULLET_HIT_INFLIGHT_ALIEN:
123F: DD CB 00 46   bit  0,(ix+0x00)          | Test INFLIGHT_ALIEN.IsActive flag
1243: C8            rts  z                   | return if not set
1244: 2A 09 42      ld   hl,(0x4209)          | read PLAYER_BULLET_X and PLAYER_BULLET_Y 
1247: DD 7E 03      ld   a,(ix+0x03)          | read INFLIGHT_ALIEN.X
124A: 95            sub  l                   | subtract from value of PLAYER_BULLET_X 
124B: C6 02         add  a,0x02               
124D: FE 06         cp   0x06
124F: D0            rts  nc
1250: DD 7E 04      ld   a,(ix+0x04)          | read INFLIGHT_ALIEN.Y  
1253: 94            sub  h                   | subtract from value of PLAYER_BULLET_Y 
1254: C6 05         add  a,0x05
1256: FE 0C         cp   0x0C
1258: D0            rts  nc

* if we get here, the player bullet has hit an alien inflight.
1259: 3E 01         ld   a,0x01
125B: 32 0B 42      ld   (0x420B),a           | set IS_PLAYER_BULLET_DONE to 1.
125E: DD 36 00 00   ld   (ix+0x00),0x00        | set INFLIGHT_ALIEN.IsActive to 0.  
1262: DD 36 01 01   ld   (ix+0x01),0x01        | set INFLIGHT_ALIEN.IsDying to 1.
1266: DD 36 02 00   ld   (ix+0x02),0x00        | set INFLIGHT_ALIEN.StageOfLife to 0.
126A: 11 04 03      ld   de,0x0304            | command ID: UPDATE_PLAYER_SCORE_COMMAND, parameter: 4 

* We now need to identify what rank this alien is so we can add its points value to the player score.
126D: 01 50 03      ld   bc,0x0350            | B= count, C = index into ALIEN_SWARM_FLAGS array to compare against
1270: DD 7E 07      ld   a,(ix+0x07)          | load a with INFLIGHT_ALIEN.IndexInSwarm to find out what rank this alien is.
1273: B9            cp   c                   | compare A with 0x50 (80 decimal)  
1274: DA F2 08      jp   c,0x08F2             | if A<0x50 jump to QUEUE_COMMAND with command ID: UPDATE_PLAYER_SCORE_COMMAND 
1277: 1C            inc  e                   | increment parameter passed to command - giving a higher score value
1278: D6 10         sub  0x10                 | subtract 10 (16 decimal) to "go down" a rank
127A: 10 F7         djnz 0x1273               | repeat until B==0. Only flagships will go to B==0.

* If we get here, we've shot an attacking flagship. 
* First we activate a timer that prevents aliens from leaving the swarm for a while. This simulates the swarm being "stunned". 
* We then calculate how many of the flagships escorts have been killed so we can update the player score accordingly. 
* For max points, a flagship must have 2 escorts and the escorts must be killed before the flagship.
127C: 21 01 F0      ld   hl,0xF001
127F: 22 2B 42      ld   (0x422B),hl          | set IS_FLAGSHIP_HIT to 1, and ALIENS_IN_SHOCK_COUNTER to 0xF0 (240 decimal)                    
1282: 3A 2A 42      ld   a,(0x422A)           | read FLAGSHIP_ESCORT_COUNT 
1285: FE 02         cp   0x02                 | do we have 2 aliens escorting the flagship?
1287: CC 92 12      call z,0x1292             | yes, call ASSERT_BOTH_FLAGSHIP_ESCORTS_ARE_ALIVE
128A: 32 2D 42      ld   (0x422D),a           | set FLAGSHIP_SCORE_FACTOR. If 3, then you get full points for killing the flagship + escort.               
128D: 83            add  a,e
128E: 5F            ld   e,a                 | set command parameter
128F: C3 F2 08      jp   0x08F2               | QUEUE_COMMAND with command ID: UPDATE_PLAYER_SCORE_COMMAND

* We need to test if both the flagship's escorts are alive.
* If both are dead, then when this function returns, A will be set to 3. 
ASSERT_BOTH_FLAGSHIP_ESCORTS_ARE_ALIVE:
1292: DD CB 20 46   bit  0,(ix+0x20)          | test if first escort is alive   
1296: C0            rts  nz                  | return if alive
1297: DD CB 40 46   bit  0,(ix+0x40)          | test if second escort is alive   
129B: C0            rts  nz                  | return if alive

* both escorts have been killed (or the flagship didn't have 2 escorts to start with)
129C: 3C            inc  a                   | both 
129D: C9            rts


*
* Iterate through list of inflight aliens and test if they have hit the player.
*

HANDLE_PLAYER_TO_INFLIGHT_ALIEN_COLLISION_DETECTION:
129E: 3A 00 42      ld   a,(0x4200)           | read HAS_PLAYER_SPAWNED
12A1: 0F            rrca                     | move flag into carry
12A2: D0            rts  nc                  | return if carry not set
12A3: DD 21 D0 42   ld   ix,0x42D0            | pointer to INFLIGHT_ALIENS[1]
12A7: 11 20 00      ld   de,0x0020            | sizeof(INFLIGHT_ALIEN)
12AA: 06 07         ld   b,0x07               | 7 aliens to test collision with
12AC: D9            exx
12AD: CD B6 12      call 0x12B6               | call TEST_IF_INFLIGHT_ALIEN_HIT_PLAYER
12B0: D9            exx
12B1: DD 19         add  ix,de               | bump IX to point to next INFLIGHT_ALIEN in array
12B3: 10 F7         djnz 0x12AC               | repeat until B==0
12B5: C9            rts



*
* Check if a flying alien has hit the player's ship.
*
* If so:
* IS_PLAYER_HIT will be set to 1.
*
* Expects: 
* IX = pointer to INFLIGHT_ALIEN structure 
*

TEST_IF_INFLIGHT_ALIEN_HIT_PLAYER:
12B6: DD CB 00 46   bit  0,(ix+0x00)          | read INFLIGHT_ALIEN.IsActive flag
12BA: C8            rts  z                   | exit if alien isn't active

12BB: DD 7E 03      ld   a,(ix+0x03)          | read INFLIGHT_ALIEN.X
12BE: C6 21         add  a,0x21
12C0: D6 05         sub  0x05
12C2: 38 16         jr   c,0x12DA
12C4: D6 0C         sub  0x0C
12C6: D0            rts  nc                  | return if >=0x0C

12C7: 3A 02 42      ld   a,(0x4202)           | read PLAYER_Y 
12CA: DD 96 04      sub  (ix+0x04)            | subtract INFLIGHT_ALIEN.Y 
12CD: C6 0A         add  a,0x0A
12CF: FE 15         cp   0x15
12D1: D0            rts  nc                  | return if >=0x15

* kill player and alien
12D2: 3E 01         ld   a,0x01
12D4: 32 04 42      ld   (0x4204),a           | set IS_PLAYER_HIT flag. 
12D7: C3 5E 12      jp   0x125E               | and we need to kill the alien as well

12DA: 3A 02 42      ld   a,(0x4202)           | read PLAYER_Y 
12DD: DD 96 04      sub  (ix+0x04)            | subtract INFLIGHT_ALIEN.Y 
12E0: C6 07         add  a,0x07
12E2: FE 0F         cp   0x0F
12E4: D0            rts  nc                  | return if >=0x0f

* kill player and alien
12E5: 3E 01         ld   a,0x01
12E7: 32 04 42      ld   (0x4204),a           | set IS_PLAYER_HIT flag. 
12EA: C3 5E 12      jp   0x125E               | and we need to kill the alien as well



* 
*  Handles the player being hit by an INFLIGHT_ALIEN (see 0x12B6) or ENEMY_BULLET (see 0x0B8D).
* 

HANDLE_PLAYER_HIT:
12ED: 21 04 42      ld   hl,0x4204            | pointer to IS_PLAYER_HIT flag
12F0: CB 46         bit  0,(hl)              | test flag to see if player has been hit. 
12F2: C8            rts  z                   | bit is not set so player not hit, return

* OK, player's hit. 
12F3: 36 00         ld   (hl),0x00            | clear IS_PLAYER_HIT flag
12F5: 21 00 01      ld   hl,0x0100             
12F8: 22 00 42      ld   (0x4200),hl          | Clear HAS_PLAYER_SPAWNED and set IS_PLAYER_DYING flags

* Draw first frame of player exploding
12FB: 21 0A 04      ld   hl,0x040A
12FE: 22 05 42      ld   (0x4205),hl          | set PLAYER_EXPLOSION_COUNTER and PLAYER_EXPLOSION_ANIM_FRAME
1301: 11 05 02      ld   de,0x0205            | command: DISPLAY_PLAYER_COMMAND, parameter: 5 (invokes DRAW_PLAYER_SHIP_EXPLODING)
1304: CD F2 08      call 0x08F2               | call QUEUE_COMMAND

* reduce level of difficulty
1307: 3A 1A 42      ld   a,(0x421A)           | read DIFFICULTY_EXTRA_VALUE
130A: A7            and  a                   | test if its zero
130B: 28 01         jr   z,0x130E             | if zero, then - wait a second, why is it updating an already zero field? Should be: jr z, 0x1311     
130D: 3D            dec  a                   | reduce game difficulty slightly
130E: 32 1A 42      ld   (0x421A),a           | update DIFFICULTY_EXTRA_VALUE

* decrement number of player lives
1311: 21 1D 42      ld   hl,0x421D            | pointer to address of PLAYER_LIVES
1314: 35            dec  (hl)                | reduce number of lives
1315: 7E            ld   a,(hl)              | read number of lives
1316: FE 06         cp   0x06                 | compare to 6
1318: 38 02         jr   c,0x131C             | if < 6 then goto 0x131C
131A: 36 05         ld   (hl),0x05            | otherwise, clamp number of lives max to 5 (is this anti-hack code?)
131C: 3A 06 40      ld   a,(0x4006)           | read IS_GAME_IN_PLAY
131F: 0F            rrca                     | move flag into carry
1320: D0            rts  nc                  | return if game is not in play

* Make player BOOM! sound
1321: 3E 01         ld   a,0x01
1323: 32 03 68      ld   (0x6803),a           | make PLAYER HIT noise
1326: C9            rts




* Draws player explosion, stops player hit sound when done.

HANDLE_PLAYER_DYING:
1327: 3A 01 42      ld   a,(0x4201)           | read IS_PLAYER_DYING flag
132A: 0F            rrca                     | move flag into carry. If player is dying carry is set
132B: D0            rts  nc                  | return if player is not dying. 
* wait for explosion delay to count to zero
132C: 21 05 42      ld   hl,0x4205            | point HL to PLAYER_EXPLOSION_COUNTER
132F: 35            dec  (hl)                | decrement value
1330: C0            rts  nz                  | if counter hasn't hit 0, then explosion animation can continue, return.
1331: 36 0A         ld   (hl),0x0A            | otherwise reset PLAYER_EXPLOSION_COUNTER value to its default #0x0A (10 decimal)

* draw explosion animation
1333: 23            inc  hl                  | bump HL to point to PLAYER_EXPLOSION_ANIM_FRAME     
1334: 16 02         ld   d,0x02               | command 2: DISPLAY_PLAYER_COMMAND
1336: 5E            ld   e,(hl)              | read the animation frame value  
1337: CD F2 08      call 0x08F2               | call QUEUE_COMMAND
133A: 35            dec  (hl)                | decrement the animation frame value
133B: C0            rts  nz                  | if its not zero, the player dying animation hasn't finished, so return 
133C: AF            xor  a                   | Otherwise, the player explosion animation has reached its end, so....

* clear IS_PLAYER_DYING flag when animation done and stop player explosion sound
133D: 32 01 42      ld   (0x4201),a           | clear IS_PLAYER_DYING flag
1340: 32 03 68      ld   (0x6803),a           | clear !SOUND  player hit
1343: C9            rts



*
* Try to send a single alien to attack the player.
*
* If we have flagships in the swarm, then only purple and blue aliens can be sent to attack by this routine.
* If we have no flagships in the swarm, then red aliens can also be sent to attack. (See 0x13BD)
*
* Flagships and escorts are handled by HANDLE_FLAGSHIP_ATTACK.
*
*
* Cheat (of a sort):
* if you want to make this game very difficult, type the following into the MAME debugger: 
* maincpu.mb@1359 = 8
* maincpu.pb@421A = 7
* maincpu.pb@421B = 7
*

HANDLE_SINGLE_ALIEN_ATTACK:
1344: 3A 28 42      ld   a,(0x4228)           | read CAN_ALIEN_ATTACK flag
1347: 0F            rrca                     | move flag into carry
1348: D0            rts  nc                  | return if flag is not set
1349: AF            xor  a
134A: 32 28 42      ld   (0x4228),a           | reset flag
134D: 3A 20 42      ld   a,(0x4220)           | read HAVE_NO_ALIENS_IN_SWARM flag.
1350: 0F            rrca                     | move flag into carry
1351: D8            rts  c                   | return if no aliens are in the swarm.

* The difficulty level specifies how many aliens can be attacking the player at one time.
1352: 2A 1A 42      ld   hl,(0x421A)          | load H with DIFFICULTY_BASE_VALUE and L with DIFFICULTY_EXTRA_VALUE
1355: 7C            ld   a,h                 | 
1356: 85            add  a,l                 | add DIFFICULTY_EXTRA_VALUE to DIFFICULTY_BASE_VALUE 
1357: 1F            rra                      | divide by 2.
1358: FE 04         cp   0x04                 | is result < 4?
135A: 38 02         jr   c,0x135E             | yes, goto 0x135E.
135C: 3E 03         ld   a,0x03               | Clamp maximum number of INFLIGHT_ALIEN slots to scan to 3.
135E: 3C            inc  a                   | ensure that slots to scan is in range of 1..4

* Scan a specified number of slots (up to 4) in the INFLIGHT_ALIENS array, starting from the *last* slot and working back.
* Take the first slot that has clear IsActive and IsDying flags.
* A = number of slots to scan
135F: 47            ld   b,a                  | save number of slots to scan in B
1360: 21 91 43      ld   hl,0x4391             | point HL to last INFLIGHT_ALIEN.IsDying flag in INFLIGHT_ALIENS array
1363: 11 E1 FF      ld   de,0xFFE1             | load DE with -31, which is sizeof(INFLIGHT_ALIEN)-1
1366: 7E            ld   a,(hl)               | read INFLIGHT_ALIEN.IsDying flag
1367: 2B            dec  hl                   | bump HL to point to INFLIGHT_ALIEN.IsActive flag  
1368: B6            or   (hl)                 | combine flags. We want A to be 0, to indicate INFLIGHT_ALIEN slot is not in use. 
1369: 28 04         jr   z,0x136F              | OK, we have an unused slot, goto 0x136F
136B: 19            add  hl,de
136C: 10 F8         djnz 0x1366                | repeat until we've scanned all the slots we're allowed to
136E: C9            rts

* If we get here, HL points to an unused INFLIGHT_ALIEN record that will be repurposed for our soon-to-be attacking alien. 
* HL = pointer to unused INFLIGHT_ALIEN structure
136F: E5            push hl
1370: DD E1         pop  ix                   | IX = HL
1372: 3A 15 42      ld   a,(0x4215)            | read ALIENS_ATTACK_FROM_RIGHT_FLANK flag
1375: DD 77 06      ld   (ix+0x06),a           | update INFLIGHT_ALIEN.ArcClockwise flag
1378: A7            and  a                    | test if flag is set  
1379: 20 30         jr   nz,0x13AB             | if flag is set, goto FIND_FIRST_OCCUPIED_SWARM_COLUMN_START_FROM_RIGHT

* If we get here, we want an alien to break off from the left flank of the swarm.
* We now need to find an alien in the swarm able to attack the player. 
* Find first occupied column of aliens starting from the leftmost column.
FIND_FIRST_OCCUPIED_SWARM_COLUMN_START_FROM_LEFT:
137B: 21 FC 41      ld   hl,0x41FC             | address of flag for leftmost alien in ALIEN_IN_COLUMN_FLAGS 
137E: 01 0A 00      ld   bc,0x000A             | 10 aliens maximum on a row         
1381: 3E 01         ld   a,0x01                | we are scanning for a value of 1, meaning "column occupied"
1383: ED B9         cpdr                      | scan 0x41FC down to 0x41F3 for value #0x01. 
1385: C0            rts  nz                   | if we have no aliens in the swarm (all flags are 0) - return
1386: E0            rts  po                   | if BC has overflowed, return

1387: 1E 3F         ld   e,0x3F
1389: 2C            inc  l                    | adjust L because CPDR will have decremented it one time too many 

* HL now points to an entry in ALIEN_IN_COLUMN_FLAGS where we have an alien present.
* If we have flagships in the swarm, then only purple and blue aliens can be sent to attack by this routine.
* If we have no flagships in the swarm, then any remaining red aliens are also considered. (See 0x13BD)
TRY_FIND_ALIEN_TO_ATTACK:
138A: 3A EF 41      ld   a,(0x41EF)            | load a with HAVE_ALIENS_IN_TOP_ROW flag
138D: 0F            rrca                      | move flag into carry
138E: 30 2D         jr   nc,0x13BD             | if no flagships in swarm, goto INIT_SCAN_FROM_RED_ALIEN_ROW

* we have flagships, so send a purple or blue alien.
INIT_SCAN_FROM_PURPLE_ALIEN_ROW:
1390: 16 04         ld   d,0x04                | number of rows to scan (1 purple + 3 blue)
1392: 26 41         ld   h,0x41                | MSB of ALIEN_SWARM_FLAGS address 
1394: 7D            ld   a,l                  
1395: E6 0F         and  0x0F                  | A = index of column containing alien 
1397: C6 50         add  a,0x50                | effectively: HL = 0x4150 + (L & 0x0f)       
1399: 6F            ld   l,a                  | HL now points to slot for purple alien in ALIEN_SWARM_FLAGS

* HL now points to a slot in ALIEN_SWARM_FLAGS. D is a row counter.
* If the slot is occupied, the occupying alien will be sent to attack the player.
* If the slot is unoccupied, we'll scan the same column in the rows beneath until we find an occupied slot or we've done D rows.  
* If we find an alien, we'll send it to attack the player.
SCAN_SPECIFIC_COLUMN_FOR_D_ROWS:
139A: 42            ld   b,d                  | set B to number of rows to scan
139B: CB 46         bit  0,(hl)               | test for presence of alien in ALIEN_SWARM_FLAGS              
139D: 20 2F         jr   nz,0x13CE             | if there's an alien present, its "volunteered" to attack, goto 0x13CE 
139F: 7D            ld   a,l                  
13A0: D6 10         sub  0x10                  | sizeof(row in ALIEN_SWARM_FLAGS)
13A2: 6F            ld   l,a                  | bump HL to point to alien in row beneath
13A3: 10 F6         djnz 0x139B                | repeat until B==0

* OK, We've scanned the entire column and not found an alien. This means that ALIEN_IN_COLUMN_FLAGS isn't truthful,
* and we need to resort to desperate measures. 
* 
* ** I've not seen this block of code called, and I think it might be legacy or debug **  
*
* Bump HL to point to the purple alien in the column to the right of the one we just scanned. We'll scan that column.  
13A5: 83            add  a,e                  | add 0x3F to A.  
13A6: 6F            ld   l,a                  | Now HL points to purple alien slot
13A7: 0D            dec  c                    | decrement count of columns remaining that we *can* scan
13A8: 20 F0         jr   nz,0x139A             | if non-zero, repeat the column scan
13AA: C9            rts


* If we get here, we want an alien to break off from the right flank of the swarm.
* We now need to find an alien in the swarm willing to attack the player. 
* Find first occupied column of aliens starting from the rightmost column.
FIND_FIRST_OCCUPIED_SWARM_COLUMN_START_FROM_RIGHT:
13AB: 21 F3 41      ld   hl,0x41F3            | address of flag for rightmost column of aliens 
13AE: 01 0A 00      ld   bc,0x000A            | 10 aliens maximum on a row  
13B1: 3E 01         ld   a,0x01               | we are scanning for a value of 1, meaning "column occupied"
13B3: ED B1         cpir                     | scan 0x41F3 up to 0x41F3 for value #0x01. 
13B5: C0            rts  nz                  | if we have no aliens in the swarm - return
13B6: E0            rts  po                  | if BC has overflowed, return

* we've found an occupied column
13B7: 1E 41         ld   e,0x41
13B9: 2D            dec  l
13BA: C3 8A 13      jp   0x138A               | jump to TRY_FIND_ALIEN_TO_ATTACK:


* Called when no flagships present in flagship row. This means we can send any alien, including red, into the attack.
INIT_SCAN_FROM_RED_ALIEN_ROW:
13BD: 16 05         ld   d,0x05                | number of rows of aliens to scan 
13BF: 26 41         ld   h,0x41                | MSB of ALIEN_SWARM_FLAGS address 
13C1: 7D            ld   a,l
13C2: E6 0F         and  0x0F                  | A = index of column   
13C4: C6 60         add  a,0x60                | effectively: HL = 0x4150 + (L & 0x0f)
13C6: 6F            ld   l,a                  | HL now points to slot for red alien in ALIEN_SWARM_FLAGS
13C7: 7B            ld   a,e
13C8: C6 10         add  a,0x10
13CA: 5F            ld   e,a
13CB: C3 9A 13      jp   0x139A                | jump to SCAN_SPECIFIC_COLUMN_FOR_D_ROWS


*
* Expects:
* HL = pointer to occupied entry in ALIEN_SWARM_FLAGS
* IX = pointer to vacant INFLIGHT_ALIEN structure
*

13CE: 36 00         ld   (hl),0x00
13D0: DD 75 07      ld   (ix+0x07),l          | set INFLIGHT_ALIEN.IndexInSwarm
13D3: DD 36 00 01   ld   (ix+0x00),0x01        | set INFLIGHT_ALIEN.IsActive 
13D7: DD 36 02 00   ld   (ix+0x02),0x00        | set INFLIGHT_ALIEN.StageOfLife
13DB: 16 01         ld   d,0x01               | command: DELETE_ALIEN_COMMAND
13DD: 5D            ld   e,l                 | parameter: index of alien in swarm
13DE: C3 F2 08      jp   0x08F2               | jump to QUEUE COMMAND



*
* Sets the flank that aliens, including flagships, will attack from.
* 
* If you replace 0x13F3-13F5, 0x13FF-1401, 0x1408-140A with zero (NOP), you can then tinker with the flag in 0x4215 and control 
* what side the aliens attack from.
*

SET_ALIEN_ATTACK_FLANK:
13E1: 2A 0E 42      ld   hl,(0x420E)          | read SWARM_SCROLL_VALUE
13E4: ED 5B 10 42   ld   de,(0x4210)          | read SWARM_SCROLL_MAX_EXTENTS
13E8: CB 7C         bit  7,h                 
13EA: 28 0B         jr   z,0x13F7

13EC: 7D            ld   a,l
13ED: 92            sub  d
13EE: FE 1C         cp   0x1C
13F0: 30 11         jr   nc,0x1403            | if A>0x1C, attack from a random flank
13F2: AF            xor  a
13F3: 32 15 42      ld   (0x4215),a           | reset ALIENS_ATTACK_FROM_RIGHT_FLANK flag. Aliens will now attack from left side of swarm.
13F6: C9            rts

13F7: 7B            ld   a,e
13F8: 95            sub  l
13F9: FE 1C         cp   0x1C
13FB: 30 06         jr   nc,0x1403            | if A>0x1C, attack from a random flank
13FD: 3E 01         ld   a,0x01
13FF: 32 15 42      ld   (0x4215),a           | set ALIENS_ATTACK_FROM_RIGHT_FLANK flag. Aliens will now attack from right side of swarm.
1402: C9            rts

* Attack from left or right flank, chosen at random
1403: CD 3C 00      call 0x003C               | call GENERATE_RANDOM_NUMBER
1406: E6 01         and  0x01                 | mask in bit 0, so A is either 0 or 1
1408: 32 15 42      ld   (0x4215),a           | set/reset ALIENS_ATTACK_FROM_RIGHT_FLANK flag. 
140B: C9            rts




*
* This routine checks if a flagship and escort can break from a given flank to attack the player.
* 
* The flank is determined by the ALIENS_ATTACK_FROM_RIGHT_FLANK flag (0x4215).
*
* If a flagship exists on the specified flank, send the flagship to attack.  
* If there's red aliens in *close proximity* to the flagship, send a maximum of 2 as an escort.
*
* If there are no flagships on the specified flank, try to send a single red alien from the flank instead.
*
* Notes:
* A flagship can attack when:
*     HAVE_NO_ALIENS_IN_SWARM is set to 0 AND
*     HAS_PLAYER_SPAWNED is set to 1 AND
*     The CAN_FLAGSHIP_OR_RED_ALIENS_ATTACK is set to 1 AND
*     INFLIGHT_ALIENS[1] is available for use
*
*
* Cheat:
* If you type into the MAME debugger: 
* maincpu.mb@140C=C9
*
* The flagships stop attacking you completely.
*

HANDLE_FLAGSHIP_ATTACK:
140C: 3A 20 42      ld   a,(0x4220)           | read HAVE_NO_ALIENS_IN_SWARM flag           
140F: 0F            rrca                     | move flag into carry
1410: D8            rts  c                   | return if no aliens in the swarm.
1411: 3A 00 42      ld   a,(0x4200)           | read HAS_PLAYER_SPAWNED
1414: 0F            rrca                     | move flag into carry
1415: D0            rts  nc                  | return if player has not spawned.
1416: 3A 29 42      ld   a,(0x4229)           | read CAN_FLAGSHIP_OR_RED_ALIENS_ATTACK
1419: 0F            rrca                     | move flag into carry
141A: D0            rts  nc                  | return if flag is not set
141B: AF            xor  a
141C: 32 29 42      ld   (0x4229),a           | reset CAN_FLAGSHIP_OR_RED_ALIENS_ATTACK flag

* Test if the slot in INFLIGHT_ALIENS reserved for the flagship is in use. If so - do nothing.
141F: 2A D0 42      ld   hl,(0x42D0)          | read from INFLIGHT_ALIENS[1] which is the 2nd array element
1422: 7C            ld   a,h                 | Load A with INFLIGHT_ALIEN.IsDying flag
1423: B5            or   l                   | OR with INFLIGHT_ALIEN.IsActive flag
1424: 0F            rrca                     | if alien is active or dying, carry will be set
1425: D8            rts  c                   | return if alien is active or dying - the slot for the flagship is in use.

* from what side should the flagship/red aliens attack from?
1426: 3A 15 42      ld   a,(0x4215)           | read ALIENS_ATTACK_FROM_RIGHT_FLANK flag
1429: 4F            ld   c,a                 | C is used to set INFLIGHT_ALIEN.ArcClockwise flag @ 0x1466
142A: 0F            rrca                     | move flag into carry
142B: DA BE 14      jp   c,0x14BE             | if attacking from right flank, jump to TRY_FIND_FLAGSHIP_OR_RED_ALIEN_TO_ATTACK_FROM_RIGHT_FLANK


TRY_FIND_FLAGSHIP_OR_RED_ALIEN_TO_ATTACK_FROM_LEFT_FLANK:
142E: 21 79 41      ld   hl,0x4179            | load HL with pointer to leftmost flagship in ALIEN_SWARM_FLAGS
1431: 06 04         ld   b,0x04               | scan 4 slots max in the ALIEN_SWARM_FLAGS array to find a flagship
1433: CB 46         bit  0,(hl)              | test if a flagship is present
1435: 20 3B         jr   nz,0x1472            | if we have found a flagship, goto INIT_FLAGSHIP_ATTACK_FROM_LEFT_FLANK
1437: 2D            dec  l                   | move to next potential flagship
1438: 10 F9         djnz 0x1433               | repeat until B==0

* If we can't get a flagship, then we scan the red alien row from left to right to find a red alien to attack.
143A: 2E 6A         ld   l,0x6A               | load HL with pointer to leftmost red alien in ALIEN_SWARM_FLAGS
143C: 06 04         ld   b,0x04               | scan first 4 red aliens 
143E: CB 46         bit  0,(hl)              | test if an alien is present
1440: 20 04         jr   nz,0x1446            | if we have found a red alien, goto TRY_INIT_INFLIGHT_ALIEN
1442: 2D            dec  l                   | bump HL to point to slot of sibling alien
1443: 10 F9         djnz 0x143E               | repeat until B==0
1445: C9            rts

* 
* Scan the last 4 entries in the INFLIGHT_ALIENS array for an unused slot. 
* If all 4 slots at the end of the array are already in use, exit.
* Otherwise re-use the lastmost free slot for an attacking alien.
*
* Expects:
* HL = pointer to a bit flag in ALIEN_IN_SWARM_FLAGS
*

TRY_INIT_INFLIGHT_ALIEN:
1446: DD 21 90 43   ld   ix,0x4390            | address of very last INFLIGHT_ALIEN record in INFLIGHT_ALIENS array 
144A: 11 E0 FF      ld   de,0xFFE0            | -32 decimal, which is -sizeof(INFLIGHT_ALIEN)
144D: 06 04         ld   b,0x04               
144F: DD 7E 00      ld   a,(ix+0x00)          | load A with INFLIGHT_ALIEN.IsActive flag
1452: DD B6 01      or   (ix+0x01)            | OR A with INFLIGHT_ALIEN.IsDying flag
1455: 28 05         jr   z,0x145C             | if the slot is not used for an active or dying alien, goto INIT_INFLIGHT_ALIEN
1457: DD 19         add  ix,de               | subtract sizeof(INFLIGHT_ALIEN) from IX, to bump IX to previous INFLIGHT_ALIEN record
1459: 10 F4         djnz 0x144F
145B: C9            rts

*
* Remove an alien from the swarm, and create an inflight alien in its place.
* 
* Expects:
* C = direction alien will break away from swarm. 0 = left, 1 = right
* HL = pointer to entry in ALIEN_SWARM_FLAGS 
* IX = pointer to INFLIGHT_ALIEN struct of alien 
*

INIT_INFLIGHT_ALIEN:
145C: 36 00         ld   (hl),0x00            | clear flag in ALIEN_SWARM_FLAGS - effectively removing it from swarm            
145E: DD 36 00 01   ld   (ix+0x00),0x01        | set INFLIGHT_ALIEN.IsActive
1462: DD 36 02 00   ld   (ix+0x02),0x00        | reset INFLIGHT_ALIEN.StageOfLife
1466: DD 71 06      ld   (ix+0x06),c          | set INFLIGHT_ALIEN.ArcClockwise
1469: DD 75 07      ld   (ix+0x07),l          | set INFLIGHT_ALIEN.IndexInSwarm
146C: 16 01         ld   d,0x01               | command: DELETE_ALIEN_COMMAND
146E: 5D            ld   e,l                 | parameter: index of alien to delete from the swarm 
146F: C3 F2 08      jp   0x08F2               | jump to QUEUE_COMMAND


*
* Given a pointer to a flagship entry in the ALIEN_SWARM_FLAGS array, 
* scan for red aliens in close proximity to the flagship that can be used as an escort.
* Initialise INFLIGHT_ALIEN records for the flagship and any escort as well. 
*
* Expects:
* HL = pointer to entry in flagship row of ALIEN_SWARM_FLAGS
*

INIT_FLAGSHIP_ATTACK_FROM_LEFT_FLANK:
1472: DD 21 D0 42   ld   ix,0x42D0            | pointer to INFLIGHT_ALIENS_START+sizeof(INFLIGHT_ALIEN)
1476: CD 5C 14      call 0x145C               | call INIT_INFLIGHT_ALIEN to make flagship take flight and leave the swarm 
1479: 7D            ld   a,l
147A: D6 0F         sub  0x0F     
147C: 6F            ld   l,a                 | bump HL to point at red alien directly below and to right of flagship
147D: FD 21 F0 42   ld   iy,0x42F0            | pointer to INFLIGHT_ALIENS_START+(sizeof(INFLIGHT_ALIEN) * 2)
1481: 06 03         ld   b,0x03               | we're scanning 3 entries in red aliens row max             
1483: 0E 02         ld   c,0x02               | But we only want 2 red aliens as an escort.  
1485: CB 46         bit  0,(hl)              | test for presence of red alien
1487: C4 8E 14      call nz,0x148E            | if we have a red alien, try to create an inflight alien  
148A: 2D            dec  l                   | bump HL to point to slot of sibling alien 
148B: 10 F8         djnz 0x1485               | repeat until B==0
148D: C9            rts

* HL = pointer to entry in ALIEN_SWARM_FLAGS
148E: CD 9B 14      call 0x149B               | call TRY_INIT_ESCORT_INFLIGHT_ALIEN
1491: 11 20 00      ld   de,0x0020            | sizeof(INFLIGHT_ALIEN)
1494: FD 19         add  iy,de               | bump IY to point to next member of INFLIGHT_ALIENS array
1496: 0D            dec  c                   | reduce count of red aliens left to check for use as escort
1497: C0            rts  nz                  | return if we have all the escort we need
1498: 06 01         ld   b,0x01
149A: C9            rts


*
* Try to create an escort for a flagship. 
*
* Expects:
* HL = pointer to red alien in ALIEN_SWARM_FLAGS that could be escort
* IX = pointer to INFLIGHT_ALIEN structure (used for flagship)
* IY = pointer to INFLIGHT_ALIEN structure (will be used for escort) 
*
* If the INFLIGHT_ALIEN pointed to by IY is not occupied by an active or dying alien, then
* the record is re-used and marked as active. 
* Otherwise this routine exits.

TRY_INIT_ESCORT_INFLIGHT_ALIEN:
149B: FD CB 00 46   bit  0,(iy+0x00)          | test INFLIGHT_ALIEN.IsActive
149F: C0            rts  nz                  | return if flag is set
14A0: FD CB 01 46   bit  0,(iy+0x01)          | test INFLIGHT_ALIEN.IsDying
14A4: C0            rts  nz                  | return if flag is set

* OK, we can use the INFLIGHT_ALIEN slot at IY. Let's remove the alien from the swarm
* and create 
14A5: 36 00         ld   (hl),0x00            | clear flag in ALIEN_SWARM_FLAGS
14A7: FD 36 00 01   ld   (iy+0x00),0x01        | set INFLIGHT_ALIEN.IsActive
14AB: FD 36 02 00   ld   (iy+0x02),0x00        | reset INFLIGHT_ALIEN.StageOfLife
14AF: DD 7E 06      ld   a,(ix+0x06)          | read flagship's INFLIGHT_ALIEN.ArcClockwise
14B2: FD 77 06      ld   (iy+0x06),a          | set escort INFLIGHT_ALIEN.ArcClockwise so it breaks away in formation.
14B5: FD 75 07      ld   (iy+0x07),l          | set escort INFLIGHT_ALIEN.IndexInSwarm
14B8: 16 01         ld   d,0x01               | command: DELETE_ALIEN_COMMAND
14BA: 5D            ld   e,l                 | parameter: index of alien to delete from the swarm
14BB: C3 F2 08      jp   0x08F2               | jump to QUEUE_COMMAND


TRY_FIND_FLAGSHIP_OR_RED_ALIEN_TO_ATTACK_FROM_RIGHT_FLANK:
14BE: 21 76 41      ld   hl,0x4176            | load HL with pointer to rightmost flagship in ALIEN_SWARM_FLAGS
14C1: 06 04         ld   b,0x04               | scan max of 4 flagships in array
14C3: CB 46         bit  0,(hl)              | test if a flagship is present
14C5: 20 10         jr   nz,0x14D7            | if we have found a flagship, goto INIT_FLAGSHIP_ATTACK_FROM_RIGHT_FLANK
14C7: 2C            inc  l                   | otherwise try looking for a flagship to immediate left
14C8: 10 F9         djnz 0x14C3               | repeat until B==0

* If we can't find a single flagship, then we try the red alien row. 
14CA: 2E 65         ld   l,0x65               | load HL with pointer to rightmost red alien in ALIEN_SWARM_FLAGS array
14CC: 06 04         ld   b,0x04               | scan max of 4 slots in array 
14CE: CB 46         bit  0,(hl)              | test if red alien is present
14D0: C2 46 14      jp   nz,0x1446            | if we have found a red alien, goto 0x1446
14D3: 2C            inc  l                   | bump HL to point to slot of sibling alien
14D4: 10 F8         djnz 0x14CE               | repeat until B==0
14D6: C9            rts


* Near duplicate of INIT_FLAGSHIP_ATTACK_FROM_LEFT_FLANK @0x1472, except for the right flank. 
*
* Given a pointer to a flagship entry in the ALIEN_SWARM_FLAGS array, 
* scan for red aliens in close proximity to the flagship that can be used as an escort.
* Initialise INFLIGHT_ALIEN records for the flagship and any escort as well. 
*
* Expects:
* HL = pointer to flag in ALIEN_SWARM_FLAGS representing flagship
*

INIT_FLAGSHIP_ATTACK_FROM_RIGHT_FLANK:
14D7: DD 21 D0 42   ld   ix,0x42D0            | pointer to INFLIGHT_ALIENS_START+sizeof(INFLIGHT_ALIEN) 
14DB: CD 5C 14      call 0x145C               | Remove an alien from the swarm, and create an inflight alien in its place.
14DE: 7D            ld   a,l
14DF: D6 11         sub  0x11                 | bump HL to point at red alien directly below and to right of flagship
14E1: 6F            ld   l,a                 
14E2: FD 21 F0 42   ld   iy,0x42F0            | pointer to INFLIGHT_ALIENS_START+(sizeof(INFLIGHT_ALIEN) * 2)
14E6: 06 03         ld   b,0x03
14E8: 0E 02         ld   c,0x02
14EA: CB 46         bit  0,(hl)              | do we have a red alien?
14EC: C4 8E 14      call nz,0x148E
14EF: 2C            inc  l
14F0: 10 F8         djnz 0x14EA
14F2: C9            rts



*
* Increase game difficulty as the level goes on.
*

HANDLE_LEVEL_DIFFICULTY:
14F3: 3A 00 42      ld   a,(0x4200)           | read HAS_PLAYER_SPAWNED
14F6: 0F            rrca                     | move flag into carry
14F7: D0            rts  nc                  | return if player has not spawned
14F8: 3A 2B 42      ld   a,(0x422B)           | read IS_FLAGSHIP_HIT
14FB: 0F            rrca                     | move flag into carry
14FC: D8            rts  c                   | return if flagship has been hit

* wait until DIFFICULTY_COUNTER_1 counts down to zero.
14FD: 21 18 42      ld   hl,0x4218            | load HL with address of DIFFICULTY_COUNTER_1
1500: 35            dec  (hl)                | decrement counter
1501: C0            rts  nz
1502: 36 3C         ld   (hl),0x3C            | reset counter

* DIFFICULTY_COUNTER_1 has reached zero and reset. Decrement DIFFICULTY_COUNTER_2.
1504: 23            inc  hl                  | bump HL to DIFFICULTY_COUNTER_2
1505: 35            dec  (hl)                | decrement counter
1506: C0            rts  nz
1507: 36 14         ld   (hl),0x14            | reset counter 

* DIFFICULTY_COUNTER_2 has reached zero. Now up the difficulty level, if we can.
1509: 23            inc  hl                  | bump HL to 0x421A (DIFFICULTY_EXTRA_VALUE)
150A: 7E            ld   a,(hl)              | read DIFFICULTY_EXTRA_VALUE
150B: FE 07         cp   0x07                 | has it reached its maximum value of 7?
150D: C8            rts  z                   | return if so
150E: 30 02         jr   nc,0x1512            | if A >= 7 , goto 0x1512

1510: 34            inc  (hl)                | increment DIFFICULTY_EXTRA_VALUE  
1511: C9            rts

1512: 36 07         ld   (hl),0x07            | clamp DIFFICULTY_EXTRA_VALUE to 7
1514: C9            rts


*
* Check if an alien can attack the player.
* For flagships, see 0x15C3 
*

CHECK_IF_ALIEN_CAN_ATTACK:
1515: 3A 00 42      ld   a,(0x4200)           | read HAS_PLAYER_SPAWNED
1518: 0F            rrca                     | move flag into carry
1519: D0            rts  nc                  | return if player has not spawned
151A: 3A 20 42      ld   a,(0x4220)           | read HAVE_NO_ALIENS_IN_SWARM flag
151D: 0F            rrca                     | move flag into carry
151E: D8            rts  c                   | return if we don't have any aliens in the swarm
151F: 3A 2B 42      ld   a,(0x422B)           | read IS_FLAGSHIP_HIT
1522: 0F            rrca                     | move flag into carry
1523: D8            rts  c                   | return if the flagship has been hit

* Use DIFFICULTY_EXTRA_VALUE and DIFFICULTY_BASE_VALUE to calculate how many secondary counters in the ALIEN_ATTACK_COUNTERS array
* we can decrement. The more counters = the higher probability one of them will count down to zero = higher probability an alien attacks.
1524: 2A 1A 42      ld   hl,(0x421A)          | load H with DIFFICULTY_BASE_VALUE and L with DIFFICULTY_EXTRA_VALUE
1527: 7C            ld   a,h                 | A = DIFFICULTY_BASE_VALUE value
1528: FE 02         cp   0x02
152A: 30 01         jr   nc,0x152D            | if DIFFICULTY_BASE_VALUE >=2, goto 0x152D
152C: AF            xor  a
152D: 85            add  a,l                 | Add DIFFICULTY_EXTRA_VALUE to DIFFICULTY_BASE_VALUE 
152E: E6 0F         and  0x0F                 | Ensure value is between 0 and 15
1530: 3C            inc  a                   | Add 1 to ensure it's between 1..16 
1531: 47            ld   b,a                 | B now contains number of counters to decrement

* Decrement ALIEN_ATTACK_MASTER_COUNTER. When it hits zero, we can decrement secondary counters in the ALIEN_ATTACK_MASTER_COUNTERS array.
1532: 21 4A 42      ld   hl,0x424A            | load HL with address of ALIEN_ATTACK_MASTER_COUNTER
1535: 11 E3 15      ld   de,0x15E3            | load DE with address of ALIEN_ATTACK_COUNTER_DEFAULT_VALUES
1538: 35            dec  (hl)                | decrement ALIEN_ATTACK_MASTER_COUNTER 
1539: 28 05         jr   z,0x1540             | if its hit zero, goto 0x1540 to decrement [B] counters 
153B: AF            xor  a
153C: 32 28 42      ld   (0x4228),a           | reset CAN_ALIEN_ATTACK flag. No alien will attack.
153F: C9            rts

* When we get here, ALIEN_ATTACK_MASTER_COUNTER is zero. 
* B specifies how many secondary counters in the ALIEN_ATTACK_COUNTERS array we can decrement. (Max value of 16)
* DE points to a default value to reset the ALIEN_ATTACK_MASTER_COUNTER back to. 
1540: 0E 00         ld   c,0x00
1542: 1A            ld   a,(de)              | read default value from table @ 0x15E3      
1543: 77            ld   (hl),a              | Reset ALIEN_ATTACK_MASTER_COUNTER to its default value

* Decrement B counters in the ALIEN_ATTACK_COUNTERS array. 
* If any of the counters hit zero, reset the counter to its default value and set the CAN_ALIEN_ATTACK flag to 1.
1544: 23            inc  hl                  | bump HL to next secondary counter 
1545: 13            inc  de                  | bump DE to address containing default value to reset secondary counter to when zero 
1546: 35            dec  (hl)                | decrement secondary counter  
1547: CC DF 15      call z,0x15DF             | if the secondary counter reaches zero, reset the counter and increment C. Alien will attack!
154A: 10 F8         djnz 0x1544               | repeat until B==0

* if C is set to a nonzero value then that means that a secondary counter has reached zero. Its time for an alien to attack. 
154C: 79            ld   a,c
154D: A7            and  a                   | test if A is zero 
154E: C8            rts  z                   | exit if so
154F: 3E 01         ld   a,0x01 
1551: 32 28 42      ld   (0x4228),a           | set CAN_ALIEN_ATTACK flag. Alien will break off from the swarm
1554: C9            rts



*
* This routine is responsible for determining when flagships can attack.
*
*

UPDATE_ATTACK_COUNTERS:
1555: 3A 00 42      ld   a,(0x4200)           | read HAS_PLAYER_SPAWNED
1558: 0F            rrca                     | move flag into carry
1559: D0            rts  nc                  | return if player has not spawned
155A: 3A EF 41      ld   a,(0x41EF)           | read HAVE_ALIENS_IN_TOP_ROW 
155D: 0F            rrca                     | move flag into carry
155E: D0            rts  nc                  | return if we have no flagships
155F: 3A 2B 42      ld   a,(0x422B)           | read IS_FLAGSHIP_HIT 
1562: 0F            rrca                     | move flag into carry
1563: D8            rts  c                   | return if a flagship has been hit
1564: 3A 06 40      ld   a,(0x4006)           | read IS_GAME_IN_PLAY
1567: 0F            rrca                     | move flag into carry
1568: 30 3D         jr   nc,0x15A7            | if game is not in play, goto 0x15A7      

* wait until FLAGSHIP_ATTACK_MASTER_COUNTER_1 counts down to zero.
156A: 21 45 42      ld   hl,0x4245            | load HL with address of FLAGSHIP_ATTACK_MASTER_COUNTER_1
156D: 35            dec  (hl)                | decrement counter
156E: C0            rts  nz                  | exit if counter is not zero
156F: 36 3C         ld   (hl),0x3C            | reset counter

* if we have no blue or purple aliens, we don't need to bother with the FLAGSHIP_ATTACK_MASTER_COUNTER_2 countdown. 
1571: 3A 21 42      ld   a,(0x4221)           | read HAVE_NO_BLUE_OR_PURPLE_ALIENS 
1574: 0F            rrca                     | move flag into carry
1575: 38 2C         jr   c,0x15A3             | if there's no blue or purple aliens left, goto 0x15A3

* otherwise, wait until FLAGSHIP_ATTACK_MASTER_COUNTER_2 counts down to 0.
1577: 23            inc  hl                  | bump HL to FLAGSHIP_ATTACK_MASTER_COUNTER_2
1578: 35            dec  (hl)                | decrement counter
1579: C0            rts  nz                  | return if its not counteed down to zero.
157A: 34            inc  (hl)                | set FLAGSHIP_ATTACK_MASTER_COUNTER_2 to 1

* count how many "extra" flagships we have carried over from previous waves (maximum of 2)
157B: 2A 77 41      ld   hl,(0x4177)          | point to usually empty flagship entry in ALIEN_SWARM_FLAGS. 
157E: 7C            ld   a,h                 
157F: 85            add  a,l                 | A now = number of *extra* flagships we have                 
1580: E6 03         and  0x03                 | ensure that number is between 0..3. (it should be between 0..2 anyway)
1582: 4F            ld   c,a                 | save count of extra flagships in C

* use difficulty settings and count of extra flagships to compute countdown before flagship attack
1583: 2A 1A 42      ld   hl,(0x421A)          | load H with DIFFICULTY_BASE_VALUE and L with DIFFICULTY_EXTRA_VALUE
1586: 7C            ld   a,h
1587: 85            add  a,l                 | Add DIFFICULTY_BASE_VALUE to DIFFICULTY_EXTRA_VALUE
1588: C8            rts  z                   | exit if both DIFFICULTY_BASE_VALUE and DIFFICULTY_EXTRA_VALUE are 0

1589: 0F            rrca                     | divide A..                     
158A: 0F            rrca                     | by 4
158B: E6 03         and  0x03                 | clamp A to 3 maximum.
158D: 2F            cpl                      | A = 255-A.
158E: C6 0A         add  a,0x0A               | ensure that A is between 0x06 and 0x09
1590: 91            sub  c                   | subtract count of extra flagships
1591: 32 46 42      ld   (0x4246),a           | set FLAGSHIP_ATTACK_MASTER_COUNTER_2

* set timer for when flagship will definitely attack.
1594: 07            rlca
1595: 07            rlca
1596: 32 2F 42      ld   (0x422F),a           | set FLAGSHIP_ATTACK_SECONDARY_COUNTER

1599: 07            rlca
159A: 32 4A 42      ld   (0x424A),a           | set ALIEN_ATTACK_MASTER_COUNTER

* enable timer for flagship to attack.
159D: 3E 01         ld   a,0x01
159F: 32 2E 42      ld   (0x422E),a           | set ENABLE_FLAGSHIP_ATTACK_SECONDARY_COUNTER
15A2: C9            rts

15A3: 3E 02         ld   a,0x02
15A5: 18 ED         jr   0x1594


* Called when game is not in play
15A7: 21 45 42      ld   hl,0x4245            | load HL with address of FLAGSHIP_ATTACK_MASTER_COUNTER_1
15AA: 35            dec  (hl)               
15AB: C0            rts  nz
15AC: 36 3C         ld   (hl),0x3C 
15AE: 23            inc  hl                  | load HL with address of FLAGSHIP_ATTACK_MASTER_COUNTER_2
15AF: 35            dec  (hl)
15B0: C0            rts  nz
15B1: 36 05         ld   (hl),0x05

15B3: 3E 5A         ld   a,0x5A
15B5: 32 2F 42      ld   (0x422F),a           | set FLAGSHIP_ATTACK_SECONDARY_COUNTER

15B8: 3E 2D         ld   a,0x2D
15BA: 32 4A 42      ld   (0x424A),a           | set ALIEN_ATTACK_MASTER_COUNTER

15BD: 3E 01         ld   a,0x01
15BF: 32 2E 42      ld   (0x422E),a           | set ENABLE_FLAGSHIP_ATTACK_SECONDARY_COUNTER
15C2: C9            rts


*
* Determines if a flagship can be permitted to attack.
*
* If so, CAN_FLAGSHIP_OR_RED_ALIENS_ATTACK is set to 1.
*


CHECK_IF_FLAGSHIP_CAN_ATTACK:
15C3: 21 2E 42      ld   hl,0x422E            | read ENABLE_FLAGSHIP_ATTACK_SECONDARY_COUNTER
15C6: CB 46         bit  0,(hl)              | test flag
15C8: C8            rts  z                   | return if not allowed to count down

* wait until FLAGSHIP_ATTACK_SECONDARY_COUNTER counts down to zero.
15C9: 23            inc  hl                  | bump HL to FLAGSHIP_ATTACK_SECONDARY_COUNTER
15CA: 35            dec  (hl)                | decrement counter
15CB: C0            rts  nz                  | return if counter hasn't reached zero

15CC: 2B            dec  hl                  | bump HL to ENABLE_FLAGSHIP_ATTACK_SECONDARY_COUNTER flag 
15CD: 36 00         ld   (hl),0x00            | reset flag
15CF: 3A 00 42      ld   a,(0x4200)           | read HAS_PLAYER_SPAWNED
15D2: 0F            rrca                     | move flag into carry
15D3: D0            rts  nc                  | return if player has not spawned

* check if we have any flagship
15D4: 3A EF 41      ld   a,(0x41EF)           | read HAVE_ALIENS_IN_TOP_ROW flag
15D7: 0F            rrca                     | move flag bit into carry
15D8: D0            rts  nc                  | return if no flagships

* yes, we have flagships, set CAN_FLAGSHIP_OR_RED_ALIENS_ATTACK flag
15D9: 3E 01         ld   a,0x01
15DB: 32 29 42      ld   (0x4229),a           | set CAN_FLAGSHIP_OR_RED_ALIENS_ATTACK
15DE: C9            rts


* A= *DE|
* *HL = A|
* C++
15DF: 1A            ld   a,(de)
15E0: 77            ld   (hl),a
15E1: 0C            inc  c
15E2: C9            rts


* Default values for the corresponding entries in the ALIEN_ATTACK_COUNTERS array.
* e.g. 0x424A's default value is 5, 0x424B's default value is 0x2F, 0x424C's default is 0x43...
* When any counter hits zero, it is reset to its default value.
ALIEN_ATTACK_COUNTER_DEFAULT_VALUES: 
15E3:  05 2F 43 77 71 6D 67 65 4F 49 43 3D 3B 35 2B 29


*
* This routine calculates how far away from the player inflight aliens can be before they can start shooting at you.
* 
* The minimum shooting distance increases as more aliens are killed, making the aliens shoot more often.
*  
* See also: 0x0E54

HANDLE_CALC_INFLIGHT_ALIEN_SHOOTING_DISTANCE:
15F4: 21 E8 41      ld   hl,0x41E8            | load HL with address of HAVE_ALIENS_IN_ROW_FLAGS
15F7: 06 04         ld   b,0x04               | we're testing potentially 4 pairs of rows.
15F9: 3A 1B 42      ld   a,(0x421B)           | read DIFFICULTY_BASE_VALUE
15FC: A7            and  a                   | test if zero
15FD: 20 16         jr   nz,0x1615            | if non-zero, which it always is, goto 0x1615

* These two lines of code appear never to be called. This must be for an EASY difficulty level we've not seen.
15FF: 1E 01         ld   e,0x01               | multiplier = 1
1601: 16 84         ld   d,0x84               | exact X coordinate  

1603: CB 46         bit  0,(hl)              | test for alien presence
1605: 20 09         jr   nz,0x1610            | if alien is present, goto 0x1610

1607: 23            inc  hl                  | bump HL to flag for next row 
1608: CB 46         bit  0,(hl)              | test flag 
160A: 20 04         jr   nz,0x1610            | if flag is set, goto 0x1610

160C: 23            inc  hl                  | bump to next entry in HAVE_ALIENS_IN_ROW_FLAGS
160D: 1C            inc  e                   | increment multiplier (see 0x0E54 for clarification on how its used)
160E: 10 F3         djnz 0x1603

1610: ED 53 13 42   ld   (0x4213),de          | set INFLIGHT_ALIEN_SHOOT_EXACT_X to D, INFLIGHT_ALIEN_SHOOT_RANGE_MUL to E
1614: C9            rts

1615: 1E 02         ld   e,0x02               | multiplier = 2
1617: 16 9D         ld   d,0x9D               | exact X coordinate 
1619: 18 E8         jr   0x1603

* TODO: I can't find anything calling this. Is this debug code left over?
161B: 1E 03         ld   e,0x03
161D: 16 B6         ld   d,0xB6
161F: 18 E2         jr   0x1603


*
* LEVEL_COMPLETE is set to 1 by this function when: 
* HAVE_NO_ALIENS_IN_SWARM is set to 1 AND
* HAVE_NO_INFLIGHT_OR_DYING_ALIENS is set to 1 AND
* LEVEL_COMPLETE is clear 
*

CHECK_IF_LEVEL_IS_COMPLETE:
1621: 3A 20 42      ld   a,(0x4220)           | read HAVE_NO_ALIENS_IN_SWARM
1624: 0F            rrca                     | move flag bit into carry
1625: D0            rts  nc                  | return if flag is not set, meaning that there are aliens left in the swarm
1626: 3A 25 42      ld   a,(0x4225)           | read HAVE_NO_INFLIGHT_OR_DYING_ALIENS
1629: 0F            rrca                     | move flag bit into carry
162A: D0            rts  nc                  | return if flag is not set, meaning that there are aliens attacking, or dying
162B: 3A 22 42      ld   a,(0x4222)           | read LEVEL_COMPLETE
162E: 0F            rrca                     | move flag bit into carry
162F: D8            rts  c                   | return if flag is not set
1630: 21 01 00      ld   hl,0x0001
1633: 22 22 42      ld   (0x4222),hl          | set LEVEL_COMPLETE to 1 and NEXT_LEVEL_DELAY_COUNTER to 0.                  
1636: C9            rts



HANDLE_LEVEL_COMPLETE:
1637: 21 22 42      ld   hl,0x4222            | load HL with address of LEVEL_COMPLETE
163A: CB 46         bit  0,(hl)              | test flag 
163C: C8            rts  z                   | return if level is not complete

* OK, level is complete. Wait until NEXT_LEVEL_DELAY_COUNTER to reach 0. 
163D: 23            inc  hl                  | bump HL to point to NEXT_LEVEL_DELAY_COUNTER
163E: 35            dec  (hl)                | decrement count
163F: C0            rts  nz                  | return if count is !=0

1640: 2B            dec  hl                  | bump HL to point to LEVEL_COMPLETE again.
1641: 36 00         ld   (hl),0x00            | clear LEVEL_COMPLETE flag.

1643: 11 1B 05      ld   de,0x051B            | load DE with address of PACKED_DEFAULT_SWARM_DEFINITION
1646: CD 46 06      call 0x0646               | call UNPACK_ALIEN_SWARM 
1649: AF            xor  a
164A: 32 1A 42      ld   (0x421A),a           | reset DIFFICULTY_EXTRA_VALUE
164D: 32 5F 42      ld   (0x425F),a           | reset TIMING_VARIABLE
1650: 21 01 00      ld   hl,0x0001
1653: 22 0E 42      ld   (0x420E),hl          | set SWARM_SCROLL_VALUE

* increase game difficulty level, if we can.
1656: 2A 1B 42      ld   hl,(0x421B)          | load H with PLAYER_LEVEL and L with DIFFICULTY_BASE_VALUE
1659: 24            inc  h                   | increment player level 
165A: 7D            ld   a,l                 | load A with DIFFICULTY_BASE_VALUE
165B: FE 07         cp   0x07                 | are we at max difficulty?
165D: 28 03         jr   z,0x1662             | yes, goto 0x1662
165F: 30 22         jr   nc,0x1683            | edge case: we're above max difficulty! So clamp difficulty level to 7.
1661: 3C            inc  a                   | otherwise, increment DIFFICULTY_BASE_VALUE
1662: 6F            ld   l,a
1663: 22 1B 42      ld   (0x421B),hl          | update PLAYER_LEVEL and DIFFICULTY_BASE_VALUE

1666: 11 00 07      ld   de,0x0700            | command: BOTTOM_OF_SCREEN_INFO_COMMAND, parameter: 0 (DISPLAY_LEVEL_FLAGS)
1669: CD F2 08      call 0x08F2               | call QUEUE_COMMAND. 

* How many flagships survived from the last round? If so, they need to be added into the swarm before the level starts.
166C: 3A 1E 42      ld   a,(0x421E)           | get value of FLAGSHIP_SURVIVOR_COUNT into A
166F: A7            and  a                   | Did any flagships survive from the last round?
1670: C8            rts  z                   | Return if no flagships survived.
1671: 21 77 41      ld   hl,0x4177            | load HL with address of free slot in flagship row of ALIEN_SWARM_FLAGS
1674: 36 01         ld   (hl),0x01            | create a flagship!
1676: 3D            dec  a                   |   
1677: 32 1E 42      ld   (0x421E),a           | set value of FLAGSHIP_SURVIVOR_COUNT
167A: C8            rts  z                   | return if zero. 
167B: 23            inc  hl                  | bump HL to address of next free slot in flagship row 
167C: 36 01         ld   (hl),0x01            | create a flagship!
167E: AF            xor  a                
167F: 32 1E 42      ld   (0x421E),a           | clear value of FLAGSHIP_SURVIVOR_COUNT
1682: C9            rts



CLAMP_DIFFICULTY_LEVEL:
1683: 3E 07         ld   a,0x07               | maximum value for DIFFICULTY_BASE_VALUE
1685: C3 62 16      jp   0x1662               | set DIFFICULTY_BASE_VALUE 


*
* When you shoot a flagship, the swarm goes into shock for a short period of time. No aliens will break off to attack you.
*

HANDLE_SHOCKED_SWARM:
1688: 21 2B 42      ld   hl,0x422B            | load HL with address of IS_FLAGSHIP_HIT flag     
168B: CB 46         bit  0,(hl)              | test flag
168D: C8            rts  z                   | return if flagship has not been hit
168E: 3A 24 42      ld   a,(0x4224)           | read HAVE_AGGRESSIVE_ALIENS flag
1691: A7            and  a                   | test flag
1692: 20 0B         jr   nz,0x169F            | if flag is set, goto 0x169F 
1694: 3A 21 42      ld   a,(0x4221)           | read HAVE_NO_BLUE_OR_PURPLE_ALIENS
1697: A7            and  a                   | test flag
1698: 20 05         jr   nz,0x169F            | if flag is set, goto 0x169F
169A: 3A 26 42      ld   a,(0x4226)           | read HAVE_NO_INFLIGHT_ALIENS
169D: 0F            rrca                     | move flag into carry
169E: D0            rts  nc                  | return if some aliens are inflight
169F: 23            inc  hl                  | bump HL to address of ALIENS_IN_SHOCK_COUNTER
16A0: 35            dec  (hl)                | decrement counter. When it hits zero, aliens will snap out of it!
16A1: C0            rts  nz                  | exit routine if counter non-zero
16A2: 2B            dec  hl                  | bump HL to address of IS_FLAGSHIP_HIT
16A3: 36 00         ld   (hl),0x00            | clear flag. Aliens can break off from the swarm to attack again.
16A5: C9            rts

*
* Looks like this might be legacy code imported from an older game| it writes to a port that does nothing
*

16A6: 3A 07 40      ld   a,(0x4007)            | read IS_GAME_OVER flag
16A9: 0F            rrca                      | move bit 0 into carry
16AA: D8            rts  c                    | if carry set, return
16AB: 21 DF 41      ld   hl,0x41DF
16AE: 7E            ld   a,(hl)
16AF: A7            and  a
16B0: C8            rts  z
16B1: 0F            rrca
16B2: 0F            rrca
16B3: 32 04 68      ld   (0x6804),a            | Does nothing - this port is not connected
16B6: 35            dec  (hl)
16B7: C9            rts


*
* You may have noticed that when you're close to obliterating the swarm, that the background swarm noises
* get fewer and fewer, until there's no background noise, just the sound of attacking aliens and your bullets.
* This is the routine that handles the background noises. But this isn't the most important thing the routine does. 
* 
* Tucked away here is more important code, which affects the aliens aggressiveness. If you have 3 aliens or less
* in the swarm (inflight aliens don't count), the aliens are enraged and will be far more aggressive.
* Any aliens that take flight to attack you (inflight aliens) will never return to the swarm and keep attacking
* until either you or they are dead.
*
* If you wish to artificially enforce aggressiveness, pause the game and input the following into the MAME debugger:
*
* maincpu.mb@16e3=c9
* maincpu.mb@16e7=c9
* maincpu.pb@4224=1       // note the .pb, not .mb
*
* This will make the aliens attack you constantly - even when you start a new level.

HANDLE_ALIEN_AGGRESSIVENESS:
16B8: 3A 07 40      ld   a,(0x4007)           | read IS_GAME_OVER flag
16BB: 0F            rrca                     | move flag into carry
16BC: D8            rts  c                   | return if GAME OVER   
16BD: 21 23 41      ld   hl,0x4123            | load HL with address of very first alien in ALIEN_SWARM_FLAGS
16C0: 11 06 00      ld   de,0x0006            | DE is an offset to add to HL after processing a row of aliens
16C3: 4B            ld   c,e                 | Conveniently, E is also number of rows of aliens in swarm! (6) 
16C4: 3E 01         ld   a,0x01               | A is going to be used to total the number of aliens in the swarm 
16C6: 06 0A         ld   b,0x0A               | 10 aliens maximum per row
16C8: 86            add  a,(hl)              
16C9: 2C            inc  l                   | bump HL to point to next alien in ALIEN_SWARM_FLAGS
16CA: 10 FC         djnz 0x16C8               | repeat until all aliens in the row have been done
16CC: 19            add  hl,de               | make HL point to first alien in row above 
16CD: 0D            dec  c                   | do rows until C==0
16CE: C2 C6 16      jp   nz,0x16C6

* When we get here, A = total number of aliens left alive in the swarm + 1
16D1: 21 00 68      ld   hl,0x6800            | load HL with address of !SOUND  reset background F1 port
16D4: 06 03         ld   b,0x03               | number of ports to write to maximum 
16D6: 3D            dec  a                   | decrement total by 1 
16D7: 28 14         jr   z,0x16ED             | if total is zero, goto 0x16ED 

* This piece of code writes 1 to !SOUND  reset background F1 to F3 
16D9: 36 01         ld   (hl),0x01            | 
16DB: 2C            inc  l
16DC: 10 F8         djnz 0x16D6

16DE: FE 02         cp   0x02                 |                  
16E0: 38 05         jr   c,0x16E7             | 
16E2: AF            xor  a
16E3: 32 24 42      ld   (0x4224),a           | clear HAVE_AGGRESSIVE_ALIENS flag
16E6: C9            rts

* This piece of code is only called when there are 3 aliens or less in the swarm.
* It makes the aliens extremely aggressive!
16E7: 3E 01         ld   a,0x01
16E9: 32 24 42      ld   (0x4224),a           | set HAVE_AGGRESSIVE_ALIENS flag
16EC: C9            rts

* This piece of code writes 0 to !SOUND  reset background F1 to F3
16ED: 36 00         ld   (hl),0x00
16EF: 2C            inc  l
16F0: 10 FB         djnz 0x16ED
16F2: C3 DE 16      jp   0x16DE


	
*
* Value in register A       What it represents
* =====================================================
* 0                         Display Player one's score 
* 1                         Display Player two's score 
* 2                         Display high score.
* 3                         Do all of the above.
*

DISPLAY_SCORE_COMMAND:	
	cmp.b	#3,d0
	bcc.b		DISPLAY_ALL_SCORES       	| if A>= #0x03, goto 0x224D, DISPLAY_ALL_SCORES
	lea			PLAYER_ONE_SCORE+2(pc),a0	| pointer to last 2 BCD digits of PLAYER_ONE_SCORE
	beq.b		DECIDE_TO_DISPLAY_PLAYER_ONE_OR_PLAYER_TWO_SCORE	| if A is 0
	subq.b		#1,d0				    | if A was 1 on entry, then Z flag is now set
	bne.b		DISPLAY_HIGH_SCORE
	tst.b		IS_TWO_PLAYER_GAME
	bne.b		0f
	rts					| if it's zero, then we're just in a single player game, return
0:
	lea			PLAYER_TWO_SCORE+2(pc),a0	        | pointer to last 2 BCD digits of PLAYER_TWO_SCORE
	jra			DECIDE_TO_DISPLAY_PLAYER_ONE_OR_PLAYER_TWO_SCORE

DISPLAY_HIGH_SCORE:
	lea		HI_SCORE+2(pc),a0            | pointer to last 2 BCD digits of HI_SCORE
	jra		l_21F8

* This displays player scores and high scores
DISPLAY_ALL_SCORES:
	subq.b	#1,d0
	move.w	d0,-(a7)
	jbsr	DISPLAY_SCORE_COMMAND
	move.w	(a7)+,d0
	bne.b	DISPLAY_ALL_SCORES
	rts


* 
* Expects:
*
* Value in register A       Action taken                     
* ====================================================
* 0                         Display player one's score       
* 1                         Display player two's score
*      
* DE = pointer to *last* byte of 3 BCD bytes representing a score (ie: player 1 score, player 2 score)

DECIDE_TO_DISPLAY_PLAYER_ONE_OR_PLAYER_TWO_SCORE:
	move.w	#0x5381,d6            | pointer to character RAM location for player one's score
	tst.b	d0                    | test if A is 0.  
	beq.b	PLOT_SCORE_CHARACTERS | if A is 0 then we want to draw player one's score, goto 0x2261
	move.w	#0x5121,d6            | pointer to character RAM location for player one's score

*
* Plot score to the screen. 
*
* Expects:
*
* DE = pointer to *last* byte of 3 BCD bytes representing a score (ie: player 1 score, player 2 score, or high score)
*      See docs for PLAYER_ONE_SCORE to understand how scores are packed as BCD 
*
* D6 = pointer to character RAM to begin plotting characters from
*
*

PLOT_SCORE_CHARACTERS:
	move.w	#-0x20,d5	| load HL with 0xFFE0 (-32 decimal) 
	moveq	#2,d3       | a score is 3 bytes in size..                
	moveq	#4,d2		| max number of leading zeros that can be skipped. For example,
                                             | when you start the game you have a score of zero. It renders as "00". 
                                             | So this says "skip the first 4 zeros in the score, but display the rest"
0:
	move.b	(a0),d0		| read BCD digits from score byte
	lsr.b	#4,d0       | move high nibble (first digit of BCD number)...
	jbsr	PLOT_LOWER_NIB_AS_DIGIT   | call  to plot the first digit                 
	move.b	(a0),d0		| read BCD digits from score byte
	jbsr	PLOT_LOWER_NIB_AS_DIGIT     | call to plot the second digit 
	subq.w	#1,a0		| bump to *previous* BCD byte
	dbf		d3,0b       | do until all BCD digits in score have been drawn
	rts


* Pokes a digit of the score to character RAM.
*
* Expects:
*
* Lower nibble of D0: BCD digit to be plotted as a character on screen 
* D2 = max number of leading zero digits in the score that can be skipped. 
* If D2 is 0, zero digits will always be drawn
* D6 = pointer to character RAM where digit will be plotted.

PLOT_LOWER_NIB_AS_DIGIT:
	and.b	#0xF,d0		| mask in lower nibble
	beq.b	0f			| if the lower nibble is zero, goto 0x2281

* OK, we have a nonzero digit.
	clr		d2              | tell the plot routine to draw all digits, even if they are zero, from now on
	bra.b	1f				| go plot the character

* we have a zero digit. Do we print it, or print a space instead?
0:
	tst.b	d2        | how many zero digits can we skip over?   
	beq.b	1f		| if we can't skip over any more leading zero digits, then goto 0x2288 to draw "0". 

* Otherwise, we are skipping a leading "0" digit and will print an empty space instead..
	move.b	#0x80,d0	| when added to 0x90 this will produce 0x10 (16 decimal) - ordinal for empty character
	subq.b	#1,d2		| decrement count of leading zeros we are allowed to ignore
1:
	add.b	#0x90,d0    | transform A into ordinal of character to be plotted
	jbsr	osd_w_bg_videoram		| plot character for score to screen
	add.w	d5,d6		| now IX points to character directly above one just plotted
	rts


*
* Load DE (A1) with the [effective] address of the current player's score.
* 


LEA_DE_OF_CURRENT_PLAYER_SCORE:
	lea	PLAYER_ONE_SCORE(pc),a1            | address of 
	tst.b	CURRENT_PLAYER     | read CURRENT_PLAYER           
	bne.b	0f					| if it is zero, then current player is player one. Return.
	rts
0:
	lea		PLAYER_TWO_SCORE(pc),a1	| address of PLAYER_TWO_SCORE
	rts


SET_COLOUR_ATTRIBUTES_TABLE_1:
		lea		COLOUR_ATTRIBUTE_TABLE_1(pc),a0 

*TODO
SET_COLOUR_ATTRIBUTES:
*0598: 11 21 40      ld   de,0x4021            | address of first attribute in OBJRAM_BACK_BUF 
*059B: 06 20         ld   b,0x20               | we're setting attributes for all 32 columns in the row
*059D: 7E            ld   a,(hl)              | read attribute value from ROM 
*059E: 12            ld   (de),a              | write to attribute value in OBJRAM_BACK_BUF
*059F: 23            inc  hl                  | bump HL to next value in ROM
*05A0: 1C            inc  e                   | Add 2 to DE..
*05A1: 1C            inc  e                   | .. so that it points to the next attribute value
*05A2: 10 F9         djnz 0x059D               | and do until b==0
*05A4: C9            rts
	rts

UNPACK_ALIEN_SWARM:
*TODO
	rts
	
*0646: 21 00 41      ld   hl,0x4100            | load HL with address of ALIEN_SWARM_FLAGS
*0649: 06 10         ld   b,0x10               | There's 16 bytes to be unpacked to 128 flags
*064B: 0E 01         ld   c,0x01
*
*064D: 1A            ld   a,(de)              | read from (de) 
*064E: A1            and  c                   | test if bit is set
*064F: 28 0B         jr   z,0x065C             | if bit is not set, goto 0x065C 
*0651: 36 01         ld   (hl),0x01            | bit is set, write 1 to (hl) - create an alien 
*0653: 23            inc  hl                  | bump hl to next byte
*0654: CB 01         rlc  c                   | rotate c left one bit
*0656: 30 F5         jr   nc,0x064D            | if bit 7 of C wasn't set, goto 0x064D
*0658: 13            inc  de                  | move to next byte
*0659: 10 F2         djnz 0x064D               | do until b ==0
*065B: C9            rts
*065C: 36 00         ld   (hl),0x00            | write 0 to (hl) 
*065E: C3 53 06      jp   0x0653               | 


*
* Try to insert into the circular command queue located @ 0x40C0. (CIRC_CMD_QUEUE_START)
* if insert is not possible, exit function immediately.
*
* Expects:
* D is a command number (0..7) 
* E is a parameter to pass to the command. 
*
* 0x40A0 contains the low byte of a pointer to a (hopefully) free entry in the queue.  
*
* REMARKS:
*
* Value in D                Action it invokes 
* ===============================================================
* 0                         Invokes DRAW_ALIEN_COMMAND
* 1                         Invokes DELETE_ALIEN_COMMAND
* 2:                        Invokes DISPLAY_PLAYER_COMMAND
* 3:                        Invokes UPDATE_PLAYER_SCORE_COMMAND
* 4:                        Invokes RESET_SCORE_COMMAND
* 5:                        Invokes DISPLAY_SCORE_COMMAND
* 6:                        Invokes PRINT_TEXT_COMMAND 
* 7:                        Invokes BOTTOM_OF_SCREEN_INFO_COMMAND
* 
* The purpose of the parameter in E depends on the command.
*
* SEE ALSO:
* The code @ 0x200C which processes the entries in the queue.

* ALGORITHM:
* 1. Form a pointer to an entry in the circular queue using #0x40 as the high byte of the pointer
*    and the contents of 0x40A0 (CIRC_CMD_QUEUE_PTR_LO) as the low byte. 
* 2. Read a byte from the queue entry the pointer points to 
* 3. IF bit 7 of the byte is unset, then the queue entry is in use, we can't insert. Exit function.  
* 4. ELSE:
*    4a) store register DE at the pointer
*    4b) bump pointer to next queue entry 
* 5. Exit function

QUEUE_COMMAND:
	move.l	a0,-(a7)
	move.l	CIRC_CMD_QUEUE_PTR(pc),a0
	tst		(a0)	| if bit 7 not set, this entry cannot be used, goto 0x090B and exit
	bpl.b	1f
	* JOTD: data is even aligned so we can write command & args
	* atomicly, in the original there's a slight chance that
	* the command queue is processed between both writes
	move.w	d3,(a0)+
	cmp.l	#CIRC_CMD_QUEUE_END,a0
	bne.b	0f
	move.l	#CIRC_CMD_QUEUE_START,a0
0:
	move.l	a0,CIRC_CMD_QUEUE_PTR		| update CIRC_CMD_QUEUE_PTR_LO to point to next queue entry
1:
	move.l	(a7)+,a0
	rts
	



*
* Called from $0004.
* 
*
*
	
INITIALISE_SYSTEM:  | 1A55

* Clear screen 
	move	#0x400-1,d1
	move	#0x10,d0
	move.w	#0x5000,d6
0:
	jbsr		osd_w_bg_videoram
	addq.w	#1,d6
	dbf		d1,0b
	
* clear attributes and reset scroll values
	move	#0x100-1,d1
	moveq	#0,d0
	move.w	#0x5400,d6
0:
	jbsr		osd_w_bg_colorram	| write 0 to screen attribute RAM. Will both set colour to 0 and reset column scroll.
	addq.w	#1,d6
	dbf		d1,0b
	
* (skipped startup checks!)

* When we get here, all the diagnostic tests have succeeded. 
* There are no errors, and the game can start proper.
* original game sets all to 0 except for 0x40C0->0x4100
* I almost could blindly follow that but some of the pointers
* are 1-byte pointer nibbles, had to switch to full 32 bit

	lea		VARIABLES_START(pc),a0		| Start of working RAM
	move.w	#VARIABLES_END-VARIABLES_START-1,d0
0:
	clr.b	(a0)+
	dbf		d0,0b
	
	* message queue set to all invalid (negative)
	lea		CIRC_CMD_QUEUE_START(pc),a0
	move.w	#CIRC_CMD_QUEUE_END-CIRC_CMD_QUEUE_START-1,d0
1:
	st.b	(a0)+
	dbf		d0,1b
	
	move.b	#0x20,TEMP_COUNTER_1			| set TEMP_COUNTER_1
	move.b	#3,DIAGNOSTIC_MESSAGE_TYPE
	lea		CIRC_CMD_QUEUE_START(pc),a0
	move.l	a0,CIRC_CMD_QUEUE_PTR			| reset CIRC_CMD_QUEUE_PTR
	move.l	a0,CIRC_CMD_QUEUE_PROC			| reset CIRC_CMD_QUEUE_PROC
	
	jbsr	osd_stars_on					| Set 9Nregen stars on. Starry background now appears 
	jbsr	osd_enable_vblank_interrupt		| Enable 9Nregen NMIon
	
	* part done in diagnostic, we don't want diagnostic but we need those inits
	move.w	#0x5000,TEMP_CHAR_RAM_PTR    | set TEMP_CHAR_RAM_PTR
	move.b	#0x20,TEMP_COUNTER_1
	clr.b	DIAGNOSTIC_MESSAGE_TYPE
	clr.b	SCRIPT_NUMBER

*	bra		jmp_2000
*	nop
	

* reset all player-related state including score, high score
jmp_2000:
	lea		PLAYER_ONE_SCORE(pc),a0
	move.w	#(CIRC_CMD_QUEUE_START-PLAYER_ONE_SCORE)/2-1,d0
0:
	clr.w	(a0)+
	dbf		d0,0b
	
	* now would be a good time to read highscore from saved state
	lea		PLAYER_ONE_SCORE(pc),a0
	*bsr		osd_read_hiscores
*
* Process the circular command queue starting @ 0x40C0 (CIRC_CMD_QUEUE_START)
*
* Notes:
* The value in 0x40A1 (I have named it CIRC_CMD_QUEUE_PROC_LO) is the low byte of a pointer to the first entry in 
* the queue to be processed. The high byte of the pointer is always #0x40.
* 
* In a circular queue, the first entry to be processed is not necessarily the head of the queue. 
* The first entry to be processed could be anywhere in the queue. 
*


PROCESS_CIRCULAR_COMMAND_QUEUE:
0:
	move.l	CIRC_CMD_QUEUE_PROC(pc),a0		| now a0 = pointer to a queue entry in the queue to be processed
	moveq	#0,d0
	move.b	(a0),d0							| read command number from queue entry into d0. 
	add.b	d0,d0							| multiply d0 by 2 to form an offset into jump table @0x203D
	bcc.b	1f
	
    jbsr		HANDLE_SWARM_ANIMATION
	bra.b	0b								| process next entry in circular queue
1:
	and  #0x0F,d0                 | mask in lower nibble
	add		d0,d0							| multiply d0 by 4 to form an offset into jump table @0x203D
	lea	jump_table_203D(pc),a1			| pointer to jump table beginning @ 0x203D
	move.l	(a1,d0.w),a1
	
	st	(a0)+                             | write #0xFF (255 decimal) to first byte of byte pair, to mark it as "free"
	move.b	(a0),d4		                  | read parameter value from queue entry into E. 
	st	(a0)+                             | write #0xFF (255 decimal) to second byte of byte pair, to mark it as "free"
	cmp.l	#CIRC_CMD_QUEUE_END,a0		  | is HL == 0x4100? If so, comparing L (which will be 0) to #0xC0 (192 decimal) will set the carry flag. 
	bcs.b	2f							  | if carry is set, then we have not reached the end of the queue (0x4100), goto 0x202C
	lea		CIRC_CMD_QUEUE_START(pc),a0		  | otherwise, we have reached end of queue. 
2:
	move.l	a0,CIRC_CMD_QUEUE_PROC       | Set lo byte of pointer to 0xC0 (0x40C0 = start of circular queue)
	move.b	d4,d0		                 | Now d0 = parameter to command
	pea		0b(pc)						 | push it onto stack, so when we hit a rts it'll return to 0x200A
	jmp		(a1)		                 | jump to proper code from the table below					 

jump_table_203D:
    .long	DRAW_ALIEN_COMMAND
    .long	DELETE_ALIEN_COMMAND
    .long	DISPLAY_PLAYER_COMMAND
    .long	UPDATE_PLAYER_SCORE_COMMAND
    .long	RESET_SCORE_COMMAND
    .long	DISPLAY_SCORE_COMMAND
    .long	PRINT_TEXT_COMMAND
    .long	DISPLAY_BOTTOM_OF_SCREEN_COMMAND
	
DRAW_ALIEN_COMMAND:
	rts
	
DELETE_ALIEN_COMMAND:
	rts
	
DISPLAY_PLAYER_COMMAND:
	rts
	
UPDATE_PLAYER_SCORE_COMMAND:
	rts
	
RESET_SCORE_COMMAND:
	rts
	
	
*
* A = index of string to print
*
* Bit 6 set: scroll this text onto screen
* Bit 7 set: clear this text
*
* Value in A (ANDed with 0x3F)       Text printed
* =============================================================
* 0                                 GAME OVER
* 1                                 PUSH START BUTTON  
* 2                                 PLAYER ONE 
* 3                                 PLAYER TWO 
* 4                                 HIGH SCORE
* 5                                 CREDIT
* 6                                 BONUS GALIXIP FOR   000 PTS
* 7                                 CONVOY CHARGER 
* 8                                 - SCORE ADVANCE TABLE -
* 9                                 MISSION: DESTROY ALIENS
* A                                 WE ARE THE GALAXIANS
* B                                 30       60  PTS 
* C                                 40       80  PTS
* D                                 50      100  PTS
* E                                 60      300  PTS
* F                                 NAMCO logo
* 10                                FREE PLAY

PRINT_TEXT_COMMAND:
	lea	TEXTPTRS(pc),a0
	add.w	d0,d0
	move.w	d0,-(a7)
	add.w	d0,d0
	and.w	#0x7F,d0   | mask in bits 0..6. Now A = a value in range of 0..127
	move.l	(a0,d0.w),a0	| HL now points to an entry in the TEXTPTRS lookup table.
	move.w	(a0)+,d6		| DE = *HL. Now DE holds character RAM address to print text at
							| Now HL = pointer to character RAM, DE = pointer to text to print
	move.w	#-0x20,d5         | offset to add to HL after every character write. (-32 in decimal)
	move.w	(a7)+,d2	
	*2309: 38 0E         jr   c,0x2319  *TODO ???? erase??
	*bmi.b	l_2323		| if minus flag is set, then we want to scroll text onto screen - goto 0x2323
0:
	move.b	(a0)+,d0     | read character to be drawn   
	sub.b	#0x30,d0
	cmp.b	#0xF,d0		| is this the string terminator, #0x3F?
	bne.b	1f
	rts					| yes, so exit routine
1:
	jbsr	osd_w_bg_videoram
	add.w	d5,d6		| Add offset to screen address so that next character is drawn at correct location.   
	bra.b	0b			| and continue

* I'll stick my neck out and guess this code is to erase text that was drawn previously.
*2319: 1A            ld   a,(de)
*231A: FE 3F         cp   0x3F
*231C: C8            rts  z
*231D: 36 40         ld   (hl),0x40
*231F: 13            inc  de
*2320: 09            add  hl,bc
*2321: 18 F6         jr   0x2319

*
* Set text up for scrolling. Invoked by 0x230B within PRINT_TEXT_COMMAND
*
* HL = pointer to character RAM
* DE = pointer to text string to render
*

l_2323:

* 22 B5 40      ld   (0x40B5),hl          | store pointer to character RAM in COLUMN_SCROLL_CHAR_RAM_PTR
*2326: EB            ex   de,hl               | now HL = pointer to text string, DE = pointer to character RAM 
*2327: 22 B3 40      ld   (0x40B3),hl          | store pointer to next char to scroll on in COLUMN_SCROLL_NEXT_CHAR_PTR
*232A: 7B            ld   a,e                 | get low byte of character RAM address into A
*232B: E6 1F         and  0x1F                 | mask in bits 0..4. Effectively A = A mod #0x20 (32 decimal). A now represents a column index from 0-31.
*232D: 47            ld   b,a                 | save column index in B.
** compute offset into OBJRAM_BACK_BUF
*232E: 87            add  a,a                 | A=A*2. This is because attribute RAM requires 2 bytes per column. 
*232F: C6 20         add  a,0x20               | add 0x20 (32 decimal) as OBJRAM_BACK_BUF starts at 0x4020
*2331: 6F            ld   l,a                 | 
*2332: 26 40         ld   h,0x40               | now HL = a pointer to scroll attribute value in OBJRAM_BACK_BUF 
*2334: 22 B1 40      ld   (0x40B1),hl          | set COLUMN_SCROLL_ATTR_BACKBUF_PTR
*2337: E5            push hl                  | save pointer to scroll offset attribute on the stack
*
*2338: CB 3B         srl  e
*233A: CB 3B         srl  e
*233C: 7A            ld   a,d                
*233D: E6 03         and  0x03
*233F: 0F            rrca
*2340: 0F            rrca
*2341: B3            or   e
*2342: E6 F8         and  0xF8
*2344: 4F            ld   c,a                 | C = scroll offset to write to OBJRAM_BACK_BUF 
*
** we're going to clear this line ready for scrolling text on.
*2345: 21 00 50      ld   hl,0x5000            | HL = start of character RAM
*2348: 78            ld   a,b                 | restore column index from B (see @0x232D)
*2349: 85            add  a,l                 
*234A: 6F            ld   l,a                 | Add column index to L. Now HL = pointer to column to clear
*234B: 11 20 00      ld   de,0x0020            | offset to add to HL. 0x20 (32 decimal) characters per row
*234E: 43            ld   b,e                 | B = count of how many characters need to be cleared by DJNZ loop
*234F: 36 10         ld   (hl),0x10            | write empty space character
*2351: 19            add  hl,de               | add offset to HL. Now HL points to same column next row down
*2352: 10 FB         djnz 0x234F
*2354: E1            pop  hl                  | restore attribute pointer from the stack
*2355: 71            ld   (hl),c              | write initial scroll offset to OBJRAM_BACK_BUF
*2356: 3E 01         ld   a,0x01
*2358: 32 B0 40      ld   (0x40B0),a           | set IS_COLUMN_SCROLLING flag
*235B: C9            rts

TEXTPTRS:                                     
	dc.l	TXT_GAME_OVER
	dc.l	TXT_PUSH_START_BUTTON  
	dc.l	TXT_PLAYER_ONE 
	dc.l	TXT_PLAYER_TWO 
	dc.l	TXT_HIGH_SCORE
	dc.l	TXT_CREDIT
	dc.l	TXT_BONUS_GALIXIP_FOR___000_PTS  
	dc.l	TXT_CONVOY_CHARGER 
	dc.l	TXT___SCORE_ADVANCE_TABLE__
	dc.l	TXT_MISSION__DESTROY_ALIENS
	dc.l	TXT_WE_ARE_THE_GALAXIANS
	dc.l	TXT_30_______60__PTS 
	dc.l	TXT_40_______80__PTS
	dc.l	TXT_50______100__PTS
	dc.l	TXT_60______300__PTS
	dc.l	TXT_NAMCO_logo
	dc.l	TXT_FREE_PLAY


*
* Selects information to be displayed at the bottom of the screen.
*
* On entry:
* A identifies what to be displayed.
*
* Value in d0                Action taken                                                                 See also 
* ===============================================================================================================================================
* 0                         The player advances to the next level and the red level flags are redrawn.   See: 0x2520 (DISPLAY_LEVEL_FLAGS)
* 1                         Display FREE PLAY or CREDIT n at bottom left of screen.                      See: 0x24EB (DISPLAY_AVAILABLE_CREDIT)
* 2                         Display BONUS GALIXIP FOR (nnnnn) PTS on screen.                             See: 0x24C8 (DISPLAY_BONUS_GALIXIP_FOR)
* Any other value           Display player ships remaining at bottom left of screen.                     See: 0x22B3 (DISPLAY_PLAYER_SHIPS_REMAINING)
*
DISPLAY_BOTTOM_OF_SCREEN_COMMAND:
	tst.b	d0
	jeq		DISPLAY_LEVEL_FLAGS		| if parameter is 0
	subq.b	#1,d0
	jeq		DISPLAY_AVAILABLE_CREDIT	| if parameter was 1
	subq.b	#2,d0
	jeq		DISPLAY_BONUS_GALIXIP_FOR	| if parameter was 2
	
	move.b	PLAYER_LIVES(pc),d1
	jra		DISPLAY_PLAYER_SHIPS_REMAINING
	

*
* Displays the text string BONUS GALIXIP FOR (nnnnn) on screen.
*

DISPLAY_BONUS_GALIXIP_FOR:
	move.b	BONUS_GALIXIP_FOR(pc),d0
	cmp.b	#0xFF,d0     | check if there is any bonus. I think this code is redundant.
	bne.b	0f
	rts                   | if no bonus, then return
0:
	move.b	#6,d0               | index of BONUS GALIXIP FOR 0000 PTS text string
    jbsr PRINT_TEXT_COMMAND               | display text on screen
    move.b	BONUS_GALIXIP_FOR(pc),d0           | read BONUS GALIXIP value
    and.b  #0x0F,d0                 | mask in low nibble
	move.w	#0x5138,d6           | write value to character RAM
    move.b	BONUS_GALIXIP_FOR(pc),d0           | read BONUS GALIXIP value
	and.b  #0xF0,d0			| mask in high nibble
    bne.b	1f            | if it's !=0, goto 0x24E3
    addq.b	#1,d0
1:
    lsr.w	#4,d0          | move high nibble...
							| ... into lower nibble, so that A is now a number from 0..9
	move.w	#0x5158,d6
	jbra		osd_w_bg_videoram   | and POKE number to screen RAM, displaying single digit in correct place
    *rts                      | we're out


*
* Displays either FREE PLAY or CREDIT (n) at bottom left of screen
*

DISPLAY_AVAILABLE_CREDIT:
      tst.b	IS_GAME_IN_PLAY
	  beq.b	0f
	  rts						| if the game is in play, return.
0:
      move.b	PORT_STATE_6800(pc),d1           | read PORT_STATE_6800
      and.b   #0xC0,d1                 | mask in dip switch 1 & 2 state
      move.b	#0x10,d0               | index of text string "FREE PLAY"
      cmp.b   #0xC0,d1                 | are both dip switches on?
      beq	PRINT_TEXT_COMMAND

* if we get here, then we're not in FREE PLAY mode. We will display number of credits on screen.
      move.b	#0x05,d0               | index of text string "CREDIT"
      jbsr PRINT_TEXT_COMMAND
	  moveq	#0,d0
      move.b	NUM_CREDITS,d0          | read number of credits
      cmp.b	#0x63,d0                 | compare to 99 decimal
      bcs.b		1f             | if A <99 then goto 0x250A
      move.w	#99,d0               | clamp number of credits to 99
1:
      jbsr CONVERT_A_TO_BCD     |  Now A = BCD equivalent of what it was
      move.b	d0,d1           | save credits as BCD in B
      and.b  #0xF0,d0                 | mask in high nibble, which is first digit of BCD
      beq.b	2f             | if the first digit is 0, goto 0x2519. We don't display it.
      lsr.w	#4,d0                    | shift high nibble...
                                     | to low nibble.. converting first BCD digit to decimal.
      move.w	#0x529F,d6           | Write first digit of credits to character RAM
	  bsr		osd_w_bg_videoram
2:
      move.b	d1,d0              | get credits as BCD into A again. We preserved it in B @0x250D
      and.b  #0x0F,d0                 | mask in low nibble, which is second digit of BCD. Converts second BCD digit to decimal.
	  move.w	#0x527F,d6
      bsr		osd_w_bg_videoram           | Write second digit of credits to character RAM 
      rts                      


*
* Called when the player has completed the level.
*
* This routine:
*    Resets the swarm tempo|
*    increments the player level (48 levels maximum)|
*    Draws level flags. 
*

DISPLAY_LEVEL_FLAGS:
      tst.b	HAVE_NO_ALIENS_IN_SWARM   | test if flag is set
      beq.b	0f             | if flag is not set, goto 0x252C
      move.b  #1,RESET_SWARM_SOUND_TEMPO     | set  flag to 1. The swarm tempo will be slow again. 
0:
      move.b	PLAYER_LEVEL(pc),d0           | read .
      addq.b	#1,d0                   | increment it.
      cmp.b	#0x30,d0                 | Compare to #0x30 (48 decimal)
      bcs.b	     1f        | if A < 48, goto 0x2536
      move.b	#0x30,d0               | Level 48 is the limit.
1:
* A = level number (0-48)
      jbsr CONVERT_A_TO_BCD               | convert A to BCD. Now A = BCD equivalent 

* A = level number in BCD
	move.w	d0,-(a7)
    move.w	#0x507E,d6              | address in character RAM to start drawing flags at
    and.b  #0xF0,d0                 | mask in high nibble
    beq.b	3f                      | if the high nibble is zero, then goto 0x2551

* Calculate how many "10" flags we are going to draw
    lsr.w	#4,d0                     | shift bits in high nibble of BCD number....
									  | to lower nibble.
	move.b	d0,d1                 | B now holds the number of red "10" flags to draw at the bottom right of the screen.
	and.w	#0xFF,d1
	subq.w	#1,d1
	move.b	#0x10,d2              | C is a count of how much space, in characters, we have to plot flags. We start with #0x10 (16 decimal) 
2:
	move.b	#0x68,d0               | ordinal of first character of "10" flag to plot
	jbsr	PLOT_CHARACTERS_2_BY_2_ASCENDING               | plot the flag with "10" on it
	subq.b	#2,d2                   | A "10" flag takes up 2 spaces..
									| ..so reduce C by 2.
	dbf		D1,2b               | repeat until B==0
3:
      move.w	(a7)+,d0

* Calculate how many normal red flags we are going to draw
* A=level number in BCD
    and.b  #0x0F,d0                 | mask in lower nibble of BCD number. Now A represents how many flags we are going to draw.
	moveq	#0,d1
	move.w	#0x1F,d3           | offset to add to HL after every flag drawn.
    move.b	d0,d1                 | B = number of flags to draw
	beq.b	5f				             | if we don't have any flags to draw then goto 0x2562
	subq.b	#1,d1
4:
    move.b	#0x6C,d0               | ordinal of first character to plot
    jbsr PLOT_TWO_CHARS_ON_SAME_ROW               | draw the normal flag on character map
    subq.b	#1,d2                   | A normal flag takes up just 1 character space, so reduce C by 1
    dbf		d1,4b               | repeat until B == 0
5:
* if we get here, we want to erase any flags left from the previous level
    subq.b	#1,d2              | decrement "space for characters remaining" count in C
    bpl.b	6f                   | return if c has become a negative value. 
	rts
6:
    jbsr	l_259E               | plot spaces to overwrite any existing flags
    bra.b	5b


DISPLAY_PLAYER_SHIPS_REMAINING:
	move.w	0x539E,d6          | address in character RAM
	move.w	#5,d2
	move.b	HAS_PLAYER_SPAWNED(pc),d0
    beq.b	0f                       
    subq.b	#1,d1
	beq.b	1f
	and.w	#0xFF,d1
	subq.b	#1,d1
0:
    move.b	#0x66,d3
    jbsr l_2593               | plot 2X2 characters
    subq.b	#1,d2
    dbf		d1,0b
1:
	subq.b	#1,d2
	bpl.b	2f
	rts
2:
	jbsr PLOT_CHARACTERS_2_BY_2_DESCENDING               | plot spaces to screen
	bra.b	1b
	
	
HANDLE_SWARM_ANIMATION:
	**move.w	#0xF00,0xdff180		| unimplemented
	rts

* Called to display "BAD RAM [n]" or "BAD ROM [n]""
* (just to debug our font engine!!)
DISPLAY_BAD_RAM_OR_ROM_MESSAGE:
	lea		bad_rom(pc),a0
	move.w	#0x5233,d6            | character RAM address to print text at
	move.w	#0x20,d2
	move.w	#6,d3               | there's 7 characters in "BAD RAM" (including the space between words)
0:
	move.b	(a0)+,d0
	jbsr	osd_w_bg_videoram
	add.w	d2,d6
	dbf		d3,0b
1:
	bra.b	1b

l_2583:
	move.b	#0x2C,d0               | space character

*
* Draw 4 characters in a 2 x 2 layout. 
*
* register A is the ordinal of the first character to draw. 
* The next 3 characters are derived automatically by incrementing A after each character drawn.
*
* Expects:
* A = ordinal of first character to poke to character RAM. 
* HL = pointer to character RAM address
* 
* Resulting layout is:
*
* A   |  A+1
* ----------
* A+2 |  A+3
*

PLOT_CHARACTERS_2_BY_2_ASCENDING:
      move.w	D3,-(a7)
      move.w	#0x001F,d3            | load de with 31 decimal. This is the width of a row, in characters, minus 1.
      jbsr PLOT_TWO_CHARS_ON_SAME_ROW               | plot 2 characters on same row... 
l_258C:
      jbsr PLOT_TWO_CHARS_ON_SAME_ROW               | and 2 characters on the next row 
      move.w	(a7)+,d3
      rts


*
* Draw 4 characters in a 2 x 2 layout. 
*
* register A is the ordinal of the first character to draw. 
*
* Expects:
* A = ordinal of first character to poke to character RAM. 
* HL = pointer to character RAM address
* 
* Resulting layout is:
*
* A-2 |  A-1
* ----------
* A   |  A+1

PLOT_CHARACTERS_2_BY_2_DESCENDING:
    move.w	D3,-(a7)
l_2593:
	move.b	#0x2E,d0
PLOT_2X2_CHARACTERS:
	move.w	#-33,d3		| load de with -33 decimal as signed word
	jbsr	PLOT_TWO_CHARS_ON_SAME_ROW               | plot 2 characters on one row..	
	subq.b	#4,d0		| subtract 4 from A
	bra.b	l_258C		| plot 2 characters on row above


l_259E:
	move.b	#0x2C,d0               | space character
*
* Plots 2 contiguous characters on same row
* register A is the ordinal of the first character to draw. A+1 is drawn in the next column.
*
* Expects:
* A = ordinal of first character to plot
* HL = pointer to character RAM where first character will be plotted
* DE = offset to add to HL after both characters have been plotted
*
* Returns:
* HL = updated pointer to character RAM
*

PLOT_TWO_CHARS_ON_SAME_ROW:
   bsr		osd_w_bg_videoram              | plot first character
   addq.b  #1,d0                   | increment A
   addq.w	#1,d6                  | bump HL to next address in RAM
   bsr		osd_w_bg_videoram     | plot second character
   addq.b  #1,d0
   add.w	d3,d6               | add offset in DE to HL
   rts

l_25A7:
	move.b	#0x2C,d0

*
* Plots 2 characters in the same column, one beneath the other.
*
* register A is the ordinal of the first character to draw. A+2 is drawn in the same column of the row beneath.
*
* Expects:
* A = ordinal of first character to plot
* HL = pointer to character RAM where first character will be plotted
*

PLOT_TWO_CHARACTERS_IN_SAME_COLUMN:
	move.w	d3,-(a7)
	move.w	#0x20,d3      | each row is comprised of 0x20 (32 decimal) characters...
	jbsr	osd_w_bg_videoram           | plot first character
	addq.b	#2,d0
	add.w	d3,d6                      | bump HL to point to the character at the row beneath
	jbsr	osd_w_bg_videoram              | plot second character
	move.w	(a7)+,d3
	rts

*
* Convert value in register A to BCD equivalent 
* 
* For example, if you pass in 0x63 (99 decimal) in A, this function will return 99 BCD
* 
* Expects:
* d0 = non BCD value, from 0..99
*
* Returns:
* d0 = BCD equivalent
* 
* the Z80 code is pretty convoluted, but I don't understand why. Just create a table: done

CONVERT_A_TO_BCD:
	lea		bcd_table(pc),a0
	and.w	#0x7f,d0		| could read out the table if > 99 but who cares?
	move.b	(a0,d0.w),d0
	rts
	
** I try to put data in the end

bad_rom:
	dc.b	0x1D,0x1F,0x22,0x10,0x14,0x11,0x12 



DEFAULT_SWARM_DEFINITION_AND_PLAYER_STATE:    | EQU 0x051B
PACKED_DEFAULT_SWARM_DEFINITION:
    | The first 16 bytes defining the default alien swarm. 
    | For information on how the bytes are unpacked, please see docs @ 0x0646
    .byte	0x00,0x00,0x00,0x00,0xF8,0x1F,0xF8,0x1F,0xF8,0x1F,0xF0,0x0F,0xE0,0x07,0x40,0x02

    | When starting a new game, these are the default values 
DEFAULT_PLAYER_STATE:
	.byte	0x3C                                 | Default value for DIFFICULTY_COUNTER_1 
    .byte	0x14                                 | Default value for DIFFICULTY_COUNTER_2
    .byte	0x00,0x02,0x00,0x02,0x00,0x0F,0x00,0x00,0x00     

* Referenced by code @ 0x0595
COLOUR_ATTRIBUTE_TABLE_1:
	.byte	0x00,0x05,0x00,0x00,0x01,0x01,0x02,0x03,0x03,0x04,0x04,0x04,0x04,0x00,0x00,0x00
	.byte	0x00,0x00,0x00,0x05,0x05,0x05,0x05,0x05,0x00,0x00,0x06,0x06,0x06,0x06,0x06,0x06
	
* Referenced by code @ 0x0408
COLOUR_ATTRIBUTE_TABLE_2:
	.byte	0x00,0x05,0x00,0x00,0x01,0x01,0x02,0x03,0x03,0x04,0x04,0x04,0x04,0x00,0x00,0x00
	.byte	0x06,0x06,0x06,0x06,0x06,0x06,0x05,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06

* Referenced by code @ 0x0212
COLOUR_ATTRIBUTE_TABLE_3:
	.byte	0x00,0x05,0x00,0x00,0x01,0x01,0x02,0x03,0x05,0x04,0x05,0x04,0x04,0x00,0x00,0x00
	.byte	0x00,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x00,0x00,0x07,0x07,0x06,0x06
* ",".join("0x{}".format(x) for x in s.split())

* Referenced by code @ 0x0D1D
	.byte	0x00,0x00,0x00,0x00,0x04,0x01,0x04,0x02,0x04,0x01,0x03,0x03,0x02,0x02,0x01,0x02

* address to print followed by text
	.align	2
TXT_GAME_OVER:
	.word	0x5296
	.ascii	"GAME@@OVER?"
	.align	2
TXT_PUSH_START_BUTTON:
	.word	0x52f1
	.ascii	"PUSH@START@BUTTON?"
	.align	2
TXT_PLAYER_ONE:
	.word	0x5294
	.ascii	"PLAYER@ONE?"
	.align	2
TXT_PLAYER_TWO:
	.word	0x5294
	.ascii	"PLAYER@TWO?"
	.align	2
TXT_HIGH_SCORE:
	.word	0x5280
	.ascii	"HIGH@SCORE?"
	.align	2
TXT_CREDIT:
	.word	0x537F
	.ascii	"CREDIT?"
	.align	2
TXT_BONUS_GALIXIP_FOR___000_PTS:
	.word	0x537F
	.ascii	"BONUS@GALIXIP@FOR@@@000@PTS?"
	.align	2
TXT_CONVOY_CHARGER:
	.word	0x52D1
	.ascii	"CONVOY@@CHARGER?"
	.align	2
TXT___SCORE_ADVANCE_TABLE__:
	.word	0x534F
	.ascii	"[@SCORE@ADVANCE@TABLE@[?"
	.align	2
TXT_MISSION__DESTROY_ALIENS:
	.word	0x5369
	.ascii	"MISSION"
	.byte	0xd3
	.ascii	"@DESTROY@ALIENS?"
	.align	2
TXT_WE_ARE_THE_GALAXIANS:
	.word	0x5327
	.ascii	"WE@ARE@THE@GALAXIANS?"
	.align	2
TXT_30_______60__PTS:
	.word	0x52D9
	.ascii	"@@30@@@@@@@60@@"
	.byte	0xD1,0xD2,0xD3,0x3F
	.align	2
TXT_40_______80__PTS:
	.word	0x52D7
	.ascii	"@@40@@@@@@@80@@"
	.byte	0xD1,0xD2,0xD3,0x3F
	.align	2
TXT_50______100__PTS:
	.word	0x52D5
	.ascii	"@@50@@@@@@100@@"
	.byte	0xD1,0xD2,0xD3,0x3F
	.align	2
TXT_60______300__PTS:
	.word	0X52D3
	.ascii	"@@60@@@@@@300@@"
	.byte	0xD1,0xD2,0xD3,0x3F
	.align	2
TXT_NAMCO_logo:
	.word	0x52C7
	.byte	0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0x9E,0x9F,0x3F
	.align	2
TXT_FREE_PLAY:
	.word	0x537F
	.ascii	"FREE@PLAY?"

* The tables @0x039A and 0x03A6 represent the points values displayed beneath the SCORE ADVANCE TABLE.
* These values are NOT BCD! They are ordinals for characters to be POKEd directly to character RAM.

* This table is for the Flagship
flagship_table_039A: 
	.byte	0x01,0x05,0x00            | 150 
	.byte	0x02,0x00,0x00            | 200
	.byte	0x03,0x00,0x00            | 300
	.byte	0x08,0x00,0x00            | 800

* This table is for the normal aliens
* Note: 10 is a space (empty) character
alien_table_03A6: 
	.byte	0x01,0x00,0x00            | 100   
	.byte	0x10,0x08,0x00            |  80   
	.byte	0x10,0x06,0x00            |  60    
	.align	2

bcd_table:
	.byte	0x0
	.byte	0x1
	.byte	0x2
	.byte	0x3
	.byte	0x4
	.byte	0x5
	.byte	0x6
	.byte	0x7
	.byte	0x8
	.byte	0x9
	.byte	0x10
	.byte	0x11
	.byte	0x12
	.byte	0x13
	.byte	0x14
	.byte	0x15
	.byte	0x16
	.byte	0x17
	.byte	0x18
	.byte	0x19
	.byte	0x20
	.byte	0x21
	.byte	0x22
	.byte	0x23
	.byte	0x24
	.byte	0x25
	.byte	0x26
	.byte	0x27
	.byte	0x28
	.byte	0x29
	.byte	0x30
	.byte	0x31
	.byte	0x32
	.byte	0x33
	.byte	0x34
	.byte	0x35
	.byte	0x36
	.byte	0x37
	.byte	0x38
	.byte	0x39
	.byte	0x40
	.byte	0x41
	.byte	0x42
	.byte	0x43
	.byte	0x44
	.byte	0x45
	.byte	0x46
	.byte	0x47
	.byte	0x48
	.byte	0x49
	.byte	0x50
	.byte	0x51
	.byte	0x52
	.byte	0x53
	.byte	0x54
	.byte	0x55
	.byte	0x56
	.byte	0x57
	.byte	0x58
	.byte	0x59
	.byte	0x60
	.byte	0x61
	.byte	0x62
	.byte	0x63
	.byte	0x64
	.byte	0x65
	.byte	0x66
	.byte	0x67
	.byte	0x68
	.byte	0x69
	.byte	0x70
	.byte	0x71
	.byte	0x72
	.byte	0x73
	.byte	0x74
	.byte	0x75
	.byte	0x76
	.byte	0x77
	.byte	0x78
	.byte	0x79
	.byte	0x80
	.byte	0x81
	.byte	0x82
	.byte	0x83
	.byte	0x84
	.byte	0x85
	.byte	0x86
	.byte	0x87
	.byte	0x88
	.byte	0x89
	.byte	0x90
	.byte	0x91
	.byte	0x92
	.byte	0x93
	.byte	0x94
	.byte	0x95
	.byte	0x96
	.byte	0x97
	.byte	0x98
	.byte	0x99
	
*
* Defines the arc to perform a loop the loop maneuvre. 
* Referenced by code @0x0D71 and 0x101F.
*
* The table comprises byte pairs:
*   byte 0: signed offset to add to INFLIGHT_ALIEN.X
*   byte 1: unsigned offset to add to *or* subtract from (depends on which way alien is facing when it breaks off from swarm) INFLIGHT_ALIEN.Y 
*
INFLIGHT_ALIEN_ARC_TABLE:
	.byte	0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x01,0xFF,0x00,0xFF,0x00,0xFF,0x01,0xFF,0x00  
	.byte	0xFF,0x01,0xFF,0x00,0x00,0x01,0xFF,0x00,0xFF,0x01,0x00,0x01,0xFF,0x00,0x00,0x01  
	.byte	0xFF,0x01,0x00,0x01,0xFF,0x01,0x00,0x01,0x00,0x01,0xFF,0x01,0x00,0x01,0x00,0x01  
	.byte	0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x01,0x01,0x00,0x01,0x00,0x01,0x01,0x01  
	.byte	0x00,0x01,0x01,0x01,0x00,0x01,0x01,0x00,0x00,0x01,0x01,0x01,0x01,0x00,0x00,0x01  
	.byte	0x01,0x00,0x01,0x01,0x01,0x00,0x01,0x01,0x01,0x00,0x01,0x00,0x01,0x01,0x01,0x00  
	.byte	0x01,0x00,0x01,0x00,0x01,0x00,0x01
