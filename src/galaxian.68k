* Galaxian, amiga 68k transcode

FAST_INTRO_TEXT = 1

* exports

    * ROM

    .global galaxian_irq
    .global galaxian_reset
    .global infinite_lives_flag
    .global invincible_flag
	.global	bg_colorram
	.global	bg_videoram
	.global	vb_ticks_count


	.include "galaxian.inc"

galaxian_reset:
	bra		INITIALISE_SYSTEM

	

invincible_flag:
	.byte	0
infinite_lives_flag:
	.byte	0
vb_ticks_count:
	.byte	0
	
*
* Galaxian (C) 1979 NAMCO.
*
* Reverse engineering work by Scott Tunstall, Paisley, Scotland. 
* Tools used: MAME debugger & Visual Studio Code text editor.
* Date: 7 July 2019.  
* 
* Please send any questions, corrections and updates to scott.tunstall@ntlworld.com
*
* Be sure to check out my reverse engineering work for Robotron 2084 and Scramble too, 
* at http://seanriddle.com/robomame.asm and http://seanriddle.com/scramble.asm asm respectively.
*
* Finally:
* If you'd like to show appreciation for this work by buying me a coffee, feel free: https://ko-fi.com/scotttunstall
* I'd be equally happy if you donated to Parkinsons UK or Chest Heart And Stroke (CHAS) Scotland.
* Thanks.  

/*
Conventions: 

NUMBERS
=======

The term "@ $" means "at memory address in hexadecimal". 
e.g. @ $1234 means "refer to memory address 1234" or "program code @ memory location 1234" 

The term "#$" means "immediate value in hexadecimal". It's a habit I have kept from 6502 days.
e.g. #$60 means "immediate value of 60 hex" (96 decimal)

If I don't prefix a number with $ or #$ in my comments, treat the value as a decimal number.


LABELS
======
I have a labelling convention in place to help you identify the important parts of the code quicker.
Any subroutine labelled with the SCRIPT_ , DISPLAY_ or HANDLE_ prefix are critical "top-level" functions responsible 
for calling a series of "lower-level" functions to achieve a given result.   

If this helps you any, think of the "top level" as the main entry point to code that achieves a specific purpose.  

Routines prefixed HANDLE_ manage a particular aspect of the game.
    For example, HANDLE_PLAYER_MOVE is the core routine for reading the player joystick and moving the player ship. 
    HANDLE_PLAYER_SHOOT is the core routine for reading the player fire button and spawning a bullet.

I expect the purpose of DISPLAY_ is obvious.

SCRIPTS are documented below - see docs for SCRIPT_NUMBER ($4005)


ARRAYS, LISTS, TABLES
=====================

The terms "entry", "slot", "item", "record" when used in an array, list or table context all mean the same thing.
I try to be consistent with my terminology but obviously with a task this size that might not be the case.

Unless I specify otherwise, I all indexes into arrays/lists/tables are zero-based, 
meaning element [0] is the first element, [1] the second, [2] the third and so on.

FLAGS
=====
The terms "Clear", "Reset", "Unset" in a flag context all mean the flag is set to zero.
                                                                               

COORDINATES
===========

X,Y refer to the X and Y axis in a 2D coordinate system, where X is horizontal and Y is vertical.

The Galaxian monitor is rotated 90 degrees. This means that:
a) updating the hardware Y position of a sprite presents itself to the player as changing the horizontal position.
   To make a sprite appear to move left, you would increment its Y position.
   To make a sprite appear to move right, you would decrement its Y position.

b) updating the hardware X position of a sprite presents itself to the player as changing the vertical position. 
   To make a sprite appear to move up, you would decrement its X position.
   To make a sprite appear to move down, you would increment its X position.

So when you see code updating the Y coordinate when you would expect X to be updated, or vice versa, you now know why.

For info about the Galaxian video hardware see: https://github.com/mamedev/mame/blob/master/src/mame/video/galaxian.cpp


Copied from MAME4All documentation: https://github.com/squidrpi/mame4all-pi/blob/master/src/drivers/galaxian.cpp
Some corrections applied from: https://github.com/mamedev/mame/blob/master/src/mame/galaxian/galaxian.cpp

Galaxian/Moon Cresta memory map.
Compiled from information provided by friends and Uncles on RGVAC.

Add 0x4000 to all addresses except for the ROM for Moon Cresta.
            AAAAAA
            111111AAAAAAAAAA     DDDDDDDD   Schem   function
HEX         5432109876543210 R/W 76543210   name
0000-3FFF                                           Game ROM
4000-47FF                                           Working ram
5000-57FF   01010AAAAAAAAAAA R/W DDDDDDDD   !Vram   Character ram           
5800-583F   01011AAAAAAAAAAA R/W DDDDDDDD   !OBJRAM Screen attributes
5840-585F   01011AAAAAAAAAAA R/W DDDDDDDD   !OBJRAM Sprites
5860-5FFF   01011AAAAAAAAAAA R/W DDDDDDDD   !OBJRAM Bullets
6000        0110000000000000 R   -------D   !SW0    coin1
6000        0110000000000000 R   ------D-   !SW0    coin2
6000        0110000000000000 R   -----D--   !SW0    p1 left
6000        0110000000000000 R   ----D---   !SW0    p1 right
6000        0110000000000000 R   ---D----   !SW0    p1shoot
6000        0110000000000000 R   --D-----   !SW0    upright/cocktail
6000        0110000000000000 R   -D------   !SW0    test
6000        0110000000000000 R   D-------   !SW0    service
6000        0110000000000001 W   -------D   !DRIVER lamp 1
6001        0110000000000001 W   -------D   !DRIVER lamp 2
6002        0110000000000001 W   -------D   !DRIVER coin lockout
6003        0110000000000011 W   -------D   !DRIVER coin control
6004        0110000000000100 W   -------D   !DRIVER Background lfo freq bit0
6005        0110000000000101 W   -------D   !DRIVER Background lfo freq bit1
6006        0110000000000110 W   -------D   !DRIVER Background lfo freq bit2
6007        0110000000000111 W   -------D   !DRIVER Background lfo freq bit3
6800        0110100000000000 R   -------D   !SW1    1p start
6800        0110100000000000 R   ------D-   !SW1    2p start
6800        0110100000000000 R   -----D--   !SW1    p2 left
6800        0110100000000000 R   ----D---   !SW1    p2 right
6800        0110100000000000 R   ---D----   !SW1    p2 shoot
6800        0110100000000000 R   --D-----   !SW1    no used
6800        0110100000000000 R   -D------   !SW1    dip sw1
6800        0110100000000000 R   D-------   !SW1    dip sw2
6800        0110100000000000 W   -------D   !SOUND  reset background F1
                                                    (1=reset ?)
6801        0110100000000001 W   -------D   !SOUND  reset background F2
6802        0110100000000010 W   -------D   !SOUND  reset background F3
6803        0110100000000011 W   -------D   !SOUND  player hit
6804        0110100000000100 W   -------D   !SOUND  not used
6805        0110100000000101 W   -------D   !SOUND  shoot on/off
6806        0110100000000110 W   -------D   !SOUND  Vol of f1
6807        0110100000000111 W   -------D   !SOUND  Vol of f2

7000        0111000000000000 R   -------D   !DIPSW  dip sw 3
7000        0111000000000000 R   ------D-   !DIPSW  dip sw 4
7000        0111000000000000 R   -----D--   !DIPSW  dip sw 5
7000        0111000000000000 R   ----D---   !DIPSW  dip s2 6
7001/B000/1 0111000000000001 W   -------D   9Nregen NMIon
7002        Unused - thanks to Phil Murray for letting me know
7003        Unused
7004        0111000000000100 W   -------D   9Nregen stars on  
7006        0111000000000110 W   -------D   9Nregen hflip
7007        0111000000000111 W   -------D   9Nregen vflip
Note: 9n reg,other bits  used on moon cresta for extra graphics rom control.
7800        0111100000000000 R   --------   !wdr    watchdog reset
7800        0111100000000000 W   DDDDDDDD   !pitch  Sound Fx base frequency
*/

/*
DIP SWITCH SETTINGS

Taken from: http://arcarc.xmission.com/PDF_Arcade_Bally_Midway/Galaxian_Parts_and_Operating_Manual_(Feb_1980).pdf

METHOD OF PLAY:
                              SW.1          SW.2
1 COIN = 1 PLAY               OFF           OFF
2 COINS = 1 PLAY              ON            OFF
1 COIN = 2 PLAYS              OFF           ON
FREE PLAY                     ON            ON 


BONUS GALIXIP (PLAYER SHIP) - the manual above is not correct with the Namco Galaxian ROM. After doing some research,
here are the correct DIP switch settings: 


                              SW.3          SW.4
7000                          OFF           OFF  
10000                         ON            OFF
12000                         OFF           ON
20000                         ON            ON


NUMBER OF GALIXIP PER GAME
                               SW.5
2 GALIXIP PER GAME             OFF
3 GALIXIP PER GAME             ON

*/


/*
And now, the main game code.... enjoy.
*/

** variables

VARIABLES_START:
DIP_SWITCH_1_2_STATE:                |  $4000         ; holds state of dip switches 1 & 2 in bits 0 & 1.
	ds.b	0x01
COIN_COUNT:                          |  $4001         ; counts up to number of coins per credit as set by dip switches. When it reaches that value, resets to 0 
	ds.b	0x01
NUM_CREDITS:                         |  $4002         ; number of credits
	ds.b	0x01
COIN_CONTROL:                        |  $4003         ; is used to output to DRIVER|COIN CONTROL (see $1974)
	ds.b	0x01
UNPROCESSED_COINS:                   |  $4004         ; bumps up when coin inserted. See $190B and $1931.

*
* The game follows what I call "scripts". A SCRIPT is a predefined sequence of STAGES (ie: subroutines) that implement an overall goal.
* The whole game is script-driven, from attract mode to the game itself.
*
* The NMI interrupt handler uses SCRIPT_NUMBER ($4005) to identify what script to run and, depending on the script, SCRIPT_STAGE ($400A) to 
* determine what subroutine to call to do the work for that stage of the script.  When the subroutine has completed its work, 
* it increments SCRIPT_STAGE which is akin to, "OK, I'm done; proceed to next stage of script".
*
* For example, a script for HELLO WORLD might be implemented as three stages:
* 1. Display Hello World on screen. Set SCRIPT_STAGE to 2.
* 2. Wait for key. Set SCRIPT_STAGE to 3 after key pressed.
* 3. Terminate program.
*
* When I've finished working out what all the scripts do, I'll replace the Hello World above with a real example from the game.
*
*
* The main take-aways from the above are:
* 1. The whole game is driven by the NMI interrupt.
* 2. Script stage and number are really just indexes into jump tables. 
*
* see $00CA for the NMI script handler. 

	ds.b	0x01
SCRIPT_NUMBER:                       |  $4005         ; 0-based index into pointer table beginning @ $00CE
	ds.b	0x01
IS_GAME_IN_PLAY:                     |  $4006         ; If set to 1, game is in play with a human in control.
	ds.b	0x01
IS_GAME_OVER:                        |  $4007         ; Set to 1 when GAME OVER message appears. TODO: Check if set any other place than GAME OVER 
	ds.b	0x01
TEMP_COUNTER_1:                      |  $4008         ; temporary counter used for delays, such as waiting before transitioning to next stage of a script
	ds.b	0x01
TEMP_COUNTER_2:                      |  $4009         ; temporary counter used for delays								 |
	ds.b	0x01
SCRIPT_STAGE:                        |  $400A         ; Identifies what stage of the script we are at.  
                                     |                ; 0-based index into script tables located @ $0164, $0400, $0540, $0785
	ds.b	0x01
	.align	2
TEMP_CHAR_RAM_PTR:                   |  $400B         ; pointer to character RAM. Used by screen-related routines (e.g. power on colour test) to remember where to plot characters on next call.                                   |                                                                     
	.word	0
CURRENT_PLAYER:                      |  $400D         ; 0 = PLAYER ONE, 1 = PLAYER TWO
	ds.b	0x01
IS_TWO_PLAYER_GAME:                  |  $400E         ; 0 = One player game, 1 = 2 player game 
	ds.b	0x01
IS_COCKTAIL:                         |  $400F         ; 0 = upright, 1 = Cocktail 
	ds.b	0x01
PORT_STATE_6000:                     |  $4010         ; copy of state for memory address 6000 (SW0)          
	ds.b	0x01
PORT_STATE_6800:                     |  $4011         ; copy of state for memory address 6800 (SW1 & SOUND)
	ds.b	0x01
PORT_STATE_7000:                     |  $4012         ; copy of state for memory address 7000 (DIPSW)
	ds.b	0x01
PREV_PORT_STATE_6000:                |  $4013         ; holds the previous state of memory address 6000 (SW0)  
	ds.b	0x01
PREV_PORT_STATE_6800:                |  $4014         ; holds the previous state of memory address 6800 (SW1 & SOUND)
	ds.b	0x01
PREV_PREV_PORT_STATE_6000:           |  $4015         ; holds the previous, previous (!) state of memory address 6000 (SW0) 
	ds.b	0x01
PREV_PREV_PREV_STATE_6000:           |  $4016         ; holds the previous, previous, previous state of memory address 6000 (SW0)
									 |
	ds.b	0x02
DISPLAY_IS_COCKTAIL_P2:              |  $4018         ; set to 1 when in cocktail mode and it's player 2's turn, so the screen's upside down.
	ds.b	0x01
PUSH_START_BUTTON_COUNTER:           |  $4019         ; On inserting credit or GAME OVER: if you have credit, how long to wait before PUSH START BUTTON appears.  
	ds.b	0x01
DIAGNOSTIC_MESSAGE_TYPE:             |  $401A         ; Read by the NMI handler. Refer to code @1BCD for docs.  
									 |
	ds.b	0x04
RAND_NUMBER:                         |  $401E         ; TENTATIVE NAME. Random number used in tests and in-game 
	ds.b	0x01
DIP_SWITCH_5_STATE:                  |  $401F         ; holds cached state of dip switch 5 in bit 0

* Object RAM back buffer. 
* Colour attributes, scroll offsets and sprite state are held in this buffer and updated by the game. 
* When all the updates are complete and ready to be presented on screen to the player, 
* the back buffer is copied to the hardware's OBJRAM by an LDIR operation - see $0079.
* Effectively all colours, scroll and sprites are updated as part of a single operation.
* This back buffering technique is still used today in modern games.
*
* The back buffer is organised thus:
*
* From $4020 - 405f: column scroll and colour attributes. Maps directly to $5800 - $583F. 
*    Note: Even numbered addresses hold scroll offsets, odd numbered addresses colour attributes. 
* From $4060 - 407F: 8 entries of type INFLIGHT_ALIEN_SPRITE. Maps directly to $5840 - $585F.
* From $4080 - 409F: alien bullets and player bullet sprite state. Maps directly to $5860 - $587F. 

	ds.b	0x01
OBJRAM_BACK_BUF:                     |  $4020            
	ds.b	0x40
OBJRAM_BACK_BUF_SPRITES:             |  $4060 

*struct INFLIGHT_ALIEN_SPRITE
*{
*   BYTE Y;                      
*   BYTE Code;                   * bits 0..5: sprite frame. bit 6 set = XFlip. bit 7 set = YFlip
*   BYTE Colour;
*   BYTE X;                      
*} - sizeof(INFLIGHT_ALIEN_SPRITE) is 4 bytes


	ds.b	0x20
OBJRAM_BACK_BUF_BULLETS:             |  $4080
	ds.b	0x1d
OBJRAM_BUF_PLAYER_BULLET_Y:          |  $409D
	ds.b	0x02
OBJRAM_BUF_PLAYER_BULLET_X:          |  $409F
OBJRAM_BACK_BUF_END:                 |  $409F                        

	ds.b	0x01
	.align	2
CIRC_CMD_QUEUE_PTR:           		|  $40A0             ; pointer to a (hopefully) vacant entry in the circular queue. See $08F2 
	.long	0
CIRC_CMD_QUEUE_PROC:          |  $40A1             ; (low byte of a ) pointer to the next entry in the circular queue to be processed. See $200C
	.long	0
PLAYER_ONE_SCORE:                      |  $40A2       | stored as 3 BCD bytes, 2 digits per byte: $40A2 = last 2 digits of score (tens), $40A3 = 3rd & 4th digits, $40A4 = 1st & 2nd

                                                      | e.g. a score of 123456 would be stored like so:
                                                      | $40A2: 56
                                                      | $40A3: 34
                                                      | $40A4: 12
													  |
	ds.b	0x03
PLAYER_TWO_SCORE:                      |  $40A5       | stored as 3 BCD bytes, 2 digits per byte: same format & order as PLAYER_ONE_SCORE
	ds.b	0x03
HI_SCORE:                              |  $40A8       | ; stored as 3 BCD bytes, 2 digits per byte: same format & order as PLAYER_ONE_SCORE
													  |
	ds.b	0x03
CAN_BLINK_1UP_2UP:                     |  $40AB       | ; When IS_GAME_IN_PLAY is set to 1, this flag is set to 1 to allow 1UP or 2UP to "blink". See @$20A7
	ds.b	0x01
BONUS_GALIXIP_FOR:                     |  $40AC       | ; stored as BCD in 1 byte. e.g. 07 = bonus galixip for 7000, 20 = bonus galixip for 20000. 
	ds.b	0x01
PLAYER_ONE_AWARDED_EXTRA_LIFE:         |  $40AD       | Set to 1 if player one has been awarded an extra life. No more extra lives will be given. 
	ds.b	0x01
PLAYER_TWO_AWARDED_EXTRA_LIFE:         |  $40AE       | Set to 1 if player two has been awarded an extra life. No more extra lives will be given. 
													  |
													  |
	ds.b	0x02
IS_COLUMN_SCROLLING:                 |  $40B0         | Set to 1 if a column is being scrolled. For example when points are scrolled into view on the WE ARE THE GALAXIANS screen
	ds.b	0x01
	.align	2
COLUMN_SCROLL_ATTR_BACKBUF_PTR:      |  $40B1         | pointer to scroll attribute data to update in OBJRAM_BACK_BUF. 
	.word	0
COLUMN_SCROLL_NEXT_CHAR_PTR:         |  $40B3         | pointer to ordinal of next character to scroll on
	.word	0
COLUMN_SCROLL_CHAR_RAM_PTR:          |  $40B5         | pointer to character RAM where next character will be plotted. 
	.word	0

* Phil Murray (PhilMurr on UKVAC) gave me a heads up on this.  
*
* $40C0 to $40FF is reserved for a circular queue. The queue is comprised of byte pairs representing a command and parameter.
* NB: I term the byte pair a *Queue Entry* in the code @$08f2 and $200A.
*
* As 64 bytes are reserved for the queue, that means 32 commands and parameters can be stored. 
*
* The memory layout of the queue is quite simple.
* 
* $40C0: command A
* $40C1: parameter for command A 
* $40C2: command B
* $40C3: parameter for command B
* $40C4: command C
* $40C5: parameter for command C
* ..and so on.
*
* See docs @ $08f2 for info about what commands are available, and how to add commands to the queue.
* See docs @ $200A for info about how commands are processed.
*


	.align	2
CIRC_CMD_QUEUE_START:            |  $40C0
	ds.b	0x40
CIRC_CMD_QUEUE_END:              |  $4100


*
* ALIEN_SWARM_FLAGS (name subject to change) is an array 128 bytes in size.   
* Each byte contains a bit flag indicating the presence of an alien at a given position.
* If you start a new game in MAME, then open the debugger and view memory location 4100 (hex) you will see this:
*
* 4100:  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  
* 4110:  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  
* 4120:  00 00 00 01 01 01 01 01 01 01 01 01 01 00 00 00  
* 4130:  00 00 00 01 01 01 01 01 01 01 01 01 01 00 00 00  
* 4140:  00 00 00 01 01 01 01 01 01 01 01 01 01 00 00 00  
* 4150:  00 00 00 00 01 01 01 01 01 01 01 01 00 00 00 00  
* 4160:  00 00 00 00 00 01 01 01 01 01 01 00 00 00 00 00  
* 4170:  00 00 00 00 00 00 01 00 00 01 00 00 00 00 00 00     
*
* This is the representation of the swarm in memory! 01 means "an alien is here" and 00 means "nothing here".
* The memory representation is upside down *and* flipped horizontally.  
*
* To visualise it properly, turn the dump above upside down using your favourite text editor, erase the "00"s and you get:
* 4170:                    01       01                       ; flagships
* 4160:                 01 01 01 01 01 01                    ; red
* 4150:              01 01 01 01 01 01 01 01                 ; purple
* 4140:           01 01 01 01 01 01 01 01 01 01              ; blue
* 4130:           01 01 01 01 01 01 01 01 01 01              ; blue
* 4120:           01 01 01 01 01 01 01 01 01 01              ; blue
* 
* Look familiar? 
*
*  

ALIEN_SWARM_FLAGS:                   *  $4100         ; 128 bytes, occupying $4100 to $417F in RAM


* When it's player 1's turn, the packed swarm definition PLAYER_ONE_PACKED_SWARM_DEF is unpacked to ALIEN_SWARM_FLAGS and the fields comprising PLAYER_ONE_STATE ($4190-4197) 
* are written to their counterparts in CURRENT_PLAYER_STATE (see docs @$4218)                
	ds.b	0x81
PLAYER_ONE_PACKED_SWARM_DEF:           |  $4180       ; Used to track state of the swarm for player one, e.g. so swarm can be restored after player two's turn is over 
	ds.b	0x10
PLAYER_ONE_STATE:                      |  $4190
PLAYER_ONE_DIFFICULTY_COUNTER_1:       |  $4190         
	ds.b	0x01
PLAYER_ONE_DIFFICULTY_COUNTER_2:       |  $4191
	ds.b	0x01
PLAYER_ONE_DIFFICULTY_EXTRA_VALUE:     |  $4192           
	ds.b	0x01
PLAYER_ONE_DIFFICULTY_BASE_VALUE:      |  $4193         
	ds.b	0x01
PLAYER_ONE_LEVEL:                      |  $4194
	ds.b	0x01
PLAYER_ONE_LIVES:                      |  $4195
	ds.b	0x01
PLAYER_ONE_FLAGSHIP_SURVIVOR_COUNT:    |  $4196         
	ds.b	0x01
PLAYER_ONE_LFO_FREQ_BITS:              |  $4197         


* When it's player 2's turn, the packed swarm definition PLAYER_TWO_PACKED_SWARM_DEF is unpacked to ALIEN_SWARM_FLAGS and the fields comprising PLAYER_TWO_STATE ($41B0-41B7) 
* are written to their counterparts in CURRENT_PLAYER_STATE (see docs @$4218)                
	ds.b	0x09
PLAYER_TWO_PACKED_SWARM_DEF:           |  $41A0       ; Used to track state of the swarm for player two, e.g. so swarm can be restored after player one's turn is over
	ds.b	0x10
PLAYER_TWO_STATE:                      |  $41B0
PLAYER_TWO_DIFFICULTY_COUNTER_1:       |  $41B0         
	ds.b	0x01
PLAYER_TWO_DIFFICULTY_COUNTER_2:       |  $41B1
	ds.b	0x01
PLAYER_TWO_DIFFICULTY_EXTRA_VALUE:     |  $41B2           
	ds.b	0x01
PLAYER_TWO_DIFFICULTY_BASE_VALUE:      |  $41B3         
	ds.b	0x01
PLAYER_TWO_LEVEL:                      |  $41B4
	ds.b	0x01
PLAYER_TWO_LIVES:                      |  $41B5
	ds.b	0x01
PLAYER_TWO_FLAGSHIP_SURVIVOR_COUNT:    |  $41B6         
	ds.b	0x01
PLAYER_TWO_LFO_FREQ_BITS:              |  $41B7         


	ds.b	0x09
SOUND_VOL:                           |  $41C0         ; Bit 0 and 1 are written to !SOUND Vol of F1 and !SOUND Vol of F2 respectively. See $1712
	ds.b	0x01
PITCH_SOUND_FX_BASE_FREQ:            |  $41C1         ; used to write to !pitch  Sound Fx base frequency. See $171F
	ds.b	0x01
ENABLE_ALIEN_ATTACK_SOUND:           |  $41C2         ; When set to 1, turns on alien attack noise, see $17D0
	ds.b	0x01
UNKNOWN_SOUND_41C3:                  |  $41C3          
	ds.b	0x01
UNKNOWN_SOUND_41C4:                  |  $41C4         ; Seems to affect the pitch of the alien attack noise. 
									 |
	ds.b	0x03
PLAY_EXTRA_LIFE_SOUND:               |  $41C7         ; when set to 1, play the sound of an extra life being awarded. See $184F
	ds.b	0x01
EXTRA_LIFE_SOUND_COUNTER:            |  $41C8            
	ds.b	0x01
PLAY_PLAYER_CREDIT_SOUND:            |  $41C9         ; when set to 1, play the sound of player credits being added. See $1876
	ds.b	0x01
PLAYER_CREDIT_SOUND_COUNTER:         |  $41CA         ; The higher the value, the longer the player credit sound plays.:
                                     |  $41CB          
	ds.b	0x02
PLAY_PLAYER_SHOOT_SOUND:             |  $41CC         ; When set to 1, play the sound of the player's bullet. See $1723
	ds.b	0x01
IS_COMPLEX_SOUND_PLAYING:            |  $41CD         ; When set to 1, a sequence of sounds, or a melody, is playing. 
	ds.b	0x01
PLAYER_SHOOT_SOUND_COUNTER:          |  $41CE         ; The higher the value, the longer the player spaceship bullet sound plays.:
                                     |  $41CF 
	ds.b	0x02
RESET_SWARM_SOUND_TEMPO:             |  $41D0         ; When set to 1, resets the tempo of the "swarm" sound to slow again. See $1898
	ds.b	0x01
PLAY_GAME_START_MELODY:              |  $41D1         ; When set to 1, plays the game start tune.: 
                                     |  $41D2         ; sound related
	ds.b	0x02
COMPLEX_SOUND_POINTER:               |  $41D3         ; If music or complex sound effect is playing, this points to the current sound/musical note being played. See $1782:
                                     |  $41D5         ; Used to set !Pitch Sound FX base frequency
	ds.b	0x03
DELAY_BEFORE_NEXT_SOUND:             |  $41D6         ; counter. When counts to zero the next sound/musical note is played. See $177B
	ds.b	0x09
ALIEN_DEATH_SOUND:                   |  $41DF         ; Tentative name. When set to $06: plays alien death sound. When set to $16, plays flagship death sound. See @$1819:
                                     |  $41E8

* HAVE_ALIENS_IN_ROW_FLAGS is an array of 6 bytes. Each byte contains a bit flag specifying if there are any aliens on a given row.
	ds.b	0x09
HAVE_ALIENS_IN_ROW_FLAGS:            |  $41E8
NEVER_USED_ROW_1:                    |  $41E8
	ds.b	0x01
NEVER_USED_ROW_2:                    |  $41E9

	ds.b	0x01
HAVE_ALIENS_IN_6TH_ROW:              |  $41EA         ; flag set to 1 if there are any aliens in the bottom row (blue aliens)
	ds.b	0x01
HAVE_ALIENS_IN_5TH_ROW:              |  $41EB         ; flag set to 1 if there are any aliens in the 5th row (blue aliens)
	ds.b	0x01
HAVE_ALIENS_IN_4TH_ROW:              |  $41EC         ; flag set to 1 if there are any aliens in the 4th row (blue aliens)
	ds.b	0x01
HAVE_ALIENS_IN_3RD_ROW:              |  $41ED         ; flag set to 1 if there are any aliens in the 3rd row (purple aliens)
	ds.b	0x01
HAVE_ALIENS_IN_2ND_ROW:              |  $41EE         ; flag set to 1 if there are any aliens in the 2nd row (red aliens)
	ds.b	0x01
HAVE_ALIENS_IN_TOP_ROW:              |  $41EF         ; flag set to 1 if there are any aliens in the top row (flagships)


* ALIEN_IN_COLUMN_FLAGS is an array 16 bytes in size. Each byte contains a bit flag specifying if there are any aliens in a specific column. 
* IMPORTANT: The flags are ordered from rightmost column of aliens to the leftmost. Only 10 of the flags are used.
* 
* In a nutshell:
* $41F0..$41F2: unused. Always set to 0.
* $41F3: set to 1 if any aliens are in the rightmost column of the swarm.
* $41F4: set to 1 if any aliens are in the 2nd rightmost column of the swarm.
* $41F5: set to 1 if any aliens are in the 3rd rightmost column of the swarm.
* ..
* $41FC: set to 1 if any aliens are in the leftmost column of the swarm.
* $41FD..$41FF: unused. Always set to 0.
*
* The flags have three purposes: 
* 1: To halt the swarm when a bullet is getting too close (see $0936)
* 2: to calculate how far the swarm can scroll before it needs to change direction (see $093E)
* 3: to find aliens at the swarm edges to attack the player (see code from $137B onwards) 
*
*
* To further clarify in case there's any confusion, let's assume you've just started the game and you're on the first level. 
* You haven't shot anything yet. The alien swarm will be in the following formation:
*
*      F  F                     F = Flagship row  
*     RRRRRR                    R = Red alien row
*    PPPPPPPP                   P = Purple alien row
*   BBBBBBBBBB                  B = Blue alien row
*   BBBBBBBBBB
*   BBBBBBBBBB 
*
* Press PAUSE in MAME and open the memory debugger at location $41F0.
* The flags will look like so in the MAME memory window:
* 00 00 00 01 01 01 01 01 01 01 01 01 01 00 00 00
*
* You'll note that there are 10 flags set to TRUE (01) in a row. That is because the bottommost row has 10 blue aliens. 
* If you were to shoot the blue aliens in the rightmost column, you would see the first 01 (at memory address $41F3) turn into a 0, 
* meaning that column no longer contains any aliens. 
* 
* 0 is also written to the flags when the only alien in a column breaks off from the swarm to attack the player.
* 
                                           
	ds.b	0x01
ALIEN_IN_COLUMN_FLAGS:               |  $41F0          
	ds.b	0x0f
ALIEN_IN_COLUMN_FLAGS_END:           |  $41FF     


	ds.b	0x01
HAS_PLAYER_SPAWNED:                  |  $4200         | set to 1 when player has spawned. (Also set in attract mode) 
	ds.b	0x01
IS_PLAYER_DYING:                     |  $4201         | set to 1 when player is in the process of exploding horribly. See $1327
	ds.b	0x01
PLAYER_Y:                            |  $4202         | Player Y coordinate. Used to set scroll offsets for column containing ship characters. See $0865
													  |
	ds.b	0x02
IS_PLAYER_HIT:                       |  $4204         | When set to 1, player has been hit by a missile or collided with an alien.         
	ds.b	0x01
PLAYER_EXPLOSION_COUNTER:            |  $4205         | Only evaluated when IS_PLAYER_DYING is set to 1. Determines how long the player explosion animation lasts. 
                                                      | When it counts down to 0, explosion animation stops. See $132C
	ds.b	0x01
PLAYER_EXPLOSION_ANIM_FRAME:         |  $4206         | Set by $12FE 
	ds.b	0x02
HAS_PLAYER_BULLET_BEEN_FIRED:        |  $4208         | set 1 when the player has fired a bullet and the bullet is still onscreen. See $08BC
	ds.b	0x01
PLAYER_BULLET_X:                     |  $4209         | Current X coordinate of player bullet. 
	ds.b	0x01
PLAYER_BULLET_Y:                     |  $420A         | Current Y coordinate of player bullet. 
	ds.b	0x01
IS_PLAYER_BULLET_DONE:               |  $420B         | set 1 when player bullet goes as far as it can upscreen (see $08CD), or hits an alien (see $0B4F & $125B).
													  |
	ds.b	0x02
SWARM_DIRECTION:                     |  $420D         | Direction of swarm (really? ;) )  0 = Moving left, 1 = moving right . See $0945              
	ds.b	0x01
SWARM_SCROLL_VALUE:                  |  $420E         | 16 bit value. Used to set the scroll values for the character columns containing the swarm.                            
	ds.b	0x02
SWARM_SCROLL_MAX_EXTENTS:            |  $4210         | Used to limit the scrolling of the swarm so no alien goes "off screen". See $09CE 

* INFLIGHT_ALIEN_SHOOT_EXACT_X and MINFLIGHT_ALIEN_SHOOT_RANGE_MUL are used to determine if an alien can shoot a bullet. See $0E54 for information.
	ds.b	0x03
INFLIGHT_ALIEN_SHOOT_RANGE_MUL:      |  $4213         ; Range multiplier.   
	ds.b	0x01
INFLIGHT_ALIEN_SHOOT_EXACT_X:        |  $4214         ; Exact X coordinate that calculated value must match for alien to shoot.

	ds.b	0x01
ALIENS_ATTACK_FROM_RIGHT_FLANK:      |  $4215         ; Flag used to determine what side of swarm aliens break off from. (0=break from left, 1=break from right). See $136f and $1426: 
                                     |  $4217         ; 

* $4218 - $421F holds important, albeit transient, state for the current player such as number of lives and difficulty level.
	ds.b	0x03
CURRENT_PLAYER_STATE:                |  $4218                    

* These 2 counters are used to gradually increase the DIFFICULTY_EXTRA_VALUE over time. See $14F3 for algorithm details.
DIFFICULTY_COUNTER_1:                |  $4218         ; Counts down to zero. 
	ds.b	0x01
DIFFICULTY_COUNTER_2:                |  $4219         ; Counts down to zero. When it reaches zero, DIFFICULTY_EXTRA_VALUE is incremented.

* These values determine how often aliens attack (see $1524 and $1583), and how many can attack at one time (see $1352). 
	ds.b	0x01
DIFFICULTY_EXTRA_VALUE:              |  $421A         ; DIFFICULTY_EXTRA_VALUE is incremented during the level. Maximum value of 7. See $1509.  
	ds.b	0x01
DIFFICULTY_BASE_VALUE:               |  $421B         ; DIFFICULTY_BASE_VALUE is incremented when you complete a level. Maximum value of 7. See $1656.

	ds.b	0x01
PLAYER_LEVEL:                        |  $421C         ; Current player's level. Starts from 0. Add 1 to get true value. See $252C.
	ds.b	0x01
PLAYER_LIVES:                        |  $421D         ; current player's lives
	ds.b	0x01
FLAGSHIP_SURVIVOR_COUNT:             |  $421E         ; When starting a new level, how many surviving flagships can we bring over from the previous level? Maximum value 2.  See $166C
	ds.b	0x01
LFO_FREQ_BITS:                       |  $421F         ; Value used to set !DRIVER Background lfo frequency ports (0-3) for the "swarm" noise

CURRENT_PLAYER_STATE_END:            |  $421F                

	ds.b	0x01
HAVE_NO_ALIENS_IN_SWARM:             |  $4220         ; Set to 1 when $4100 - $417F are set to 0. Aliens are either all dead, or are in flight and out of the swarm. See $0A0F
	ds.b	0x01
HAVE_NO_BLUE_OR_PURPLE_ALIENS:       |  $4221         ; When set to 1, all the blue and purple aliens have died, or are in flight. See $09FA and $1571  
	ds.b	0x01
LEVEL_COMPLETE:                      |  $4222         ; When set to 1, the level is treated as complete. See @$1621, $1637
	ds.b	0x01
NEXT_LEVEL_DELAY_COUNTER:            |  $4223         ; After all aliens have fled or been killed, this counts down to give the player breathing space. When it hits 0, the next wave starts. See $1637
	ds.b	0x01
HAVE_AGGRESSIVE_ALIENS:              |  $4224         ; when set to 1, inflight aliens will not return to swarm and keep attacking player until they die - or you die. See $16B8
	ds.b	0x01
HAVE_NO_INFLIGHT_OR_DYING_ALIENS:    |  $4225         ; When set to 1, there are no aliens inflight, or dying. See $06BC
	ds.b	0x01
HAVE_NO_INFLIGHT_ALIENS:             |  $4226         ; When set to 1, no aliens have broken off from the swarm to attack the player.
	ds.b	0x02
CAN_ALIEN_ATTACK:                    |  $4228         ; When set to 1, a single alien should break off from the swarm to attack the player. See $1344.
	ds.b	0x01
CAN_FLAGSHIP_OR_RED_ALIENS_ATTACK:   |  $4229         ; When set to 1, a flagship should attack the player, with an escort if possible. If no flagships alive, send red aliens.  See $140C.
	ds.b	0x01
FLAGSHIP_ESCORT_COUNT:               |  $422A         ; Number of red aliens escorting the flagship. Max value of 2. See $0D58.

* When you shoot an enemy flagship in flight that this puts the aliens into a state of "shock" where they are afraid to leave the swarm for a while.
* No aliens will leave the swarm while $422B is set to 1 and $422C is non-zero. 
	ds.b	0x01
IS_FLAGSHIP_HIT:                     |  $422B         ; Set to 1 when you've shot a flagship in flight. See $127C  
	ds.b	0x01
ALIENS_IN_SHOCK_COUNTER:             |  $422C         ; When $422B is set to 1, this counter decrements. When it hits 0, $422B will be set to 0, meaning aliens can leave the swarm again.  
	ds.b	0x01
FLAGSHIP_SCORE_FACTOR:               |  $422D         ; When you shoot a flagship, this is used to compute your score. Couldn't think of a better name! See $127C

	ds.b	0x01
ENABLE_FLAGSHIP_ATTACK_SECONDARY_COUNTER:      |  $422E         ; when set to 1, FLAGSHIP_ATTACK_SECONDARY_COUNTER is allowed to decrement.             
	ds.b	0x01
FLAGSHIP_ATTACK_SECONDARY_COUNTER:   |  $422F         ; Counts down to 0. When reaches zero, CAN_FLAGSHIP_OR_RED_ALIENS_ATTACK will be set to 1.

	ds.b	0x09
DISABLE_SWARM_ANIMATION:             |  $4238         ; When set to 1, alien swarm won't animate. See $2067 for docs. 
	ds.b	0x07
ATTRACT_MODE_FAKE_CONTROLLER:        |  $423F         ; used to simulate a players movements on the ATTRACT MODE screen. Contains bit values that map to SW0.
	ds.b	0x02
ATTRACT_MODE_SCROLL_ID:              |  $4241         ; Identifies what points values are being scrolled in on attract mode. 1:Flagship. 2: Red Alien. 3: Purple alien. 4: Blue alien. 

* These 2 counters are used to determine when a flagship is permitted to attack.  See $156A.
	ds.b	0x04
FLAGSHIP_ATTACK_MASTER_COUNTER_1:    |  $4245          
	ds.b	0x01
FLAGSHIP_ATTACK_MASTER_COUNTER_2:    |  $4246          

* ALIEN_ATTACK_COUNTERS is an array of BYTE counters that control when aliens (but not flagships) break off from the swarm to attack. 
* ALIEN_ATTACK_MASTER_COUNTER at $424A is the first element of the array. The secondary counters are stored in $424B to $425A. 
* The ALIEN_ATTACK_MASTER_COUNTER acts as a gateway to the secondary counters; only when the master counter reaches zero will the secondary counters in the array be decremented.
* If any of the secondary counters reach zero, an alien will attack the player. See $1532 for more info.
	ds.b	0x04
ALIEN_ATTACK_COUNTERS:               |  $424A  
ALIEN_ATTACK_MASTER_COUNTER:         |  $424A
	ds.b	0x11
ALIEN_ATTACK_SECONDARY_COUNTERS:     |  $425B         
	ds.b	0x04
ALIEN_ATTACK_SECONDARY_COUNTERS_END: |  $425F     


TIMING_VARIABLE:                     |  $425F         ; Perpetually decremented by the NMI handler. Routines use this variable to determine when to execute.
                                                         

* ENEMY_BULLETS is an array of type ENEMY_BULLET. 
*
* The array occupies memory locations $4260 - $42A5; It is thus 70 bytes in size. 
* As an ENEMY_BULLET record only requires 5 bytes, this means that there's room for 14 enemy bullets in the array.
*

* struct ENEMY_BULLET

*IsActive = 0
*X = 1
*YL = 2                                       | low byte of the Y coordinate. Used to represent "fractional part" of Y coordinate
*YH = 3                                       | high byte of the Y coordinate.  
*YDelta = 4                                   | packed delta to add to YH *and* YL. Bit 7 = sign bit. Bits 0-6 = delta. See @$0AA1.                                  
* - sizeof(ENEMY_BULLET) is 5 bytes

	ds.b	0x01
ENEMY_BULLETS:                       |  $4260
ENEMY_BULLETS_START:                 |  $4260                                                                        
	ds.b	0x45
ENEMY_BULLETS_END:                   |  $42A5

	* macro to stop program with a direct error code
	* when using whdload (amiga)
	.macro	TODOM	item
	tst.l	0xFF000000+\item
	.endm
	
* INFLIGHT_ALIENS is an array of type INFLIGHT_ALIEN. 
* An "Inflight alien" is my term for an alien that has broken off from the main swarm body to attack the player. 
*
* The array occupies memory locations $42B0 - $43AF; It is thus 256 bytes in size. 
* As the INFLIGHT_ALIEN type is 32 bytes in size, this means that there's room for 8 entries in the array. 
*
* Slot 0 in the array is actually reserved for misc use, such as when you shoot an alien in the swarm body and an 
* explosion animation needs a free sprite to play. (See: $0B52 for an example of this)
*
* Slot  1 is reserved for the flagship. 
* Slots 2 and 3 are reserved for the flagship's escorts.
* Slots 4,5,6,7 are reserved for individual attacking aliens.
*
* This means there can be 7 aliens in flight maximum. 
*
*  

*
* struct INFLIGHT_ALIEN

IsActive              = 0x0            | Set to 1 when the alien is to be processed. 
IsDying               = 0x1            | Set to 1 when the alien is in the process of exploding.
StageOfLife           = 0x2            | See $0CD6 for details. 
inf_alien_X                     = 0x3            | X coordinate
inf_alien_Y                     = 0x4            | Y coordinate. 
AnimationFrame        = 0x5            |
ArcClockwise          = 0x6            | Set to 1 if the alien will rotate clockwise as it leaves the swarm or loops the loop. See $0D71 and $101F
IndexInSwarm          = 0x7            | index of alien within ALIEN_SWARM_FLAGS array
PivotYValue           = 0x9            | When alien is attacking, this value + $19 produces INFLIGHT_ALIEN.Y coordinate. See $0DF6
AnimFrameStartCode    = 0xF            | Base animation frame number to which a number is added to compute sprite "code"
TempCounter1          = 0x10           | Counter used for various timing purposes
TempCounter2          = 0x11           | Secondary counter for various timing purposes
DyingAnimFrameCode    = 0x12           | when IsDying is set to 1, specifies the animation frame to display. See @$0C9F
ArcTableLsb           = 0x13           | LSB of pointer into INFLIGHT_ALIEN_ARC_TABLE @$1E00. See docs @$0D71 and $1E00.
Colour                = 0x16           |
SortieCount           = 0x17           | Number of times the alien has reached the bottom of the screen then resumed attack on the player. Reset to 0 when rejoins swarm. See $0E9D.
Speed                 = 0x18           | Value from 0..3. The higher the number the faster the alien moves. See $116B. 
PivotYValueAdd        = 0x19           | Signed number which is added to INFLIGHT_ALIEN.PivotYValue to produce INFLIGHT_ALIEN.Y. See $0DF6

inflight_alien_size   = 0x20
          
*  - sizeof(INFLIGHT_ALIEN) is 32 bytes


	ds.b	0x0b
	.align	2
INFLIGHT_ALIENS:                     |  $42B0
	ds.b	inflight_alien_size*8
INFLIGHT_ALIENS_END:                 |  $43B0
VARIABLES_END:

	.align	0x100
bg_videoram:
CHARACTER_RAM:						| $5000
	ds.b	0x800
bg_colorram:
ATTRIBUTE_RAM:						| $5800
	ds.b	0x800

* start of code

*
* A very primitive pseudo-random number generator.
* (seems that it just multiplies by 5, adds 1 and wraps)
*

GENERATE_RANDOM_NUMBER:
	move.b	RAND_NUMBER(pc),d0
	move.b	d0,d1
	add.b	d0,d0
	add.b	d0,d0
	add.b	d0,d1
	addq.b	#1,d0
	move.b	d0,RAND_NUMBER
	rts

galaxian_irq:
*TODO
* update screen in one go - IMPORTANT
*0079: 21 20 40      ld   hl,0x4020            | pointer to OBJRAM_BACK_BUF buffer held in RAM
*007C: 11 00 58      ld   de,0x5800            | start of screen attribute RAM
*007F: 01 80 00      ld   bc,0x0080            | number of bytes to copy from OBJRAM_BACK_BUF 
*0082: ED B0         ldir                     | update screen & sprites in one go

* read ports and stash values read in RAM
*0084: 3A 00 78      ld   a,(0x7800)           | kick the watchdog
*0087: 3A 15 40      ld   a,(0x4015)           | read previous, previous state of port 6000 (SW0)
*008A: 32 16 40      ld   (0x4016),a           | and write to PREV_PREV_PREV_STATE_6000 
*008D: 3A 13 40      ld   a,(0x4013)           | read previous state of port 6000 (SW0)
*0090: 32 15 40      ld   (0x4015),a           | and write to PREV_PREV_PORT_STATE_6000  
*0093: 2A 10 40      ld   hl,(0x4010)          | read state of 6000 (SW0) and 6800 (SW1 & SOUND)
*0096: 22 13 40      ld   (0x4013),hl          | and write to previous state value
*0099: 3A 00 70      ld   a,(0x7000)           | read state of DIPSW
*009C: 32 12 40      ld   (0x4012),a           | and write to PORT_STATE_7000 holder
*009F: 3A 00 68      ld   a,(0x6800)           | read start button, p2 control, dipsw 1/2 state 
*00A2: 32 11 40      ld   (0x4011),a           | and write to PORT_STATE_6800 holder
*00A5: 3A 00 60      ld   a,(0x6000)           | read coin, p1 control, test & service state
*00A8: 32 10 40      ld   (0x4010),a           | and write to PORT_STATE_6000 holder

		subq.b	#1,TIMING_VARIABLE             | decrement value

*		jbsr CHECK_IF_COIN_INSERTED               | 
*jbsr HANDLE_UNPROCESSED_COINS
*jbsr HANDLE_SOUND
*jbsr HANDLE_SWARM_SOUND
*jbsr HANDLE_TEXT_SCROLL

* invoke script [SCRIPT_NUMBER]
	moveq	#0,d0
	move.b	SCRIPT_NUMBER(pc),d0
	add.w	d0,d0
	add.w	d0,d0
	lea		SCRIPT_TABLE(pc),a0
	move.l	(a0,d0.w),a0
	jmp		(a0)
	

SCRIPT_TABLE:
     .long	SCRIPT_ZERO   
     .long	SCRIPT_ONE
     .long	SCRIPT_TWO
     .long	SCRIPT_THREE
     .long	SCRIPT_FOUR
	

SCRIPT_ZERO:
		move.w	TEMP_CHAR_RAM_PTR(pc),d6	| Read TEMP_CHAR_RAM_PTR. This holds character RAM to start clearing from
		move.w	#0x20-1,d1                  | #0x20 (32 decimal) bytes to fill in a row
		move.w	#0x10,d0				| ordinal of empty character
0:
		jbsr	osd_w_bg_videoram
		addq.w	#1,d6
		dbf		d1,0b
		
		move.w	d6,TEMP_CHAR_RAM_PTR       | save in TEMP_CHAR_RAM_PTR
		subq.b	#1,TEMP_COUNTER_1        | decrement value
		beq.b	1f
		rts                          | if counter hasn't hit zero, return
1:
		move.b	#1,IS_GAME_OVER		| point HL to IS_GAME_OVER (set to 1)
		clr.b   IS_GAME_IN_PLAY     | point HL to IS_GAME_IN_PLAY
		move.b	#1,SCRIPT_NUMBER    | point HL to SCRIPT_NUMBER
		clr.b	SCRIPT_STAGE   | reset SCRIPT_STAGE to 0

*TODO
*0103: 3A 11 40      ld   a,(0x4011)           | read PORT_STATE_6800
*0106: 07            rlca                     | move dip sw1 & dip sw2 state...
*0107: 07            rlca                     | ...into bits 0 & 1 of register a
*0108: E6 03         and  0x03
*010A: 32 00 40      ld   (0x4000),a           | and store into DIP_SWITCH_1_2_STATE
*
*010D: 3A 12 40      ld   a,(0x4012)           | read PORT_STATE_7000 
*0110: E6 04         and  0x04                 | mask in state of dip switch 5
*0112: 0F            rrca                     | move bit into...
*0113: 0F            rrca                     | bit 0 of register a
*0114: 32 1F 40      ld   (0x401F),a           | and store it in DIP_SWITCH_5_STATE
*
			lea	PACKED_DEFAULT_SWARM_DEFINITION(pc),a1  | load DE with address of PACKED_DEFAULT_SWARM_DEFINITION
			bsr UNPACK_ALIEN_SWARM                      | call UNPACK_ALIEN_SWARM
*
** set IS_COCKTAIL flag from !SW0    upright/cocktail
*011D: 3A 10 40      ld   a,(0x4010)           | read PORT_STATE_6000
*0120: E6 20         and  0x20                 | read upright/cocktail bit                  
*0122: 07            rlca                     | move bit from bit 5.. 
*0123: 07            rlca
*0124: 07            rlca                     | ..to bit 0.
*0125: 32 0F 40      ld   (0x400F),a           | and store to IS_COCKTAIL

* read DIP switches to calculate value of BONUS GALIXIP
*0128: 3A 00 70      ld   a,(0x7000)           | read state of dip switch 3,4,5,6
*012B: E6 03         and  0x03                 | mask in state of dip switches 3 & 4
*012D: 21 52 01      ld   hl,0x0152   see below table
*0130: E7            rst  0x20                 | call routine to fetch value @ HL + A 
*0131: 32 AC 40      ld   BONUS_GALIXIP_FOR,a           | write BONUS GALIXIP @ value  

* Set screen attribute colours then display "1UP" and "HIGH SCORE" 
			jbsr	SET_COLOUR_ATTRIBUTES_TABLE_1 | call SET_COLOUR_ATTRIBUTES_TABLE_1
			move.b	#1,d0
			move.w	#0x5340,d6
			jbsr	osd_w_bg_videoram		| poke "1" to character RAM
			move.b	#0x25,d0
			move.w	#0x5320,d6		          
			jbsr	osd_w_bg_videoram		| poke "U" to character RAM
			move.b	#0x20,d0
			move.w	#0x5300,d6		          
			jbsr	osd_w_bg_videoram		| poke "P" to character RAM - text "1UP" now drawn
			move.w	#0x0604,d3		      | command: PRINT_TEXT_COMMAND, parameter: 4 (index of "HIGH SCORE")
			jbsr	QUEUE_COMMAND
			move.w	#0x0503,d3              | command: DISPLAY_SCORE_COMMAND , parameter: 3 (Displays player scores and high score)
			jra		QUEUE_COMMAND
  
* Values for BONUS GALIXIP. 7 = 7000, 10 = 10000, 12 =12000, 20 = 20000
**0152: 
	.byte	0x07,0x10,0x12,0x20 

*
* Script ONE is responsible for managing the attract mode.
*
*
*

SCRIPT_ONE:
	bsr	HANDLE_SWARM_MOVEMENT	| even on "game over"!   
	bsr	SET_ALIEN_PRESENCE_FLAGS
	moveq	#0,d0
	lea		script_one_jump_table(pc),a0
	move.b	SCRIPT_STAGE(pc),d0		| read SCRIPT_STAGE   
	add.w	d0,d0
	add.w	d0,d0
	move.l	(a0,d0.w),a0
	jsr		(a0)

	tst.b	NUM_CREDITS   | 03D7
	bne.b	1f			| return if no credits
	rts
1:
	addq.b	#1,SCRIPT_NUMBER        | advance to next script
	clr.b	IS_GAME_OVER 			| set IS_GAME_OVER to 0
	clr.b	SCRIPT_STAGE               | set SCRIPT_STAGE to 0
	clr.b	ENABLE_ALIEN_ATTACK_SOUND  | set ENABLE_ALIEN_ATTACK_SOUND to 0
	clr.b	ALIEN_DEATH_SOUND          | set ALIEN_DEATH_SOUND to 0
	clr.b	IS_COLUMN_SCROLLING        | clear IS_COLUMN_SCROLLING flag
	rts

script_one_jump_table: 
	.long	DISPLAY_GAME_OVER_AND_REMAINING_CREDIT_1
	.long	SET_PUSH_START_BUTTON_COUNTER
	.long	HIDE_SWARM_AND_PREPARE_TO_CLEAR_SCREEN 
	.long	CLEAR_SCREEN_BEFORE_WE_ARE_THE_GALAXIANS_INTRO
	.long	DISPLAY_WE_ARE_THE_GALAXIANS_INTRO
	.long	SCROLL_ON_CONVOY_CHARGER_POINTS
	.long	DISPLAY_NAMCO_LOGO 
	.long	BLINK_CONVOY_CHARGER_POINTS
	.long	HIDE_SWARM_AND_PREPARE_TO_CLEAR_SCREEN 
	.long	CLEAR_WE_ARE_GALAXIANS_SCREEN_AND_DISPLAY_GAME_OVER
	.long	DISPLAY_GAME_OVER_AND_REMAINING_CREDIT_2
	.long	WAIT_FOR_TEMP_COUNTER_2_THEN_ADVANCE_TO_NEXT_STAGE 
	.long	CLEAR_ALIEN_SWARM_AND_SUSPEND_SWARM_ANIMATION
	.long	CREATE_ATTRACT_MODE_ALIEN_SWARM
	.long	HANDLE_SPAWN_PLAYER
	.long	HANDLE_MAIN_GAME_LOGIC
	.long	HANDLE_PLAYER_ONE_KILLED
	.long	WAIT_FOR_TEMP_COUNTER_2_THEN_ADVANCE_TO_NEXT_STAGE
	.long	SET_SCRIPT_STAGE_TO_1

SCRIPT_TWO:
	TODOM	0x1002
	rts
SCRIPT_THREE:
	TODOM	0x1003
	rts
SCRIPT_FOUR:
	TODOM	0x1004
	rts
	
*TODO
HANDLE_SWARM_MOVEMENT:
	rts
SET_ALIEN_PRESENCE_FLAGS:
	rts

*
* Enables starfield, displays GAME OVER and the amount of credit remaining.
*
*
DISPLAY_GAME_OVER_AND_REMAINING_CREDIT_1:      
	move.w	#0x0701,d3            | command: BOTTOM_OF_SCREEN_INFO_COMMAND, parameter: 1 (invokes DISPLAY_AVAILABLE_CREDIT)
	jbsr	QUEUE_COMMAND		| call QUEUE_COMMAND
	move.w	#0x0600,d3          | command: PRINT_TEXT_COMMAND, parameter: 0 (index of GAME OVER)
	jbsr	QUEUE_COMMAND               | call QUEUE_COMMAND
	moveq  #1,d0
	move.b	d0,IS_GAME_OVER           | set IS_GAME_OVER flag
	bsr		osd_stars_on         | enable stars
	addq.b	#1,SCRIPT_STAGE   | advance to next stage
	clr.b	PUSH_START_BUTTON_COUNTER
	clr.b	CURRENT_PLAYER           | set CURRENT_PLAYER to 0 (player one)
	clr.b	IS_TWO_PLAYER_GAME
	clr.b	IS_GAME_IN_PLAY
	move.b	#0x60,TEMP_COUNTER_1
	.ifdef	FAST_INTRO_TEXT
    move.b	#1,TEMP_COUNTER_2
	.else
	move.b	#0x10,TEMP_COUNTER_2     | set TEMP_COUNTER_1 and TEMP_COUNTER_2 
	.endif
	rts

	
HIDE_SWARM_AND_PREPARE_TO_CLEAR_SCREEN:
    lea		ALIEN_SWARM_FLAGS(pc),a0            | load HL with address of 
    move.w	#0x80-1,d1               | sizeof(ALIEN_SWARM_FLAGS) array
0:
	clr.b	(a0)+             | Clear all alien swarm flags 
	dbf		d1,0b
	
    clr.b	TIMING_VARIABLE          
    clr.b   HAVE_AGGRESSIVE_ALIENS 		| reset HAVE_AGGRESSIVE_ALIENS flag
	move.w	#0x5002,TEMP_CHAR_RAM_PTR       | address of column 2 in character RAM
	.ifdef	FAST_INTRO_TEXT
    move.b	#1,TEMP_COUNTER_2
	.else
    move.b	#0x20,TEMP_COUNTER_2
	.endif
    addq.b	#1,SCRIPT_STAGE                | advance to next part of script.
	rts
	
*
* This piece of code clears all of the screen except the HUD (score, credits inserted etc)
*

CLEAR_SCREEN_BEFORE_WE_ARE_THE_GALAXIANS_INTRO:
	move.w	TEMP_CHAR_RAM_PTR(pc),d6  | load HL with contents of TEMP_CHAR_RAM_PTR
     move.w	#0x1C-1,d1               | We want to clear #0x1C (28 characters) on this row 
     move.b	#0x10,d0               | ordinal for empty character
0:
	 jbsr	osd_w_bg_videoram
	 dbf		D1,0b         | Clear 28 characters from row
                              | As a row is 32 characters wide, to get to start of next row...
     add.w	#4,d6              | ... we need to add 4 characters.
     move.w	d6,TEMP_CHAR_RAM_PTR         | write to TEMP_CHAR_RAM_PTR
	 subq.b	#1,TEMP_COUNTER_2     | decrement value of counter
     beq.b	1f                  | if value is not zero then exit 
	rts
1:
	addq.b	#1,SCRIPT_STAGE		| advance to next part of script.
	move.b	#0x40,TEMP_COUNTER_1
	move.b	#0x04,TEMP_COUNTER_2	| set TEMP_COUNTER_1 and TEMP_COUNTER_2

	lea		HAS_PLAYER_SPAWNED(pc),a0
	move.w	#FLAGSHIP_ATTACK_SECONDARY_COUNTER-HAS_PLAYER_SPAWNED,d1
0:
	clr.b	(a0)+
	dbf		d1,0b    | Clear from 0x4200-422F
	  
      | reset regen hflip (not done)
      | reset regen vflip (not done)
      | reset DISPLAY_IS_COCKTAIL_P2  (not done)
      move.b	#1,DISABLE_SWARM_ANIMATION           | set  flag
      lea	COLOUR_ATTRIBUTE_TABLE_3(pc),a0
      bra	SET_COLOUR_ATTRIBUTES               | jump to SET_COLOUR_ATTRIBUTES

*
* The alien swarm scrolling in the attract mode has changed scroll values for some columns, 
* and these scroll values need to be reset before we can print text like "WE ARE THE GALAXIANS" "MISSION: DESTROY ALIENS"
* in those columns. If we don't reset the scroll values, the text will probably be off-centre and not look good.
*

HANDLE_ALIEN_SWARM_SCROLL_RESET:
    moveq	#0,d0                   | reset scroll offset to 0
    jra     SET_SWARM_SCROLL_OFFSET

*
* This is used to scroll the alien swarm from side to side.
*
* Expects:
* register A: Scroll offset value
*

SET_SWARM_SCROLL_OFFSET:
    lea	OBJRAM_BACK_BUF+8,a0     | pointer to attribute and column scroll data held in OBJRAM_BACK_BUF
    move.w	#8,d1                | we're doing 9 columns.
0:
	move.b	d0,(a0)
    addq.w	#2,a0        | bump HL to next scroll offset address in OBJRAM_BACK_BUF
    dbf		d1,0b
    rts


MAKE_SWARM_MOVE_RIGHT:
	move.b	#1,SWARM_DIRECTION   | Swarm now moves right.
	rts

MAKE_SWARM_MOVE_LEFT:
	clr.b	SWARM_DIRECTION   | Swarm now moves left
	rts

*0988: 2A 0E 42      ld   hl,(0x420E)          | read SWARM_SCROLL_VALUE
*098B: C3 6F 09      jp   0x096F


*
* Displays the following:
*
* WE ARE THE GALAXIANS
* MISSION: DESTROY ALIENS
* - SCORE ADVANCE TABLE -
* CONVOY CHARGER

DISPLAY_WE_ARE_THE_GALAXIANS_INTRO:
     bsr	HANDLE_ALIEN_SWARM_SCROLL_RESET
     subq.b	#1,TEMP_COUNTER_1
     beq.b	0f
	 rts 
0:
     move.b	#0x50,TEMP_COUNTER_1            | reset counter
     move.w	#0x0600,d3               | Command: PRINT_TEXT

* HL now points to a number between 1 and 4. This identifies a text string we want to print: 
* 1: CONVOY CHARGER             
* 2: SCORE ADVANCE TABLE
* 3: MISSION: DESTROY ALIENS    
* 4: WE ARE THE GALAXIANS
	move.b	TEMP_COUNTER_2(pc),d3
	add.b	#6,d3      | add 6 to it to give us an index for PRINT_TEXT
    jbsr	QUEUE_COMMAND
    subq.b	#1,TEMP_COUNTER_2              | bump TEMP_COUNTER_2 to index of next string to print
    beq.b	1f
	rts
1:
	addq.b	#1,SCRIPT_STAGE     | advance to next stage
	move.b	#0x20,TEMP_COUNTER_1
	move.b	#0x04,TEMP_COUNTER_2  | set TEMP_COUNTER_1 and TEMP_COUNTER_2

* hide all sprites 
	lea		INFLIGHT_ALIENS(pc),a0
	move.w	#0x3F,d1
0:
	clr.l	(a0)+
	dbf		d1,0b     | Fill the entire INFLIGHT_ALIENS array with zero
    clr.b	ATTRACT_MODE_SCROLL_ID
    rts

SCROLL_ON_CONVOY_CHARGER_POINTS:
	jbsr	HANDLE_ALIEN_SWARM_SCROLL_RESET
	jbsr	HANDLE_INFLIGHT_ALIEN_SPRITE_UPDATE
	jbsr	HANDLE_INFLIGHT_ALIENS
	jbsr	HANDLE_DRAW_CONVOY_CHARGER_POINTS
	subq.b	#1,TEMP_COUNTER_1
	bne.b	0f
	move.b	#0xD2,TEMP_COUNTER_1
0:
	rts

* get ready to scroll the next alien sprite and associated points values on screen
	jbsr	INIT_CONVOY_CHARGER_SPRITE
	addq.b	#1,ATTRACT_MODE_SCROLL_ID     | set id to next thing to scroll on
	subq.b	#1,TEMP_COUNTER_2			  | dec TEMP_COUNTER_2
	beq.b	0f
	rts
0:
	move.b	#0xD2,TEMP_COUNTER_2
	addq.b	#1,SCRIPT_STAGE
	clr.b	OBJRAM_BACK_BUF+0x38		      | write to scroll offset in OBJRAM_BACK_BUF (0x4058)
	rts


*
* This important routine is responsible for handling the enemy sprites in the game. 
* It reads the position, colour and animation frame of each item in the INFLIGHT_ALIENS array and 
* projects it into the relevant INFLIGHT_ALIEN_SPRITE of OBJRAM_BACK_BUF_SPRITES. 
*
* In plain English: the sprite back buffer is filled by this routine :) 
* 
* JOTD: removed cocktail mode

HANDLE_INFLIGHT_ALIEN_SPRITE_UPDATE:
	lea		INFLIGHT_ALIENS(pc),a2
	lea		OBJRAM_BACK_BUF_SPRITES(pc),a3
*
** for the first 3 alien sprites, their Y coordinates need to be offset 7 pixels vertically so that the hardware can render them correctly.
	move.w	#3-1,d1                            | number of sprites to set sprite state for
	moveq	#7,d2							   | set pixel offset to 7
0:
	jbsr	SET_SPRITE_STATE
	add.w	#inflight_alien_size,a2
	addq.w	#0x4,a3
	dbf		d1,0b
*
** for the next 5 alien sprites, their Y coordinates need to be offset 8 pixels vertically.
	move.w	#5-1,d1                            | number of sprites to set sprite state for
	moveq	#8,d2							   | set pixel offset to 8
0:
	jbsr	SET_SPRITE_STATE
	add.w	#inflight_alien_size,a2
	addq.w	#0x4,a3
	dbf		d1,0b
	rts
*
* Extract the colour, position, animation frame information from an INFLIGHT_ALIEN structure
* and project it into a INFLIGHT_ALIEN_SPRITE.
*
* Expects:
* C = pixel adjustment for Y coordinate
* IX = pointer to INFLIGHT_ALIEN structure to extract information from
* IY = pointer to INFLIGHT_ALIEN_SPRITE structure to be filled
*

SET_SPRITE_STATE:
	tst.b	(IsActive,a2)       | test INFLIGHT_ALIEN.IsActive
	jeq		SET_INACTIVE_OR_DYING_SPRITE_STATE   | if alien is not active, goto 
	move.b	(Colour,a2),(2,a3)		| read INFLIGHT_ALIEN.Colour, write to INFLIGHT_ALIEN_SPRITE.Colour
	move.b	(inf_alien_X,a2),d0          | read INFLIGHT_ALIEN.X
	subq.b	#8,d0
	move.b	d0,(3,a3)    | write to INFLIGHT_ALIEN_SPRITE.X
	move.b	(inf_alien_Y,a2),d0    | read INFLIGHT_ALIEN.Y 
	not.b	d0          | flip bits  
    sub.b	d2,d0                 | subtract pixel adjustment
    move.b	d0,(a3)          | write to INFLIGHT_ALIEN_SPRITE.Y 
*
** Determine what way the alien is facing and set the sprite XFlip/YFlip/Code properties accordingly
**
** Important point to remember: non-flagship aliens are like bats. They hang upside down in the swarm.
** If you want to see what the sprites look like before being flipped, refer to my sprite grabs @ 
** http://seanriddle.com/galaxiansprites.html
*
	move.b	(AnimationFrame,a2),d0       | read INFLIGHT_ALIEN.AnimationFrame
l_C40:
	bpl.b	0f
	cmp.b   #0xFA,d0                 | compare to -6 
	bmi.b	1f

** alien is between an angle of 90 and 180 degrees (as player sees it)
	not.b	d0
	add.b  #0x12,d0
	or.b	#0x40,d0                           | set X-Flip bit for sprite
	add.b	d0,(AnimFrameStartCode,a2)         | add in INFLIGHT_ALIEN.AnimFrameStartCode
	move.b	d0,(1,a3)                          | write to INFLIGHT_ALIEN_SPRITE.Code
    addq.b	#1,(3,a3)           			   | increment INFLIGHT_ALIEN_SPRITE.X
	rts
0:
	cmp.b	#6,d0
	bpl.b	2f

** alien is between an angle of 180 and 270 degrees (as player sees it)
	add.b	#0x11,d0
	or.b	#0xC0,d0        | set X-Flip and Y-Flip bits for sprite
	add.b	d0,(AnimFrameStartCode,a2)          | add in INFLIGHT_ALIEN.AnimFrameStartCode
	move.b	d0,(1,a3)        				   | write to INFLIGHT_ALIEN_SPRITE.Code
    addq.b	#1,(3,a3)           			   | increment INFLIGHT_ALIEN_SPRITE.X
    addq.b	#1,(a3)           			       | increment INFLIGHT_ALIEN_SPRITE.Y
	rts
2:
	cmp.b	#0xC,d0
	bpl.b	3f

** alien is between an angle of 270-360 degrees (as player sees it)
	not.b	d0
	add.b	#0x1E,d0
	bset	#7,d0                               | set Y-Flip bit for sprite
	add.b	d0,(AnimFrameStartCode,a2)          | add in INFLIGHT_ALIEN.AnimFrameStartCode
	move.b	d0,(1,a3)        				   | write to INFLIGHT_ALIEN_SPRITE.Code
    addq.b	#1,(a3)           			       | increment INFLIGHT_ALIEN_SPRITE.Y
	rts

1:
	cmp.b	#0xF4,d0
	bmi.b	4f

** alien is between an angle of 0-90 degrees (as player sees it)
	add.w	#0x1D,d0
	add.b	d0,(AnimFrameStartCode,a2)          | add in INFLIGHT_ALIEN.AnimFrameStartCode
	move.b	d0,(1,a3)        				   | write to INFLIGHT_ALIEN_SPRITE.Code
	rts
*
3:
	sub.b	#0x18,d0
	bra.b	l_C40
4:
	add.b	#0x18,d0
	bra.b	l_C40


*
* Jumped to from SET_SPRITE_STATE when the INFLIGHT_ALIEN is inactive or dying.
*
* Expects:
* C = pixel adjustment for Y coordinate
* IX = pointer to INFLIGHT_ALIEN structure
* IY = pointer to INFLIGHT_ALIEN_SPRITE structure

SET_INACTIVE_OR_DYING_SPRITE_STATE:
	tst.b	(IsDying,a2)		| test INFLIGHT_ALIEN.IsDying flag
	beq.b	0f					| if the alien has finally expired, goto 0x0CBA

* alien is dying
	move.b	#7,(2,a3)        | set INFLIGHT_ALIEN_SPRITE.Colour
	move.b	(inf_alien_X,a2),d0		   | read INFLIGHT_ALIEN.X
	subq.b	#8,d0
	move.b	d0,(3,a3)     | set INFLIGHT_ALIEN_SPRITE.X
	move.b	(inf_alien_Y,a2),d0		  | read INFLIGHT_ALIEN.Y 
	not.b	d0
	sub.b	d2,d0		       | subtract pixel adjustment value
	move.b	d0,(a3)			 | set INFLIGHT_ALIEN_SPRITE.Y 

	move.b	(DyingAnimFrameCode,a2),(1,a3)	| read INFLIGHT_ALIEN.DyingAnimFrameCode
											| and set INFLIGHT_ALIEN_SPRITE.Code 
	rts
0:
* This alien has died. Move sprite off-screen
	move.b	#0xF8,(3,a3)     | set INFLIGHT_ALIEN_SPRITE.X to value offscreen
	move.b	#0xF8,(0,a3)     | set INFLIGHT_ALIEN_SPRITE.Y to value offscreen
	rts
	

DISPLAY_NAMCO_LOGO:
	jbsr	HANDLE_ALIEN_SWARM_SCROLL_RESET
	jbsr	HANDLE_INFLIGHT_ALIEN_SPRITE_UPDATE
	jbsr	HANDLE_INFLIGHT_ALIENS
	jbsr	HANDLE_DRAW_CONVOY_CHARGER_POINTS

* wait until TEMP_COUNTER_2 reaches 0
	subq.b	#1,TEMP_COUNTER_2
	beq.b	0f
	rts
0:
	addq.b	#1,SCRIPT_STAGE		| advance to next stage
	clr.b	OBJRAM_BACK_BUF+0x38		      | write to scroll offset in OBJRAM_BACK_BUF (0x4058)
	move.b	#0x11,TEMP_COUNTER_2
	move.b	#0x40,TEMP_COUNTER_1
	addq.b	#1,ATTRACT_MODE_SCROLL_ID
	move.w	#0x060F,d3            | command: PRINT_TEXT, parameter: #0x0F (Displays NAMCO logo)
	jra		QUEUE_COMMAND               


*
*
*
*
*

BLINK_CONVOY_CHARGER_POINTS:
	jbsr	HANDLE_ALIEN_SWARM_SCROLL_RESET
	jbsr	HANDLE_INFLIGHT_ALIEN_SPRITE_UPDATE
	jbsr	HANDLE_INFLIGHT_ALIENS
	jbsr	HANDLE_DRAW_CONVOY_CHARGER_POINTS
	jra		WAIT_FOR_TEMP_COUNTERS

CLEAR_WE_ARE_GALAXIANS_SCREEN_AND_DISPLAY_GAME_OVER:
	TODOM	8
DISPLAY_GAME_OVER_AND_REMAINING_CREDIT_2:
	TODOM	9
CLEAR_ALIEN_SWARM_AND_SUSPEND_SWARM_ANIMATION:
	TODOM	10
CREATE_ATTRACT_MODE_ALIEN_SWARM:
	TODOM	11
HANDLE_SPAWN_PLAYER:
	TODOM	12
HANDLE_MAIN_GAME_LOGIC:
	TODOM	13
HANDLE_PLAYER_ONE_KILLED:
	TODOM	14

*
* In the demo mode, this erases all of the points values underneath the text "CHARGER"
*
* in D1: number of rows

CLEAR_DEMO_CONVOY_CHARGER_POINTS:
     move.w	#0x5193,d6            | address in character RAM
     move.w	#-32,d3            | offset to add to character RAM address  (-32 decimal.)
	 and.w	#0xFF,d1
	 subq.w	#1,d1
0:
     move.b	#3,d2               | 3 characters to erase
     move.b	#0x10,d0               | ordinal of empty character
1:
     jbsr	osd_w_bg_videoram           | write empty character to screen       
     add.w	d3,d6               | add offset. HL now points to character a row above, same column               
     subq.b	#1,d2               | decrement count of characters to erase
     bne.b	1b            | if not done goto 0x03CA
     add.w	#0x62,d6
     dbf	d1,0b
     rts


*
* Handles the drawing and blinking of the CONVOY CHARGER points values in the demo.
*

HANDLE_DRAW_CONVOY_CHARGER_POINTS:
	tst.b	ATTRACT_MODE_SCROLL_ID
	bne.b	0f
	rts					| if its zero, not time to scroll anything in yet, return
0:
	subq.b	#1,d0		| JOTD: if its one, seems that it's the same!
	bne.b	1f
	rts
1:
	move.b	d0,d1
	move.b	TIMING_VARIABLE(pc),d0
	move.b	d0,d2				 | save it in C 
	and.w	#0x3F,d0                 | mask in bits 0..5. Now A is a value from 0..63 decimal.
	bne.b	2f
	jbsr	CLEAR_DEMO_CONVOY_CHARGER_POINTS 	| if bits 0..5 are not set, call CLEAR_DEMO_CONVOY_CHARGER_POINTS
2:
	cmp.b	#0x20,d0
	bne.b	3f		| If A is not exactly 0x20 exit
	rts
3:

* When we get here, we need to compute what flagship scores we are going to draw. 
* We basically take the value in TIMING_VARIABLE, AND the value by 3 to give an index value in range of 0..3, then
* multiply the index by 3 to give an offset into the flagship score table @0x039A.  
* The end result is cycling flagship values.

	roxl.b	#2,d2		| TIMING_VARIABLE saved in d2
	and.w	#3,d2		| now d2 is a value from 0..3. d2 is now an index into table @0x039A 
	move.w	d2,d0
	add.w	d2,d2
	add.w	d0,d2		| multiply d2 by 3
	lea		flagship_table_039A,a0
	move.w	#0x5193,d3      | address in character RAM
	jbsr	DRAW_3_CHARACTERS
	subq.b	#1,d1
	bne.b	4f
	rts
4:
	subq.b	#1,d1
	and.w	#0xFF,d1
* The alien scores are static and don't cycle, so we just draw them straight from the table 
	lea	alien_table_03A6(pc),a0				| pointer to Alien score table
5:
	jbsr	DRAW_3_CHARACTERS
	dbf		d1,5b
	rts


*
* This routine is responsible for positioning alien sprites off screen ready to be scrolled onto the CONVOY CHARGER points table.
* Once the positioning is done, the sprite is "handed over" to the routine @ 0x109B.
*
* Expects: HL(a0) points to TEMP_COUNTER_2
*
* The value in TEMP_COUNTER_2 specifies what type of alien we are scrolling on:
*
* 4: Flagship
* 3: Red alien
* 2: Purple alien
* 1: Blue alien
*

INIT_CONVOY_CHARGER_SPRITE:
	moveq	#0,d0
	move.b	TEMP_COUNTER_2(pc),d0     | read type of alien to scroll on
	subq.b	#1,d0		| convert A into a 0-based index 
	move.b	d0,d1
	
	lsr.w	#5,d0		| multiply A by 32 (which is sizeof(INFLIGHT_ALIEN))
	lea		INFLIGHT_ALIENS(pc),a0	  | HL = address of INFLIGHT_ALIENS[3]
	add.w	d0,a0					   | Add offset to HL. HL now points to INFLIGHT_ALIEN record we're using to scroll sprite on with
	move.b	#1,(a0)+            | set INFLIGHT_ALIEN.IsActive to 1 
	clr.b	(a0)+				| reset INFLIGHT_ALIEN.IsDying 
	move.b	#0xD,(a0)+			| set INFLIGHT_ALIEN.StageOfLife to INFLIGHT_ALIEN_CONVOY_CHARGER_SET_COLOUR_POS_ANIM
	addq.w	#1,a0
	clr.b	(a0)+               | set INFLIGHT_ALIEN.Y to position offscreen
	move.b	#0xC,(a0)+		        | set INFLIGHT_ALIEN.AnimationFrame
	addq.w	#1,a0
	move.b	d1,(a0)				     | set INFLIGHT_ALIEN.IndexInSwarm 
	rts


SET_SCRIPT_STAGE_TO_1:
	move.b	#1,SCRIPT_STAGE         | set SCRIPT_STAGE to 1
	move.b	#3,TEMP_COUNTER_1
	move.b	#3,TEMP_COUNTER_2
	rts

*
* Decrements value in TEMP_COUNTER_2. When counter value hits zero, advance script to next stage.
* 

WAIT_FOR_TEMP_COUNTER_2_THEN_ADVANCE_TO_NEXT_STAGE:
	subq.b	#1,TEMP_COUNTER_2        | decrement value of TEMP_COUNTER_2 counter
	beq.b	0f
	rts
0:
	addq.b	#1,SCRIPT_STAGE		| advance script to next stage
	rts

*
* Draw 3 characters in the same *column*.
* Because the Galaxian monitor is turned on its side, the characters look like they are on the same row.
* 
* Expects:
* A0 to point to 3 bytes defining the characters to draw 
* D3 to point to character RAM to draw to
*

DRAW_3_CHARACTERS:
    move.b	#3,d2               | number of characters to draw
	move.w	d3,d6
0:    
	move.b	(a0)+,d0           | read character to draw  
    bsr		osd_w_bg_videoram  | write to character RAM
    sub.w	#0x20,d6           | subtract #0x20 (32 decimal) from it. Now DE points to character in same column, row above 
    subq.b	#1,d2              | decrement counter of characters to draw. 
    bne.b	0b                 | if counter !=0, more characters are to be drawn, goto 0x03B1
    add.w	#0x62,d6           | Add #0x62 (98 decimal) to DE. Now DE is back on row we started drawing from.
	move.w	d6,d3
    rts


*
* Decrements value in TEMP_COUNTER_1. When counter value hits zero, reset value of TEMP_COUNTER_1 to 0x3C (60 decimal)
* and then decrement value of TEMP_COUNTER_2. 
*
* When value of TEMP_COUNTER_2 hits zero, advance script to next stage.
*

WAIT_FOR_TEMP_COUNTERS:
	subq.b	#1,TEMP_COUNTER_1        | decrement value of TEMP_COUNTER_1 counter
	beq.b	0f
	rts
0:
	move.b	#0x3C,TEMP_COUNTER_1             | reset counter to 0x3C (50 decimal)
	bra.b	WAIT_FOR_TEMP_COUNTER_2_THEN_ADVANCE_TO_NEXT_STAGE	| and go check if that counter 2 has counted down to 0 yet 


SET_PUSH_START_BUTTON_COUNTER:
	move.b	#1,PUSH_START_BUTTON_COUNTER
	bra.b	WAIT_FOR_TEMP_COUNTERS
	
* < A1: player score which replaces high score
UPDATE_HIGH_SCORE:
		bsr	LEA_DE_OF_CURRENT_PLAYER_SCORE	| Now DE = pointer to current player score
		lea	HI_SCORE(pc),a0		| address of high score
		moveq	#2,d2			| high score occupies 3 bytes
0:
		move.b	(a1)+,(a0)+
		dbf		d2,0b
		subq.w	#1,a1
l_21F8: move.w	#0x5241,d6            | character RAM address where HIGH SCORE will be drawn
		jbra	PLOT_SCORE_CHARACTERS

*
* This routine is responsible for processing all 8 elements in the INFLIGHT_ALIENS array. 
*

HANDLE_INFLIGHT_ALIENS:
	lea		INFLIGHT_ALIENS(pc),a2           | load IX with address of 
    move.w	#inflight_alien_size,d2                         | sizeof(INFLIGHT_ALIEN)
	move.w	#8-1,d1							| 1 misc + 7 attacking aliens to process
0:
	movem.l	d1/d2,-(a7)
	jbsr	HANDLE_INFLIGHT_ALIEN_STAGE_OF_LIFE
	movem.l	(a7)+,d1/d2
	add.w	d2,a2		        | bump IX to point to next INFLIGHT_ALIEN structure
	dbf		d1,0b               | do while b!=0
	rts

*
* Like humans, inflight aliens go through stages of life. They leave home, attack humans, maybe do a loop the loop,
* then (maybe) return home. Just like we do!
* 
* This routine is used to invoke actions appropriate for the alien's stage of life.
*
* Expects:
* IX = pointer to INFLIGHT_ALIEN structure.
*

HANDLE_INFLIGHT_ALIEN_STAGE_OF_LIFE:
	tst.b	(IsDying,a2)          | test INFLIGHT_ALIEN.IsDying flag
	jne		HANDLE_INFLIGHT_ALIEN_DYING    | if alien is dying, goto 
	tst.b	(IsActive,a2)          | test INFLIGHT_ALIEN.IsActive flag 
	bne.b	0f		| exit if not active
	rts
0:
* We need to determine what stage of life the inflight alien is at, then call the appropriate function to
* tell it how to behave. 
	moveq	#0,d0
	move.b	(StageOfLife,a2),d0 	| read INFLIGHT_ALIEN.StageOfLife
	add.w	d0,d0
	add.w	d0,d0
	lea		table_0CE6(pc),a0
	move.l	(a0,d0.w),a0
	jmp		(a0)

table_0CE6: 
      .long		INFLIGHT_ALIEN_PACKS_BAGS
      .long		INFLIGHT_ALIEN_FLIES_IN_ARC
      .long		INFLIGHT_ALIEN_READY_TO_ATTACK
      .long		INFLIGHT_ALIEN_ATTACKING_PLAYER
      .long		INFLIGHT_ALIEN_NEAR_BOTTOM_OF_SCREEN
      .long		INFLIGHT_ALIEN_REACHED_BOTTOM_OF_SCREEN
      .long		INFLIGHT_ALIEN_RETURNING_TO_SWARM
      .long		INFLIGHT_ALIEN_CONTINUING_ATTACK_RUN_FROM_TOP_OF_SCREEN 
      .long		INFLIGHT_ALIEN_FULL_SPEED_CHARGE 
      .long		INFLIGHT_ALIEN_ATTACKING_PLAYER_AGGRESSIVELY
      .long		INFLIGHT_ALIEN_LOOP_THE_LOOP
      .long		INFLIGHT_ALIEN_COMPLETE_LOOP
      .long		INFLIGHT_ALIEN_UNKNOWN_1091
      .long		INFLIGHT_ALIEN_CONVOY_CHARGER_SET_COLOUR_POS_ANIM
      .long		INFLIGHT_ALIEN_CONVOY_CHARGER_START_SCROLL  
      .long		INFLIGHT_ALIEN_CONVOY_CHARGER_DO_SCROLL


*
* Called when the alien is dying.
*

HANDLE_INFLIGHT_ALIEN_DYING:
	moveq	#0,d0
	move.b	(StageOfLife,a2),d0 	| read INFLIGHT_ALIEN.StageOfLife
	add.w	d0,d0
	add.w	d0,d0
	lea		table_10E8(pc),a0
	move.l	(a0,d0.w),a0
	jmp		(a0)

table_10E8:
    .long	INFLIGHT_ALIEN_DYING_SETUP_ANIM_AND_SOUND    
    .long	INFLIGHT_ALIEN_DYING_DISPLAY_EXPLOSION
    .long	INFLIGHT_ALIEN_DYING_FINALLY_BUYS_FARM
    .long	JUST_RTS

JUST_RTS:
	rts
	
INFLIGHT_ALIEN_PACKS_BAGS:
	TODOM	0x100
INFLIGHT_ALIEN_FLIES_IN_ARC:	
	TODOM	0x101
INFLIGHT_ALIEN_READY_TO_ATTACK:	
	TODOM	0x102
INFLIGHT_ALIEN_ATTACKING_PLAYER:	
	TODOM	0x103
INFLIGHT_ALIEN_NEAR_BOTTOM_OF_SCREEN:
	TODOM	0x104
INFLIGHT_ALIEN_REACHED_BOTTOM_OF_SCREEN:	
	TODOM	0x104
INFLIGHT_ALIEN_RETURNING_TO_SWARM:
	TODOM	0x104
INFLIGHT_ALIEN_CONTINUING_ATTACK_RUN_FROM_TOP_OF_SCREEN:
	TODOM	0x104
INFLIGHT_ALIEN_FULL_SPEED_CHARGE:
	TODOM	0x104
INFLIGHT_ALIEN_ATTACKING_PLAYER_AGGRESSIVELY:
	TODOM	0x104
INFLIGHT_ALIEN_LOOP_THE_LOOP:
	TODOM	0x104
INFLIGHT_ALIEN_COMPLETE_LOOP:	
	TODOM	0x104
INFLIGHT_ALIEN_UNKNOWN_1091:
	TODOM	0x104
INFLIGHT_ALIEN_CONVOY_CHARGER_SET_COLOUR_POS_ANIM:
	TODOM	0x104
INFLIGHT_ALIEN_CONVOY_CHARGER_START_SCROLL:
	TODOM	0x104
INFLIGHT_ALIEN_CONVOY_CHARGER_DO_SCROLL:
	TODOM	0x104
INFLIGHT_ALIEN_DYING_SETUP_ANIM_AND_SOUND:    	
	TODOM	0x104
INFLIGHT_ALIEN_DYING_DISPLAY_EXPLOSION:
	TODOM	0x104
INFLIGHT_ALIEN_DYING_FINALLY_BUYS_FARM:
	TODOM	0x104

	
	
	
	
	
	
	
	
	
*
* Value in register A       What it represents
* =====================================================
* 0                         Display Player one's score 
* 1                         Display Player two's score 
* 2                         Display high score.
* 3                         Do all of the above.
*

DISPLAY_SCORE_COMMAND:	
	cmp.b	#3,d0
	bcc.b		DISPLAY_ALL_SCORES       	| if A>= #0x03, goto 0x224D, DISPLAY_ALL_SCORES
	lea			PLAYER_ONE_SCORE+2(pc),a0	| pointer to last 2 BCD digits of PLAYER_ONE_SCORE
	beq.b		DECIDE_TO_DISPLAY_PLAYER_ONE_OR_PLAYER_TWO_SCORE	| if A is 0
	subq.b		#1,d0				    | if A was 1 on entry, then Z flag is now set
	bne.b		DISPLAY_HIGH_SCORE
	tst.b		IS_TWO_PLAYER_GAME
	bne.b		0f
	rts					| if it's zero, then we're just in a single player game, return
0:
	lea			PLAYER_TWO_SCORE+2(pc),a0	        | pointer to last 2 BCD digits of PLAYER_TWO_SCORE
	jra			DECIDE_TO_DISPLAY_PLAYER_ONE_OR_PLAYER_TWO_SCORE

DISPLAY_HIGH_SCORE:
	lea		HI_SCORE+2(pc),a0            | pointer to last 2 BCD digits of HI_SCORE
	jra		l_21F8

* This displays player scores and high scores
DISPLAY_ALL_SCORES:
	subq.b	#1,d0
	move.w	d0,-(a7)
	jbsr	DISPLAY_SCORE_COMMAND
	move.w	(a7)+,d0
	bne.b	DISPLAY_ALL_SCORES
	rts


* 
* Expects:
*
* Value in register A       Action taken                     
* ====================================================
* 0                         Display player one's score       
* 1                         Display player two's score
*      
* DE = pointer to *last* byte of 3 BCD bytes representing a score (ie: player 1 score, player 2 score)

DECIDE_TO_DISPLAY_PLAYER_ONE_OR_PLAYER_TWO_SCORE:
	move.w	#0x5381,d6            | pointer to character RAM location for player one's score
	tst.b	d0                    | test if A is 0.  
	beq.b	PLOT_SCORE_CHARACTERS | if A is 0 then we want to draw player one's score, goto 0x2261
	move.w	#0x5121,d6            | pointer to character RAM location for player one's score

*
* Plot score to the screen. 
*
* Expects:
*
* DE = pointer to *last* byte of 3 BCD bytes representing a score (ie: player 1 score, player 2 score, or high score)
*      See docs for PLAYER_ONE_SCORE to understand how scores are packed as BCD 
*
* D6 = pointer to character RAM to begin plotting characters from
*
*

PLOT_SCORE_CHARACTERS:
	move.w	#-0x20,d5	| load HL with 0xFFE0 (-32 decimal) 
	moveq	#2,d3       | a score is 3 bytes in size..                
	moveq	#4,d2		| max number of leading zeros that can be skipped. For example,
                                             | when you start the game you have a score of zero. It renders as "00". 
                                             | So this says "skip the first 4 zeros in the score, but display the rest"
0:
	move.b	(a0),d0		| read BCD digits from score byte
	lsr.b	#4,d0       | move high nibble (first digit of BCD number)...
	jbsr	PLOT_LOWER_NIB_AS_DIGIT   | call  to plot the first digit                 
	move.b	(a0),d0		| read BCD digits from score byte
	jbsr	PLOT_LOWER_NIB_AS_DIGIT     | call to plot the second digit 
	subq.w	#1,a0		| bump to *previous* BCD byte
	dbf		d3,0b       | do until all BCD digits in score have been drawn
	rts


* Pokes a digit of the score to character RAM.
*
* Expects:
*
* Lower nibble of D0: BCD digit to be plotted as a character on screen 
* D2 = max number of leading zero digits in the score that can be skipped. 
* If D2 is 0, zero digits will always be drawn
* D6 = pointer to character RAM where digit will be plotted.

PLOT_LOWER_NIB_AS_DIGIT:
	and.b	#0xF,d0		| mask in lower nibble
	beq.b	0f			| if the lower nibble is zero, goto 0x2281

* OK, we have a nonzero digit.
	clr		d2              | tell the plot routine to draw all digits, even if they are zero, from now on
	bra.b	1f				| go plot the character

* we have a zero digit. Do we print it, or print a space instead?
0:
	tst.b	d2        | how many zero digits can we skip over?   
	beq.b	1f		| if we can't skip over any more leading zero digits, then goto 0x2288 to draw "0". 

* Otherwise, we are skipping a leading "0" digit and will print an empty space instead..
	move.b	#0x80,d0	| when added to 0x90 this will produce 0x10 (16 decimal) - ordinal for empty character
	subq.b	#1,d2		| decrement count of leading zeros we are allowed to ignore
1:
	add.b	#0x90,d0    | transform A into ordinal of character to be plotted
	jbsr	osd_w_bg_videoram		| plot character for score to screen
	add.w	d5,d6		| now IX points to character directly above one just plotted
	rts


*
* Load DE (A1) with the [effective] address of the current player's score.
* 


LEA_DE_OF_CURRENT_PLAYER_SCORE:
	lea	PLAYER_ONE_SCORE(pc),a1            | address of 
	tst.b	CURRENT_PLAYER     | read CURRENT_PLAYER           
	bne.b	0f					| if it is zero, then current player is player one. Return.
	rts
0:
	lea		PLAYER_TWO_SCORE(pc),a1	| address of PLAYER_TWO_SCORE
	rts


SET_COLOUR_ATTRIBUTES_TABLE_1:
		lea		COLOUR_ATTRIBUTE_TABLE_1(pc),a0 

*TODO
SET_COLOUR_ATTRIBUTES:
*0598: 11 21 40      ld   de,0x4021            | address of first attribute in OBJRAM_BACK_BUF 
*059B: 06 20         ld   b,0x20               | we're setting attributes for all 32 columns in the row
*059D: 7E            ld   a,(hl)              | read attribute value from ROM 
*059E: 12            ld   (de),a              | write to attribute value in OBJRAM_BACK_BUF
*059F: 23            inc  hl                  | bump HL to next value in ROM
*05A0: 1C            inc  e                   | Add 2 to DE..
*05A1: 1C            inc  e                   | .. so that it points to the next attribute value
*05A2: 10 F9         djnz 0x059D               | and do until b==0
*05A4: C9            ret
	rts

UNPACK_ALIEN_SWARM:
*TODO
	rts
	
*0646: 21 00 41      ld   hl,0x4100            | load HL with address of ALIEN_SWARM_FLAGS
*0649: 06 10         ld   b,0x10               | There's 16 bytes to be unpacked to 128 flags
*064B: 0E 01         ld   c,0x01
*
*064D: 1A            ld   a,(de)              | read from (de) 
*064E: A1            and  c                   | test if bit is set
*064F: 28 0B         jr   z,0x065C             | if bit is not set, goto 0x065C 
*0651: 36 01         ld   (hl),0x01            | bit is set, write 1 to (hl) - create an alien 
*0653: 23            inc  hl                  | bump hl to next byte
*0654: CB 01         rlc  c                   | rotate c left one bit
*0656: 30 F5         jr   nc,0x064D            | if bit 7 of C wasn't set, goto 0x064D
*0658: 13            inc  de                  | move to next byte
*0659: 10 F2         djnz 0x064D               | do until b ==0
*065B: C9            ret
*065C: 36 00         ld   (hl),0x00            | write 0 to (hl) 
*065E: C3 53 06      jp   0x0653               | 


*
* Try to insert into the circular command queue located @ 0x40C0. (CIRC_CMD_QUEUE_START)
* if insert is not possible, exit function immediately.
*
* Expects:
* D is a command number (0..7) 
* E is a parameter to pass to the command. 
*
* 0x40A0 contains the low byte of a pointer to a (hopefully) free entry in the queue.  
*
* REMARKS:
*
* Value in D                Action it invokes 
* ===============================================================
* 0                         Invokes DRAW_ALIEN_COMMAND
* 1                         Invokes DELETE_ALIEN_COMMAND
* 2:                        Invokes DISPLAY_PLAYER_COMMAND
* 3:                        Invokes UPDATE_PLAYER_SCORE_COMMAND
* 4:                        Invokes RESET_SCORE_COMMAND
* 5:                        Invokes DISPLAY_SCORE_COMMAND
* 6:                        Invokes PRINT_TEXT_COMMAND 
* 7:                        Invokes BOTTOM_OF_SCREEN_INFO_COMMAND
* 
* The purpose of the parameter in E depends on the command.
*
* SEE ALSO:
* The code @ 0x200C which processes the entries in the queue.

* ALGORITHM:
* 1. Form a pointer to an entry in the circular queue using #0x40 as the high byte of the pointer
*    and the contents of 0x40A0 (CIRC_CMD_QUEUE_PTR_LO) as the low byte. 
* 2. Read a byte from the queue entry the pointer points to 
* 3. IF bit 7 of the byte is unset, then the queue entry is in use, we can't insert. Exit function.  
* 4. ELSE:
*    4a) store register DE at the pointer
*    4b) bump pointer to next queue entry 
* 5. Exit function

QUEUE_COMMAND:
	move.l	a0,-(a7)
	move.l	CIRC_CMD_QUEUE_PTR(pc),a0
	tst		(a0)	| if bit 7 not set, this entry cannot be used, goto 0x090B and exit
	bpl.b	1f
	* JOTD: data is even aligned so we can write command & args
	* atomicly, in the original there's a slight chance that
	* the command queue is processed between both writes
	move.w	d3,(a0)+
	cmp.l	#CIRC_CMD_QUEUE_END,a0
	bne.b	0f
	move.l	#CIRC_CMD_QUEUE_START,a0
0:
	move.l	a0,CIRC_CMD_QUEUE_PTR		| update CIRC_CMD_QUEUE_PTR_LO to point to next queue entry
1:
	move.l	(a7)+,a0
	rts
	



*
* Called from $0004.
* 
*
*
	
INITIALISE_SYSTEM:  | 1A55

* Clear screen 
	move	#0x400-1,d1
	move	#0x10,d0
	move.w	#0x5000,d6
0:
	jbsr		osd_w_bg_videoram
	addq.w	#1,d6
	dbf		d1,0b
	
* clear attributes and reset scroll values
	move	#0x100-1,d1
	moveq	#0,d0
	move.w	#0x5400,d6
0:
	jbsr		osd_w_bg_colorram	| write 0 to screen attribute RAM. Will both set colour to 0 and reset column scroll.
	addq.w	#1,d6
	dbf		d1,0b
	
* (skipped startup checks!)

* When we get here, all the diagnostic tests have succeeded. 
* There are no errors, and the game can start proper.
* original game sets all to 0 except for 0x40C0->0x4100
* I almost could blindly follow that but some of the pointers
* are 1-byte pointer nibbles, had to switch to full 32 bit

	lea		VARIABLES_START(pc),a0		| Start of working RAM
	move.w	#VARIABLES_END-VARIABLES_START-1,d0
0:
	clr.b	(a0)+
	dbf		d0,0b
	
	* message queue set to all invalid (negative)
	lea		CIRC_CMD_QUEUE_START(pc),a0
	move.w	#CIRC_CMD_QUEUE_END-CIRC_CMD_QUEUE_START-1,d0
1:
	st.b	(a0)+
	dbf		d0,1b
	
	move.b	#0x20,TEMP_COUNTER_1			| set TEMP_COUNTER_1
	move.b	#3,DIAGNOSTIC_MESSAGE_TYPE
	lea		CIRC_CMD_QUEUE_START(pc),a0
	move.l	a0,CIRC_CMD_QUEUE_PTR			| reset CIRC_CMD_QUEUE_PTR
	move.l	a0,CIRC_CMD_QUEUE_PROC			| reset CIRC_CMD_QUEUE_PROC
	
	jbsr	osd_stars_on					| Set 9Nregen stars on. Starry background now appears 
	jbsr	osd_enable_vblank_interrupt		| Enable 9Nregen NMIon
	
	* part done in diagnostic, we don't want diagnostic but we need those inits
	move.w	#0x5000,TEMP_CHAR_RAM_PTR    | set TEMP_CHAR_RAM_PTR
	move.b	#0x20,TEMP_COUNTER_1
	clr.b	DIAGNOSTIC_MESSAGE_TYPE
	clr.b	SCRIPT_NUMBER

*	bra		jmp_2000
*	nop
	

* reset all player-related state including score, high score
jmp_2000:
	lea		PLAYER_ONE_SCORE(pc),a0
	move.w	#(CIRC_CMD_QUEUE_START-PLAYER_ONE_SCORE)/2-1,d0
0:
	clr.w	(a0)+
	dbf		d0,0b
	
	* now would be a good time to read highscore from saved state
	lea		PLAYER_ONE_SCORE(pc),a0
	*bsr		osd_read_hiscores
*
* Process the circular command queue starting @ 0x40C0 (CIRC_CMD_QUEUE_START)
*
* Notes:
* The value in 0x40A1 (I have named it CIRC_CMD_QUEUE_PROC_LO) is the low byte of a pointer to the first entry in 
* the queue to be processed. The high byte of the pointer is always #0x40.
* 
* In a circular queue, the first entry to be processed is not necessarily the head of the queue. 
* The first entry to be processed could be anywhere in the queue. 
*


PROCESS_CIRCULAR_COMMAND_QUEUE:
0:
	move.l	CIRC_CMD_QUEUE_PROC(pc),a0		| now a0 = pointer to a queue entry in the queue to be processed
	moveq	#0,d0
	move.b	(a0),d0							| read command number from queue entry into d0. 
	add.b	d0,d0							| multiply d0 by 2 to form an offset into jump table @0x203D
	bcc.b	1f
	
    jbsr		HANDLE_SWARM_ANIMATION
	bra.b	0b								| process next entry in circular queue
1:
	and  #0x0F,d0                 | mask in lower nibble
	add		d0,d0							| multiply d0 by 4 to form an offset into jump table @0x203D
	lea	jump_table_203D(pc),a1			| pointer to jump table beginning @ 0x203D
	move.l	(a1,d0.w),a1
	
	st	(a0)+                             | write #0xFF (255 decimal) to first byte of byte pair, to mark it as "free"
	move.b	(a0),d4		                  | read parameter value from queue entry into E. 
	st	(a0)+                             | write #0xFF (255 decimal) to second byte of byte pair, to mark it as "free"
	cmp.l	#CIRC_CMD_QUEUE_END,a0		  | is HL == 0x4100? If so, comparing L (which will be 0) to #0xC0 (192 decimal) will set the carry flag. 
	bcs.b	2f							  | if carry is set, then we have not reached the end of the queue (0x4100), goto 0x202C
	lea		CIRC_CMD_QUEUE_START(pc),a0		  | otherwise, we have reached end of queue. 
2:
	move.l	a0,CIRC_CMD_QUEUE_PROC       | Set lo byte of pointer to 0xC0 (0x40C0 = start of circular queue)
	move.b	d4,d0		                 | Now d0 = parameter to command
	pea		0b(pc)						 | push it onto stack, so when we hit a RET it'll return to 0x200A
	jmp		(a1)		                 | jump to proper code from the table below					 

jump_table_203D:
    .long	DRAW_ALIEN_COMMAND
    .long	DELETE_ALIEN_COMMAND
    .long	DISPLAY_PLAYER_COMMAND
    .long	UPDATE_PLAYER_SCORE_COMMAND
    .long	RESET_SCORE_COMMAND
    .long	DISPLAY_SCORE_COMMAND
    .long	PRINT_TEXT_COMMAND
    .long	DISPLAY_BOTTOM_OF_SCREEN_COMMAND
	
DRAW_ALIEN_COMMAND:
	rts
	
DELETE_ALIEN_COMMAND:
	rts
	
DISPLAY_PLAYER_COMMAND:
	rts
	
UPDATE_PLAYER_SCORE_COMMAND:
	rts
	
RESET_SCORE_COMMAND:
	rts
	
	
*
* A = index of string to print
*
* Bit 6 set: scroll this text onto screen
* Bit 7 set: clear this text
*
* Value in A (ANDed with 0x3F)       Text printed
* =============================================================
* 0                                 GAME OVER
* 1                                 PUSH START BUTTON  
* 2                                 PLAYER ONE 
* 3                                 PLAYER TWO 
* 4                                 HIGH SCORE
* 5                                 CREDIT
* 6                                 BONUS GALIXIP FOR   000 PTS
* 7                                 CONVOY CHARGER 
* 8                                 - SCORE ADVANCE TABLE -
* 9                                 MISSION: DESTROY ALIENS
* A                                 WE ARE THE GALAXIANS
* B                                 30       60  PTS 
* C                                 40       80  PTS
* D                                 50      100  PTS
* E                                 60      300  PTS
* F                                 NAMCO logo
* 10                                FREE PLAY

PRINT_TEXT_COMMAND:
	lea	TEXTPTRS(pc),a0
	add.w	d0,d0
	move.w	d0,-(a7)
	add.w	d0,d0
	and.w	#0x7F,d0   | mask in bits 0..6. Now A = a value in range of 0..127
	move.l	(a0,d0.w),a0	| HL now points to an entry in the TEXTPTRS lookup table.
	move.w	(a0)+,d6		| DE = *HL. Now DE holds character RAM address to print text at
							| Now HL = pointer to character RAM, DE = pointer to text to print
	move.w	#-0x20,d5         | offset to add to HL after every character write. (-32 in decimal)
	move.w	(a7)+,d2	
	*2309: 38 0E         jr   c,0x2319  *TODO ???? erase??
	*bmi.b	l_2323		| if minus flag is set, then we want to scroll text onto screen - goto 0x2323
0:
	move.b	(a0)+,d0     | read character to be drawn   
	sub.b	#0x30,d0
	cmp.b	#0xF,d0		| is this the string terminator, #0x3F?
	bne.b	1f
	rts					| yes, so exit routine
1:
	jbsr	osd_w_bg_videoram
	add.w	d5,d6		| Add offset to screen address so that next character is drawn at correct location.   
	bra.b	0b			| and continue

* I'll stick my neck out and guess this code is to erase text that was drawn previously.
*2319: 1A            ld   a,(de)
*231A: FE 3F         cp   0x3F
*231C: C8            ret  z
*231D: 36 40         ld   (hl),0x40
*231F: 13            inc  de
*2320: 09            add  hl,bc
*2321: 18 F6         jr   0x2319

*
* Set text up for scrolling. Invoked by 0x230B within PRINT_TEXT_COMMAND
*
* HL = pointer to character RAM
* DE = pointer to text string to render
*

l_2323:

* 22 B5 40      ld   (0x40B5),hl          | store pointer to character RAM in COLUMN_SCROLL_CHAR_RAM_PTR
*2326: EB            ex   de,hl               | now HL = pointer to text string, DE = pointer to character RAM 
*2327: 22 B3 40      ld   (0x40B3),hl          | store pointer to next char to scroll on in COLUMN_SCROLL_NEXT_CHAR_PTR
*232A: 7B            ld   a,e                 | get low byte of character RAM address into A
*232B: E6 1F         and  0x1F                 | mask in bits 0..4. Effectively A = A mod #0x20 (32 decimal). A now represents a column index from 0-31.
*232D: 47            ld   b,a                 | save column index in B.
** compute offset into OBJRAM_BACK_BUF
*232E: 87            add  a,a                 | A=A*2. This is because attribute RAM requires 2 bytes per column. 
*232F: C6 20         add  a,0x20               | add 0x20 (32 decimal) as OBJRAM_BACK_BUF starts at 0x4020
*2331: 6F            ld   l,a                 | 
*2332: 26 40         ld   h,0x40               | now HL = a pointer to scroll attribute value in OBJRAM_BACK_BUF 
*2334: 22 B1 40      ld   (0x40B1),hl          | set COLUMN_SCROLL_ATTR_BACKBUF_PTR
*2337: E5            push hl                  | save pointer to scroll offset attribute on the stack
*
*2338: CB 3B         srl  e
*233A: CB 3B         srl  e
*233C: 7A            ld   a,d                
*233D: E6 03         and  0x03
*233F: 0F            rrca
*2340: 0F            rrca
*2341: B3            or   e
*2342: E6 F8         and  0xF8
*2344: 4F            ld   c,a                 | C = scroll offset to write to OBJRAM_BACK_BUF 
*
** we're going to clear this line ready for scrolling text on.
*2345: 21 00 50      ld   hl,0x5000            | HL = start of character RAM
*2348: 78            ld   a,b                 | restore column index from B (see @0x232D)
*2349: 85            add  a,l                 
*234A: 6F            ld   l,a                 | Add column index to L. Now HL = pointer to column to clear
*234B: 11 20 00      ld   de,0x0020            | offset to add to HL. 0x20 (32 decimal) characters per row
*234E: 43            ld   b,e                 | B = count of how many characters need to be cleared by DJNZ loop
*234F: 36 10         ld   (hl),0x10            | write empty space character
*2351: 19            add  hl,de               | add offset to HL. Now HL points to same column next row down
*2352: 10 FB         djnz 0x234F
*2354: E1            pop  hl                  | restore attribute pointer from the stack
*2355: 71            ld   (hl),c              | write initial scroll offset to OBJRAM_BACK_BUF
*2356: 3E 01         ld   a,0x01
*2358: 32 B0 40      ld   (0x40B0),a           | set IS_COLUMN_SCROLLING flag
*235B: C9            ret

TEXTPTRS:                                     
	dc.l	TXT_GAME_OVER
	dc.l	TXT_PUSH_START_BUTTON  
	dc.l	TXT_PLAYER_ONE 
	dc.l	TXT_PLAYER_TWO 
	dc.l	TXT_HIGH_SCORE
	dc.l	TXT_CREDIT
	dc.l	TXT_BONUS_GALIXIP_FOR___000_PTS  
	dc.l	TXT_CONVOY_CHARGER 
	dc.l	TXT___SCORE_ADVANCE_TABLE__
	dc.l	TXT_MISSION__DESTROY_ALIENS
	dc.l	TXT_WE_ARE_THE_GALAXIANS
	dc.l	TXT_30_______60__PTS 
	dc.l	TXT_40_______80__PTS
	dc.l	TXT_50______100__PTS
	dc.l	TXT_60______300__PTS
	dc.l	TXT_NAMCO_logo
	dc.l	TXT_FREE_PLAY


*
* Selects information to be displayed at the bottom of the screen.
*
* On entry:
* A identifies what to be displayed.
*
* Value in d0                Action taken                                                                 See also 
* ===============================================================================================================================================
* 0                         The player advances to the next level and the red level flags are redrawn.   See: 0x2520 (DISPLAY_LEVEL_FLAGS)
* 1                         Display FREE PLAY or CREDIT n at bottom left of screen.                      See: 0x24EB (DISPLAY_AVAILABLE_CREDIT)
* 2                         Display BONUS GALIXIP FOR (nnnnn) PTS on screen.                             See: 0x24C8 (DISPLAY_BONUS_GALIXIP_FOR)
* Any other value           Display player ships remaining at bottom left of screen.                     See: 0x22B3 (DISPLAY_PLAYER_SHIPS_REMAINING)
*
DISPLAY_BOTTOM_OF_SCREEN_COMMAND:
	tst.b	d0
	jeq		DISPLAY_LEVEL_FLAGS		| if parameter is 0
	subq.b	#1,d0
	jeq		DISPLAY_AVAILABLE_CREDIT	| if parameter was 1
	subq.b	#2,d0
	jeq		DISPLAY_BONUS_GALIXIP_FOR	| if parameter was 2
	
	move.b	PLAYER_LIVES(pc),d1
	jra		DISPLAY_PLAYER_SHIPS_REMAINING
	

*
* Displays the text string BONUS GALIXIP FOR (nnnnn) on screen.
*

DISPLAY_BONUS_GALIXIP_FOR:
	move.b	BONUS_GALIXIP_FOR(pc),d0
	cmp.b	#0xFF,d0     | check if there is any bonus. I think this code is redundant.
	bne.b	0f
	rts                   | if no bonus, then return
0:
	move.b	#6,d0               | index of BONUS GALIXIP FOR 0000 PTS text string
    jbsr PRINT_TEXT_COMMAND               | display text on screen
    move.b	BONUS_GALIXIP_FOR(pc),d0           | read BONUS GALIXIP value
    and.b  #0x0F,d0                 | mask in low nibble
	move.w	#0x5138,d6           | write value to character RAM
    move.b	BONUS_GALIXIP_FOR(pc),d0           | read BONUS GALIXIP value
	and.b  #0xF0,d0			| mask in high nibble
    bne.b	1f            | if it's !=0, goto 0x24E3
    addq.b	#1,d0
1:
    lsr.w	#4,d0          | move high nibble...
							| ... into lower nibble, so that A is now a number from 0..9
	move.w	#0x5158,d6
	jbra		osd_w_bg_videoram   | and POKE number to screen RAM, displaying single digit in correct place
    *rts                      | we're out


*
* Displays either FREE PLAY or CREDIT (n) at bottom left of screen
*

DISPLAY_AVAILABLE_CREDIT:
      tst.b	IS_GAME_IN_PLAY
	  beq.b	0f
	  rts						| if the game is in play, return.
0:
      move.b	PORT_STATE_6800(pc),d1           | read PORT_STATE_6800
      and.b   #0xC0,d1                 | mask in dip switch 1 & 2 state
      move.b	#0x10,d0               | index of text string "FREE PLAY"
      cmp.b   #0xC0,d1                 | are both dip switches on?
      beq	PRINT_TEXT_COMMAND

* if we get here, then we're not in FREE PLAY mode. We will display number of credits on screen.
      move.b	#0x05,d0               | index of text string "CREDIT"
      jbsr PRINT_TEXT_COMMAND
	  moveq	#0,d0
      move.b	NUM_CREDITS,d0          | read number of credits
      cmp.b	#0x63,d0                 | compare to 99 decimal
      bcs.b		1f             | if A <99 then goto 0x250A
      move.w	#99,d0               | clamp number of credits to 99
1:
      jbsr CONVERT_A_TO_BCD     |  Now A = BCD equivalent of what it was
      move.b	d0,d1           | save credits as BCD in B
      and.b  #0xF0,d0                 | mask in high nibble, which is first digit of BCD
      beq.b	2f             | if the first digit is 0, goto 0x2519. We don't display it.
      lsr.w	#4,d0                    | shift high nibble...
                                     | to low nibble.. converting first BCD digit to decimal.
      move.w	#0x529F,d6           | Write first digit of credits to character RAM
	  bsr		osd_w_bg_videoram
2:
      move.b	d1,d0              | get credits as BCD into A again. We preserved it in B @0x250D
      and.b  #0x0F,d0                 | mask in low nibble, which is second digit of BCD. Converts second BCD digit to decimal.
	  move.w	#0x527F,d6
      bsr		osd_w_bg_videoram           | Write second digit of credits to character RAM 
      rts                      


*
* Called when the player has completed the level.
*
* This routine:
*    Resets the swarm tempo|
*    increments the player level (48 levels maximum)|
*    Draws level flags. 
*

DISPLAY_LEVEL_FLAGS:
      tst.b	HAVE_NO_ALIENS_IN_SWARM   | test if flag is set
      beq.b	0f             | if flag is not set, goto 0x252C
      move.b  #1,RESET_SWARM_SOUND_TEMPO     | set  flag to 1. The swarm tempo will be slow again. 
0:
      move.b	PLAYER_LEVEL(pc),d0           | read .
      addq.b	#1,d0                   | increment it.
      cmp.b	#0x30,d0                 | Compare to #0x30 (48 decimal)
      bcs.b	     1f        | if A < 48, goto 0x2536
      move.b	#0x30,d0               | Level 48 is the limit.
1:
* A = level number (0-48)
      jbsr CONVERT_A_TO_BCD               | convert A to BCD. Now A = BCD equivalent 

* A = level number in BCD
	move.w	d0,-(a7)
    move.w	#0x507E,d6              | address in character RAM to start drawing flags at
    and.b  #0xF0,d0                 | mask in high nibble
    beq.b	3f                      | if the high nibble is zero, then goto 0x2551

* Calculate how many "10" flags we are going to draw
    lsr.w	#4,d0                     | shift bits in high nibble of BCD number....
									  | to lower nibble.
	move.b	d0,d1                 | B now holds the number of red "10" flags to draw at the bottom right of the screen.
	and.w	#0xFF,d1
	subq.w	#1,d1
	move.b	#0x10,d2              | C is a count of how much space, in characters, we have to plot flags. We start with #0x10 (16 decimal) 
2:
	move.b	#0x68,d0               | ordinal of first character of "10" flag to plot
	jbsr	PLOT_CHARACTERS_2_BY_2_ASCENDING               | plot the flag with "10" on it
	subq.b	#2,d2                   | A "10" flag takes up 2 spaces..
									| ..so reduce C by 2.
	dbf		D1,2b               | repeat until B==0
3:
      move.w	(a7)+,d0

* Calculate how many normal red flags we are going to draw
* A=level number in BCD
    and.b  #0x0F,d0                 | mask in lower nibble of BCD number. Now A represents how many flags we are going to draw.
	moveq	#0,d1
	move.w	#0x1F,d3           | offset to add to HL after every flag drawn.
    move.b	d0,d1                 | B = number of flags to draw
	beq.b	5f				             | if we don't have any flags to draw then goto 0x2562
	subq.b	#1,d1
4:
    move.b	#0x6C,d0               | ordinal of first character to plot
    jbsr PLOT_TWO_CHARS_ON_SAME_ROW               | draw the normal flag on character map
    subq.b	#1,d2                   | A normal flag takes up just 1 character space, so reduce C by 1
    dbf		d1,4b               | repeat until B == 0
5:
* if we get here, we want to erase any flags left from the previous level
    subq.b	#1,d2              | decrement "space for characters remaining" count in C
    bpl.b	6f                   | return if c has become a negative value. 
	rts
6:
    jbsr	l_259E               | plot spaces to overwrite any existing flags
    bra.b	5b


DISPLAY_PLAYER_SHIPS_REMAINING:
	move.w	0x539E,d6          | address in character RAM
	move.w	#5,d2
	move.b	HAS_PLAYER_SPAWNED(pc),d0
    beq.b	0f                       
    subq.b	#1,d1
	beq.b	1f
	and.w	#0xFF,d1
	subq.b	#1,d1
0:
    move.b	#0x66,d3
    jbsr l_2593               | plot 2X2 characters
    subq.b	#1,d2
    dbf		d1,0b
1:
	subq.b	#1,d2
	bpl.b	2f
	rts
2:
	jbsr PLOT_CHARACTERS_2_BY_2_DESCENDING               | plot spaces to screen
	bra.b	1b
	
	
HANDLE_SWARM_ANIMATION:
	**move.w	#0xF00,0xdff180		| unimplemented
	rts

* Called to display "BAD RAM [n]" or "BAD ROM [n]""
* (just to debug our font engine!!)
DISPLAY_BAD_RAM_OR_ROM_MESSAGE:
	lea		bad_rom(pc),a0
	move.w	#0x5233,d6            | character RAM address to print text at
	move.w	#0x20,d2
	move.w	#6,d3               | there's 7 characters in "BAD RAM" (including the space between words)
0:
	move.b	(a0)+,d0
	jbsr	osd_w_bg_videoram
	add.w	d2,d6
	dbf		d3,0b
1:
	bra.b	1b

l_2583:
	move.b	#0x2C,d0               | space character

*
* Draw 4 characters in a 2 x 2 layout. 
*
* register A is the ordinal of the first character to draw. 
* The next 3 characters are derived automatically by incrementing A after each character drawn.
*
* Expects:
* A = ordinal of first character to poke to character RAM. 
* HL = pointer to character RAM address
* 
* Resulting layout is:
*
* A   |  A+1
* ----------
* A+2 |  A+3
*

PLOT_CHARACTERS_2_BY_2_ASCENDING:
      move.w	D3,-(a7)
      move.w	#0x001F,d3            | load de with 31 decimal. This is the width of a row, in characters, minus 1.
      jbsr PLOT_TWO_CHARS_ON_SAME_ROW               | plot 2 characters on same row... 
l_258C:
      jbsr PLOT_TWO_CHARS_ON_SAME_ROW               | and 2 characters on the next row 
      move.w	(a7)+,d3
      rts


*
* Draw 4 characters in a 2 x 2 layout. 
*
* register A is the ordinal of the first character to draw. 
*
* Expects:
* A = ordinal of first character to poke to character RAM. 
* HL = pointer to character RAM address
* 
* Resulting layout is:
*
* A-2 |  A-1
* ----------
* A   |  A+1

PLOT_CHARACTERS_2_BY_2_DESCENDING:
    move.w	D3,-(a7)
l_2593:
	move.b	#0x2E,d0
PLOT_2X2_CHARACTERS:
	move.w	#-33,d3		| load de with -33 decimal as signed word
	jbsr	PLOT_TWO_CHARS_ON_SAME_ROW               | plot 2 characters on one row..	
	subq.b	#4,d0		| subtract 4 from A
	bra.b	l_258C		| plot 2 characters on row above


l_259E:
	move.b	#0x2C,d0               | space character
*
* Plots 2 contiguous characters on same row
* register A is the ordinal of the first character to draw. A+1 is drawn in the next column.
*
* Expects:
* A = ordinal of first character to plot
* HL = pointer to character RAM where first character will be plotted
* DE = offset to add to HL after both characters have been plotted
*
* Returns:
* HL = updated pointer to character RAM
*

PLOT_TWO_CHARS_ON_SAME_ROW:
   bsr		osd_w_bg_videoram              | plot first character
   addq.b  #1,d0                   | increment A
   addq.w	#1,d6                  | bump HL to next address in RAM
   bsr		osd_w_bg_videoram     | plot second character
   addq.b  #1,d0
   add.w	d3,d6               | add offset in DE to HL
   rts

l_25A7:
	move.b	#0x2C,d0

*
* Plots 2 characters in the same column, one beneath the other.
*
* register A is the ordinal of the first character to draw. A+2 is drawn in the same column of the row beneath.
*
* Expects:
* A = ordinal of first character to plot
* HL = pointer to character RAM where first character will be plotted
*

PLOT_TWO_CHARACTERS_IN_SAME_COLUMN:
	move.w	d3,-(a7)
	move.w	#0x20,d3      | each row is comprised of 0x20 (32 decimal) characters...
	jbsr	osd_w_bg_videoram           | plot first character
	addq.b	#2,d0
	add.w	d3,d6                      | bump HL to point to the character at the row beneath
	jbsr	osd_w_bg_videoram              | plot second character
	move.w	(a7)+,d3
	rts

*
* Convert value in register A to BCD equivalent 
* 
* For example, if you pass in 0x63 (99 decimal) in A, this function will return 99 BCD
* 
* Expects:
* d0 = non BCD value, from 0..99
*
* Returns:
* d0 = BCD equivalent
* 
* the Z80 code is pretty convoluted, but I don't understand why. Just create a table: done

CONVERT_A_TO_BCD:
	lea		bcd_table(pc),a0
	and.w	#0x7f,d0		| could read out the table if > 99 but who cares?
	move.b	(a0,d0.w),d0
	rts
	
** I try to put data in the end

bad_rom:
	dc.b	0x1D,0x1F,0x22,0x10,0x14,0x11,0x12 



DEFAULT_SWARM_DEFINITION_AND_PLAYER_STATE:    | EQU 0x051B
PACKED_DEFAULT_SWARM_DEFINITION:
    | The first 16 bytes defining the default alien swarm. 
    | For information on how the bytes are unpacked, please see docs @ 0x0646
    .byte	0x00,0x00,0x00,0x00,0xF8,0x1F,0xF8,0x1F,0xF8,0x1F,0xF0,0x0F,0xE0,0x07,0x40,0x02

    | When starting a new game, these are the default values 
DEFAULT_PLAYER_STATE:
	.byte	0x3C                                 | Default value for DIFFICULTY_COUNTER_1 
    .byte	0x14                                 | Default value for DIFFICULTY_COUNTER_2
    .byte	0x00,0x02,0x00,0x02,0x00,0x0F,0x00,0x00,0x00     

* Referenced by code @ 0x0595
COLOUR_ATTRIBUTE_TABLE_1:
	.byte	0x00,0x05,0x00,0x00,0x01,0x01,0x02,0x03,0x03,0x04,0x04,0x04,0x04,0x00,0x00,0x00
	.byte	0x00,0x00,0x00,0x05,0x05,0x05,0x05,0x05,0x00,0x00,0x06,0x06,0x06,0x06,0x06,0x06
	
* Referenced by code @ 0x0408
COLOUR_ATTRIBUTE_TABLE_2:
	.byte	0x00,0x05,0x00,0x00,0x01,0x01,0x02,0x03,0x03,0x04,0x04,0x04,0x04,0x00,0x00,0x00
	.byte	0x06,0x06,0x06,0x06,0x06,0x06,0x05,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06

* Referenced by code @ 0x0212
COLOUR_ATTRIBUTE_TABLE_3:
	.byte	0x00,0x05,0x00,0x00,0x01,0x01,0x02,0x03,0x05,0x04,0x05,0x04,0x04,0x00,0x00,0x00
	.byte	0x00,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x00,0x00,0x07,0x07,0x06,0x06
* ",".join("0x{}".format(x) for x in s.split())

* Referenced by code @ 0x0D1D
	.byte	0x00,0x00,0x00,0x00,0x04,0x01,0x04,0x02,0x04,0x01,0x03,0x03,0x02,0x02,0x01,0x02

* address to print followed by text
	.align	2
TXT_GAME_OVER:
	.word	0x5296
	.ascii	"GAME@@OVER?"
	.align	2
TXT_PUSH_START_BUTTON:
	.word	0x52f1
	.ascii	"PUSH@START@BUTTON?"
	.align	2
TXT_PLAYER_ONE:
	.word	0x5294
	.ascii	"PLAYER@ONE?"
	.align	2
TXT_PLAYER_TWO:
	.word	0x5294
	.ascii	"PLAYER@TWO?"
	.align	2
TXT_HIGH_SCORE:
	.word	0x5280
	.ascii	"HIGH@SCORE?"
	.align	2
TXT_CREDIT:
	.word	0x537F
	.ascii	"CREDIT?"
	.align	2
TXT_BONUS_GALIXIP_FOR___000_PTS:
	.word	0x537F
	.ascii	"BONUS@GALIXIP@FOR@@@000@PTS?"
	.align	2
TXT_CONVOY_CHARGER:
	.word	0x52D1
	.ascii	"CONVOY@@CHARGER?"
	.align	2
TXT___SCORE_ADVANCE_TABLE__:
	.word	0x534F
	.ascii	"[@SCORE@ADVANCE@TABLE@[?"
	.align	2
TXT_MISSION__DESTROY_ALIENS:
	.word	0x5369
	.ascii	"MISSION"
	.byte	0xd3
	.ascii	"@DESTROY@ALIENS?"
	.align	2
TXT_WE_ARE_THE_GALAXIANS:
	.word	0x5327
	.ascii	"WE@ARE@THE@GALAXIANS?"
	.align	2
TXT_30_______60__PTS:
	.word	0x52D9
	.ascii	"@@30@@@@@@@60@@"
	.byte	0xD1,0xD2,0xD3,0x3F
	.align	2
TXT_40_______80__PTS:
	.word	0x52D7
	.ascii	"@@40@@@@@@@80@@"
	.byte	0xD1,0xD2,0xD3,0x3F
	.align	2
TXT_50______100__PTS:
	.word	0x52D5
	.ascii	"@@50@@@@@@100@@"
	.byte	0xD1,0xD2,0xD3,0x3F
	.align	2
TXT_60______300__PTS:
	.word	0X52D3
	.ascii	"@@60@@@@@@300@@"
	.byte	0xD1,0xD2,0xD3,0x3F
	.align	2
TXT_NAMCO_logo:
	.word	0x52C7
	.byte	0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0x9E,0x9F,0x3F
	.align	2
TXT_FREE_PLAY:
	.word	0x537F
	.ascii	"FREE@PLAY?"

* The tables @0x039A and 0x03A6 represent the points values displayed beneath the SCORE ADVANCE TABLE.
* These values are NOT BCD! They are ordinals for characters to be POKEd directly to character RAM.

* This table is for the Flagship
flagship_table_039A: 
	.byte	0x01,0x05,0x00            | 150 
	.byte	0x02,0x00,0x00            | 200
	.byte	0x03,0x00,0x00            | 300
	.byte	0x08,0x00,0x00            | 800

* This table is for the normal aliens
* Note: 10 is a space (empty) character
alien_table_03A6: 
	.byte	0x01,0x00,0x00            | 100   
	.byte	0x10,0x08,0x00            |  80   
	.byte	0x10,0x06,0x00            |  60    
	.align	2

bcd_table:
	.byte	0x0
	.byte	0x1
	.byte	0x2
	.byte	0x3
	.byte	0x4
	.byte	0x5
	.byte	0x6
	.byte	0x7
	.byte	0x8
	.byte	0x9
	.byte	0x10
	.byte	0x11
	.byte	0x12
	.byte	0x13
	.byte	0x14
	.byte	0x15
	.byte	0x16
	.byte	0x17
	.byte	0x18
	.byte	0x19
	.byte	0x20
	.byte	0x21
	.byte	0x22
	.byte	0x23
	.byte	0x24
	.byte	0x25
	.byte	0x26
	.byte	0x27
	.byte	0x28
	.byte	0x29
	.byte	0x30
	.byte	0x31
	.byte	0x32
	.byte	0x33
	.byte	0x34
	.byte	0x35
	.byte	0x36
	.byte	0x37
	.byte	0x38
	.byte	0x39
	.byte	0x40
	.byte	0x41
	.byte	0x42
	.byte	0x43
	.byte	0x44
	.byte	0x45
	.byte	0x46
	.byte	0x47
	.byte	0x48
	.byte	0x49
	.byte	0x50
	.byte	0x51
	.byte	0x52
	.byte	0x53
	.byte	0x54
	.byte	0x55
	.byte	0x56
	.byte	0x57
	.byte	0x58
	.byte	0x59
	.byte	0x60
	.byte	0x61
	.byte	0x62
	.byte	0x63
	.byte	0x64
	.byte	0x65
	.byte	0x66
	.byte	0x67
	.byte	0x68
	.byte	0x69
	.byte	0x70
	.byte	0x71
	.byte	0x72
	.byte	0x73
	.byte	0x74
	.byte	0x75
	.byte	0x76
	.byte	0x77
	.byte	0x78
	.byte	0x79
	.byte	0x80
	.byte	0x81
	.byte	0x82
	.byte	0x83
	.byte	0x84
	.byte	0x85
	.byte	0x86
	.byte	0x87
	.byte	0x88
	.byte	0x89
	.byte	0x90
	.byte	0x91
	.byte	0x92
	.byte	0x93
	.byte	0x94
	.byte	0x95
	.byte	0x96
	.byte	0x97
	.byte	0x98
	.byte	0x99
	
