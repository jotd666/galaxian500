*
* Galaxian (C) 1979 NAMCO.
*
* Reverse engineering work by Scott Tunstall, Paisley, Scotland. 
* Tools used: MAME debugger & Visual Studio Code text editor.
* Date: 7 July 2019.  
* 
* Please send any questions, corrections and updates to scott.tunstall@ntlworld.com
*
* Be sure to check out my reverse engineering work for Robotron 2084 and Scramble too, 
* at http://seanriddle.com/robomame.asm and http://seanriddle.com/scramble.asm asm respectively.
*
* Finally:
* If you'd like to show appreciation for this work by buying me a coffee, feel free: https://ko-fi.com/scotttunstall
* I'd be equally happy if you donated to Parkinsons UK or Chest Heart And Stroke (CHAS) Scotland.
* Thanks.  
*
* 68k transcode by JOTD in 2023 using Scott excellent work
*
* - first started by hand discovering routines from the entrypoint
*   (which explains why routines aren't in the same order as Scrott z80 code
*   but I tried to preserve the names)
* - then wrote and used z80268k.py tool to convert most of the instructions (https://github.com/jotd666/amiga68ktools)
* - then reworked tool output to fix unconverted instructions, optimize
*   multiple bit shifts, boolean tests using strange ror+carry test sometimes,
*    bit test replaced by tst.b...
* re-injected offsets & symbols that Scott had put in comments, fixing a few mistakes
*  (fortunately mistakes were very rare!)
  
* register conventions (imposed by z80268k mostly) are as follows:
*
* A: D0
* B: D1
* C: D2
* BC: manual
* D: D3
* E: D4
* DE: A1
* H: D5
* L: D6
* HL: A0 or D6 (video addresses)
* carry: manual, using D7 (push/pop af has no portable equivalent as SR is privileged on 68020+)
*
* depending on the context H/L/HL and D/E/DE require rework as the game
* constructs pointers from 0x100-page aligned pointers to avoid to handle
* lsb wrap and msb increase. Of course the 68000 can do that so easily. But
* it cannot split address registers :) 
*
* screen addresses (0x5000-0x5400) are usually pointed by HL but in the API
* I chose to store the value in D6 as it's not really an address now but rather
* an offset to video memory once you subtract 0x5000


FAST_INTRO_TEXT = 1

* exports

    * ROM

    .global galaxian_irq
    .global galaxian_reset

	
	.include "galaxian.inc"

galaxian_reset:
	bra		INITIALISE_SYSTEM

	

/*
Conventions: 

NUMBERS
=======

The term "@ $" means "at memory address in hexadecimal". 
e.g. @ $1234 means "refer to memory address 1234" or "program code @ memory location 1234" 

The term "#$" means "immediate value in hexadecimal". It's a habit I have kept from 6502 days.
e.g. #$60 means "immediate value of 60 hex" (96 decimal)

If I don't prefix a number with $ or #$ in my comments, treat the value as a decimal number.


LABELS
======
I have a labelling convention in place to help you identify the important parts of the code quicker.
Any subroutine labelled with the SCRIPT_ , DISPLAY_ or HANDLE_ prefix are critical "top-level" functions responsible 
for calling a series of "lower-level" functions to achieve a given result.   

If this helps you any, think of the "top level" as the main entry point to code that achieves a specific purpose.  

Routines prefixed HANDLE_ manage a particular aspect of the game.
    For example, HANDLE_PLAYER_MOVE is the core routine for reading the player joystick and moving the player ship. 
    HANDLE_PLAYER_SHOOT is the core routine for reading the player fire button and spawning a bullet.

I expect the purpose of DISPLAY_ is obvious.

SCRIPTS are documented below - see docs for SCRIPT_NUMBER ($4005)


ARRAYS, LISTS, TABLES
=====================

The terms "entry", "slot", "item", "record" when used in an array, list or table context all mean the same thing.
I try to be consistent with my terminology but obviously with a task this size that might not be the case.

Unless I specify otherwise, I all indexes into arrays/lists/tables are zero-based, 
meaning element [0] is the first element, [1] the second, [2] the third and so on.

FLAGS
=====
The terms "Clear", "Reset", "Unset" in a flag context all mean the flag is set to zero.
                                                                               

COORDINATES
===========

X,Y refer to the X and Y axis in a 2D coordinate system, where X is horizontal and Y is vertical.

The Galaxian monitor is rotated 90 degrees. This means that:
a) updating the hardware Y position of a sprite presents itself to the player as changing the horizontal position.
   To make a sprite appear to move left, you would increment its Y position.
   To make a sprite appear to move right, you would decrement its Y position.

b) updating the hardware X position of a sprite presents itself to the player as changing the vertical position. 
   To make a sprite appear to move up, you would decrement its X position.
   To make a sprite appear to move down, you would increment its X position.

So when you see code updating the Y coordinate when you would expect X to be updated, or vice versa, you now know why.

For info about the Galaxian video hardware see: https://github.com/mamedev/mame/blob/master/src/mame/video/galaxian.cpp


Copied from MAME4All documentation: https://github.com/squidrpi/mame4all-pi/blob/master/src/drivers/galaxian.cpp
Some corrections applied from: https://github.com/mamedev/mame/blob/master/src/mame/galaxian/galaxian.cpp

Galaxian/Moon Cresta memory map.
Compiled from information provided by friends and Uncles on RGVAC.

Add 0x4000 to all addresses except for the ROM for Moon Cresta.
            AAAAAA
            111111AAAAAAAAAA     DDDDDDDD   Schem   function
HEX         5432109876543210 R/W 76543210   name
0000-3FFF                                           Game ROM
4000-47FF                                           Working ram
5000-57FF   01010AAAAAAAAAAA R/W DDDDDDDD   !Vram   Character ram           
5800-583F   01011AAAAAAAAAAA R/W DDDDDDDD   !OBJRAM Screen attributes
5840-585F   01011AAAAAAAAAAA R/W DDDDDDDD   !OBJRAM Sprites
5860-5FFF   01011AAAAAAAAAAA R/W DDDDDDDD   !OBJRAM Bullets
6000        0110000000000000 R   -------D   !SW0    coin1
6000        0110000000000000 R   ------D-   !SW0    coin2
6000        0110000000000000 R   -----D--   !SW0    p1 left
6000        0110000000000000 R   ----D---   !SW0    p1 right
6000        0110000000000000 R   ---D----   !SW0    p1shoot
6000        0110000000000000 R   --D-----   !SW0    upright/cocktail
6000        0110000000000000 R   -D------   !SW0    test
6000        0110000000000000 R   D-------   !SW0    service
6000        0110000000000001 W   -------D   !DRIVER lamp 1
6001        0110000000000001 W   -------D   !DRIVER lamp 2
6002        0110000000000001 W   -------D   !DRIVER coin lockout
6003        0110000000000011 W   -------D   !DRIVER coin control
6004        0110000000000100 W   -------D   !DRIVER Background lfo freq bit0
6005        0110000000000101 W   -------D   !DRIVER Background lfo freq bit1
6006        0110000000000110 W   -------D   !DRIVER Background lfo freq bit2
6007        0110000000000111 W   -------D   !DRIVER Background lfo freq bit3
6800        0110100000000000 R   -------D   !SW1    1p start
6800        0110100000000000 R   ------D-   !SW1    2p start
6800        0110100000000000 R   -----D--   !SW1    p2 left
6800        0110100000000000 R   ----D---   !SW1    p2 right
6800        0110100000000000 R   ---D----   !SW1    p2 shoot
6800        0110100000000000 R   --D-----   !SW1    no used
6800        0110100000000000 R   -D------   !SW1    dip sw1
6800        0110100000000000 R   D-------   !SW1    dip sw2
6800        0110100000000000 W   -------D   !SOUND  reset background F1
                                                    (1=reset ?)
6801        0110100000000001 W   -------D   !SOUND  reset background F2
6802        0110100000000010 W   -------D   !SOUND  reset background F3
6803        0110100000000011 W   -------D   !SOUND  player hit
6804        0110100000000100 W   -------D   !SOUND  not used
6805        0110100000000101 W   -------D   !SOUND  shoot on/off
6806        0110100000000110 W   -------D   !SOUND  Vol of f1
6807        0110100000000111 W   -------D   !SOUND  Vol of f2

7000        0111000000000000 R   -------D   !DIPSW  dip sw 3
7000        0111000000000000 R   ------D-   !DIPSW  dip sw 4
7000        0111000000000000 R   -----D--   !DIPSW  dip sw 5
7000        0111000000000000 R   ----D---   !DIPSW  dip s2 6
7001/B000/1 0111000000000001 W   -------D   9Nregen NMIon
7002        Unused - thanks to Phil Murray for letting me know
7003        Unused
7004        0111000000000100 W   -------D   9Nregen stars on  
7006        0111000000000110 W   -------D   9Nregen hflip
7007        0111000000000111 W   -------D   9Nregen vflip
Note: 9n reg,other bits  used on moon cresta for extra graphics rom control.
7800        0111100000000000 R   --------   !wdr    watchdog reset
7800        0111100000000000 W   DDDDDDDD   !pitch  Sound Fx base frequency
*/

/*
DIP SWITCH SETTINGS

Taken from: http://arcarc.xmission.com/PDF_Arcade_Bally_Midway/Galaxian_Parts_and_Operating_Manual_(Feb_1980).pdf

METHOD OF PLAY:
                              SW.1          SW.2
1 COIN = 1 PLAY               OFF           OFF
2 COINS = 1 PLAY              ON            OFF
1 COIN = 2 PLAYS              OFF           ON
FREE PLAY                     ON            ON 


BONUS GALIXIP (PLAYER SHIP) - the manual above is not correct with the Namco Galaxian ROM. After doing some research,
here are the correct DIP switch settings: 


                              SW.3          SW.4
7000                          OFF           OFF  
10000                         ON            OFF
12000                         OFF           ON
20000                         ON            ON


NUMBER OF GALIXIP PER GAME
                               SW.5
2 GALIXIP PER GAME             OFF
3 GALIXIP PER GAME             ON

*/


/*
And now, the main game code.... enjoy.
*/

** variables
*
* struct INFLIGHT_ALIEN

IsActive              = 0x0            | Set to 1 when the alien is to be processed. 
IsDying               = 0x1            | Set to 1 when the alien is in the process of exploding.
StageOfLife           = 0x2            | See $0CD6 for details. 
inf_alien_X                     = 0x3            | X coordinate
inf_alien_Y                     = 0x4            | Y coordinate. 
AnimationFrame        = 0x5            |
ArcClockwise          = 0x6            | Set to 1 if the alien will rotate clockwise as it leaves the swarm or loops the loop. See $0D71 and $101F
IndexInSwarm          = 0x7            | index of alien within ALIEN_SWARM_FLAGS array
PivotYValue           = 0x9            | When alien is attacking, this value + $19 produces INFLIGHT_ALIEN.Y coordinate. See $0DF6
AnimFrameStartCode    = 0xF            | Base animation frame number to which a number is added to compute sprite "code"
TempCounter1          = 0x10           | Counter used for various timing purposes
TempCounter2          = 0x11           | Secondary counter for various timing purposes
DyingAnimFrameCode    = 0x12           | when IsDying is set to 1, specifies the animation frame to display. See @$0C9F
ArcTableLsb           = 0x13           | LSB of pointer into INFLIGHT_ALIEN_ARC_TABLE @$1E00. See docs @$0D71 and $1E00.
Colour                = 0x16           |
SortieCount           = 0x17           | Number of times the alien has reached the bottom of the screen then resumed attack on the player. Reset to 0 when rejoins swarm. See $0E9D.
Speed                 = 0x18           | Value from 0..3. The higher the number the faster the alien moves. See $116B. 
PivotYValueAdd        = 0x19           | Signed number which is added to INFLIGHT_ALIEN.PivotYValue to produce INFLIGHT_ALIEN.Y. See $0DF6

inflight_alien_size   = 0x20

* struct ENEMY_BULLET

*IsActive = 0
*XL = 1
YL = 2                                       | low byte of the Y coordinate. Used to represent "fractional part" of Y coordinate
YH = 3                                       | high byte of the Y coordinate.  
YDelta = 4                                   | packed delta to add to YH *and* YL. Bit 7 = sign bit. Bits 0-6 = delta. See @$0AA1.                                  
* - sizeof(ENEMY_BULLET) is 5 bytes

* sound
RESET_SOUND:
	jsr		osd_sound_stop
	rts
HANDLE_SOUND:
	clr.b	d0                               	| [xor  a]
	move.b	d0,SOUND_VOL                       	| clear SOUND_VOL [ld   (0x41C0),a]
	subq.b	#1,d0                           	| [dec  a]
	move.b	d0,PITCH_SOUND_FX_BASE_FREQ                       	| set PITCH_SOUND_FX_BASE_FREQ value [ld   (0x41C1),a]
	jbsr	HANDLE_GAME_START_MELODY    | [call 0x1747]
	jbsr	HANDLE_ALIEN_ATTACK_SOUND    |  [call 0x17D0]
	jbsr	HANDLE_ALIEN_DEATH_SOUND    |  [call 0x1819]
	jbsr	HANDLE_COMPLEX_SOUNDS    |  [call 0x175D]
	jbsr	HANDLE_EXTRA_LIFE_SOUND     | [call 0x184F]
	jbsr	HANDLE_COIN_INSERT_SOUND     | [call 0x1876]
	jbsr	HANDLE_PLAYER_SHOOTING_SOUND     | [call 0x1723]
	move.b	SOUND_VOL,d0                       	| load A with value of SOUND_VOL [ld   a,(0x41C0)]
	*move.b	d0,l_6806                       	| Write to !SOUND Vol of F1 [ld   (0x6806),a]
	ror.b	#1,d0                            	| [rrca]
	*move.b	d0,l_6807                       	| Write to !SOUND Vol of f2 [ld   (0x6807),a]
	move.b	PITCH_SOUND_FX_BASE_FREQ,d0                       	| read PITCH_SOUND_FX_BASE_FREQ value [ld   a,(0x41C1)]
	*move.b	d0,l_7800                       	| Write to !Pitch Sound FX base frequency [ld   (0x7800),a]
	rts                                    	| [ret]



HANDLE_PLAYER_SHOOTING_SOUND:
	move.b	PLAY_PLAYER_SHOOT_SOUND,d0                       	| read PLAY_PLAYER_SHOOT_SOUND flag [ld   a,(0x41CC)]
	subq.b	#1,d0                           	| decrement value [dec  a]
	jne	l_1733                             	| if the value is nonzero now then it wasn't set to 1 before, so don't play the sound. Goto 0x1733 [jp   nz,0x1733]
	clr.b	PLAY_PLAYER_SHOOT_SOUND                       	| a is zero, so this sets the shoot flag to false. [ld   (0x41CC),a]
	move.b	#0x08,d0                        	| this value here appears to affect the length of the shoot sound. Higher value = longer [ld   a,0x08]
	move.b	d0,PLAYER_SHOOT_SOUND_COUNTER                       	| set PLAYER_SHOOT_SOUND_COUNTER [ld   (0x41CE),a]
	rts                                    	| [ret]

l_1733:
	move.b	PLAYER_SHOOT_SOUND_COUNTER,d0                       	| read PLAYER_SHOOT_SOUND_COUNTER [ld   a,(0x41CE)]
	tst.b	d0                               	| test if zero [and  a]
	jeq	l_1743                             	| if it is zero, goto 0x1743, which will turn the player shoot sound off [jp   z,0x1743]
	subq.b	#1,d0                           	| reduce counter value by 1. [dec  a]
	move.b	d0,PLAYER_SHOOT_SOUND_COUNTER                       	| and write updated count back. [ld   (0x41CE),a]
	move.b	IS_GAME_OVER,d0                       	| read IS_GAME_OVER flag [ld   a,(0x4007)]
	eor.b	#0x01,d0                         	| [xor  0x01]
	beq.b	l_1743
	cmp.b	#7,PLAYER_SHOOT_SOUND_COUNTER		| added in port so we only play shoot sound once
	bne.b	l_1743
	move.w	#SHOOT_SND,d0
	jbsr	osd_sound_start
l_1743:
	*move.b	d0,l_6805                       	| !SOUND shoot on/off [ld   (0x6805),a]
	rts                                    	| [ret]


*
* Plays the GAME START tune.
*

HANDLE_GAME_START_MELODY:
	move.b	PLAY_GAME_START_MELODY,d0                       	| read PLAY_GAME_START_MELODY flag [ld   a,(0x41D1)]
	subq.b	#1,d0                           	| if was set to 1, this dec will set zero flag [dec  a]
	beq.b	0f
	rts                                    	| return if PLAY_GAME_START_MELODY wasn't set [ret  nz]
0:
	move.b	d0,PLAY_GAME_START_MELODY                       	| clear PLAY_GAME_START_MELODY flag [ld   (0x41D1),a]
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,PLAY_GAME_START_MELODY+1                       	| [ld   (0x41D2),a]
	move.b	d0,DELAY_BEFORE_NEXT_SOUND                       	| [ld   (0x41D6),a]
	
	move.w	#INTRO_SND,d0
	jsr		osd_sound_start
	
	* play game start tune
	*lea	l_1E68(pc),a0                      	| [ld   hl,0x1E68]
	*move.b	a0,COMPLEX_SOUND_POINTER                       	| set COMPLEX_SOUND_POINTER [ld   (0x41D3),hl]
	rts                                    	| [ret]




*
* TODO: Wondering if I should change this label to HANDLE_MONOPHONIC_SOUNDS... maybe best to KISS.
*
*

HANDLE_COMPLEX_SOUNDS:
	lea	PLAY_GAME_START_MELODY+1,a0                      	| [ld   hl,0x41D2]
	jbsr	l_176c                            	| [call 0x176C]
	lea	PLAYER_SHOOT_SOUND_COUNTER+1,a0                      	| [ld   hl,0x41CF]
	jbsr	l_176c                            	| [call 0x176C]
	lea	IS_COMPLEX_SOUND_PLAYING,a0                      	| pointer to address of IS_COMPLEX_SOUND_PLAYING [ld   hl,0x41CD]
l_176c:
	move.b	(a0),d0                         	| read flag [ld   a,(hl)]
	tst.b	d0                               	| is flag set? [and  a]
	bne.b	0f
	rts                                    	| No, a complex sound isn't playing, so return [ret  z]
0:
                            	| OK, now DE = 0x41CD
	move.b	#0x02,d0                        	| [ld   a,0x02]
	move.b	d0,SOUND_VOL                       	| Set value of SOUND_VOL [ld   (0x41C0),a]
	move.b	COMPLEX_SOUND_POINTER,d0                       	| [ld   a,(0x41D5)]
	move.b	d0,PITCH_SOUND_FX_BASE_FREQ                       	| Set PITCH_SOUND_FX_BASE_FREQ [ld   (0x41C1),a]

* wait until counter has hit 0 before getting next musical note or sound effect to play.
	move.b	DELAY_BEFORE_NEXT_SOUND,d0                       	| read DELAY_BEFORE_NEXT_SOUND [ld   a,(0x41D6)]
	subq.b	#1,d0                           	| decrement countdown [dec  a]
	jne	l_17a2                             	| if count hasn't hit zero, then goto 0x17A2 [jp   nz,0x17A2]
	*TODO
	nop
* OK, counter is zero, we get musical note or sound effect to play.
*	move.w	COMPLEX_SOUND_POINTER,a0                   	| read COMPLEX_SOUND_POINTER [ld   hl,(0x41D3)]
*	move.b	(a0),d0                         	| read sound to play [ld   a,(hl)]
*	cmp.b	#0xE0,d0                         	| is this the end of sound marker? [cp   0xE0]
*	jeq	l_17a6                             	| if so, then we've finished playing our sounds, goto 0x17A6 [jr   z,0x17A6]
*	addq.w	#1,a0                           	| bump HL to point to next sound [inc  hl]
*	move.b	a0,l_41D3                       	| update COMPLEX_SOUND_POINTER [ld   (0x41D3),hl]
*	move.b	d0,d1                           	| [ld   b,a]
*	and.b	#0x1F,d0                         	| [and  0x1F]
*	lea	l_17A9(pc),a0                      	| [ld   hl,0x17A9]
*rst  0x20                               	| call routine to fetch value @ HL + A
*	move.b	d0,COMPLEX_SOUND_POINTER+2                       	| [ld   (0x41D5),a]
*	move.b	d1,d0                           	| [ld   a,b]
*	and.b	#0xE0,d0                         	| [and  0xE0]
*	rol.b	#3,d0                            	| [rlca]
*	lea	l_17C8(pc),a0                      	| [ld   hl,0x17C8]
*rst  0x20                               	| call routine to fetch value @ HL + A
l_17a2:
	move.b	d0,DELAY_BEFORE_NEXT_SOUND                       	| set DELAY_BEFORE_NEXT_SOUND [ld   (0x41D6),a]
	rts                                    	| [ret]

*,0xDE = 0x41CD
l_17a6:
	clr.b	d0                               	| [xor  a]
	move.b	d0,(a1)                         	| Indicate free to play more sounds [ld   (de),a]
	rts                                    	| [ret]

l_17C8:
	.byte	0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x00


*
* This routine is responsible for making the "Wheeew" noise as the alien attackers fly down the screen.
* No, I'm not going to call this routine "HANDLE_WHEEW_SOUND" although I was tempted	|)
*

HANDLE_ALIEN_ATTACK_SOUND:
	move.b	IS_GAME_IN_PLAY,d0                       	| read IS_GAME_IN_PLAY [ld   a,(0x4006)]
	ror.b	#1,d0                            	| move bit 0 into carry. If game is in play, carry is set [rrca]
	bcs.b	0f
	rts                                    	| if carry is not set, game's not in play, return [ret  nc]
0:
	lea	ENABLE_ALIEN_ATTACK_SOUND,a0                      	| [ld   hl,0x41C2]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	subq.b	#1,d0                           	| [dec  a]
	jne	l_17e5                             	| [jp   nz,0x17E5]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	*lea	l_A002(pc),a0                      	| [ld   hl,0xA002]
	*move.b	a0,l_41C3                       	| [ld   (0x41C3),hl]
	move.b	#0x02,UNKNOWN_SOUND_41C3
	move.b	#0xA0,UNKNOWN_SOUND_41C3
	
	rts                                    	| [ret]

l_17e5:
	move.b	HAVE_NO_INFLIGHT_ALIENS,d0                       	| read HAVE_NO_INFLIGHT_ALIENS [ld   a,(0x4226)]
	ror.b	#1,d0                            	| move flag into carry [rrca]
	bcc.b	0f
	rts                                    	| return if there are no aliens in flight [ret  c]
0:
	lea		UNKNOWN_SOUND_41C3,a0                           	| bump HL to point to UNKNOWN_SOUND_41C3 [inc  hl]
	move.b	TIMING_VARIABLE,d0                       	| read TIMING_VARIABLE [ld   a,(0x425F)]
	ror.b	#1,d0                            	| move bit 0 into carry [rrca]
	jcs	l_1801                             	| [jr   c,0x1801]
	move.b	UNKNOWN_SOUND_41C4,d0                       	| [ld   a,(0x41C4)]
	cmp.b	#0x60,d0                         	| [cp   0x60]
	jcc	l_17f9                             	| [jr   nc,0x17F9]
	addq.b	#1,(a0)                         	| [inc  (hl)]
l_17f9:
	tst.b	d0                               	| [and  a]
	jeq	l_1801                             	| [jp   z,0x1801]
	subq.b	#1,d0                           	| [dec  a]
	move.b	d0,UNKNOWN_SOUND_41C4                       	| [ld   (0x41C4),a]
l_1801:
	move.b	(a0),d0                         	| [ld   a,(hl)]
	and.b	#0x03,d0                         	| [and  0x03]
	jne	l_180c                             	| [jp   nz,0x180C]
	move.b	#0x60,d0                        	| [ld   a,0x60]
	jra	l_1815                             	| [jp   0x1815]
l_180c:
	ror.b	#1,d0                            	| [rrca]
	move.b	UNKNOWN_SOUND_41C4,d0                       	| [ld   a,(0x41C4)]
	jcc	l_1815                             	| [jr   nc,0x1815]
	add.b	#0x60,d0                         	| [add  a,0x60]
	roxr.b	#1,d0                           	| [rra]
l_1815:
	move.b	d0,PITCH_SOUND_FX_BASE_FREQ                       	| Set PITCH_SOUND_FX_BASE_FREQ [ld   (0x41C1),a]
	rts                                    	| [ret]


*
* Plays the sound of an alien or a flagship when hit.
*
* No death sound will be played if either of the IS_GAME_IN_PLAY or IS_COMPLEX_SOUND_PLAYING flags are set.
*

HANDLE_ALIEN_DEATH_SOUND:
	move.b	IS_GAME_IN_PLAY,d0                       	| read IS_GAME_IN_PLAY [ld   a,(0x4006)]
	ror.b	#1,d0                            	| move flag into carry [rrca]
	bcs.b	0f
	rts                                    	| if game is not in play, we won't play sound. [ret  nc]
0:

	move.b	ALIEN_DEATH_SOUND,d0                       	| [ld   a,(0x41DF)]
	cmp.b	#0x06,d0                         	| Do we want to play the ALIEN DEATH sound? [cp   0x06]
	jne	l_183a                             	| no, goto 0x183A [jp   nz,0x183A]

	tst.b	IS_COMPLEX_SOUND_PLAYING                       	| read IS_COMPLEX_SOUND_PLAYING flag [ld   a,(0x41CD)]
	beq.b	0f
	rts                                    	| [ret  c]
0:

	move.b	#0x01,d0                        	| [ld   a,0x01]
	move.b	d0,PLAYER_SHOOT_SOUND_COUNTER+1                       	| [ld   (0x41CF),a]
	move.b	d0,DELAY_BEFORE_NEXT_SOUND                       	| [ld   (0x41D6),a]
	move.w	#ALIEN_SHOT_SND,d0
	jbsr	osd_sound_start
	
	* play alien death sound
	*lea	l_1EBD(pc),a0                      	| [ld   hl,0x1EBD]
	*move.b	a0,COMPLEX_SOUND_POINTER                       	| [ld   (0x41D3),hl]
	rts                                    	| [ret]

l_183a:
	cmp.b	#0x16,d0                         	| Do we want to play the FLAGSHIP DEATH sound? [cp   0x16]
	beq.b	0f
	rts                                    	| if not, return [ret  nz]
0:
	clr.b	d0                               	| [xor  a]
	move.b	d0,PLAYER_SHOOT_SOUND_COUNTER+1                       	| [ld   (0x41CF),a]
	addq.b	#1,d0                           	| [inc  a]
	move.b	d0,IS_COMPLEX_SOUND_PLAYING                       	| [ld   (0x41CD),a]
	move.b	d0,DELAY_BEFORE_NEXT_SOUND                       	| [ld   (0x41D6),a]
	* play flagship death soundeffect
	move.w	#FLAGSHIP_SHOT_SND,d0
	jbsr	osd_sound_start
	*lea	l_1EDF(pc),a0                      	| [ld   hl,0x1EDF]
	*move.b	a0,COMPLEX_SOUND_POINTER                       	| [ld   (0x41D3),hl]
	rts                                    	| [ret]

*
*
*
*
*

HANDLE_EXTRA_LIFE_SOUND:
	tst.b	PLAY_EXTRA_LIFE_SOUND                            	| read PLAY_EXTRA_LIFE_SOUND flag. [bit  0,l]
	jeq	l_185e                             	| if flag is not set, goto 0x185E. [jp   z,0x185E]
	             	| store 0 in PLAY_EXTRA_LIFE_SOUND and 0x80 in EXTRA_LIFE_SOUND_COUNTER [ld   hl,0x8000]
	clr.b	PLAY_EXTRA_LIFE_SOUND                       	| [ld   (0x41C7),hl]
	move.b	#0x80,EXTRA_LIFE_SOUND_COUNTER                       	| [ld   (0x41C7),hl]
	rts                                    	| [ret]

* play the extra life sound
l_185e:
	move.b	EXTRA_LIFE_SOUND_COUNTER,d0                           	| read EXTRA_LIFE_SOUND_COUNTER [ld   a,h]
	tst.b	d0                               	| test if value is 0. [and  a]
	bne.b	0f
	rts                                    	| return if value is indeed 0. [ret  z]
0:
	subq.b	#1,d0                           	| decrement counter [dec  a]
	move.b	d0,EXTRA_LIFE_SOUND_COUNTER                       	| update EXTRA_LIFE_SOUND_COUNTER [ld   (0x41C8),a]
	and.b	#0x04,d0                         	| [and  0x04]
	jeq	l_186c                             	| [jp   z,0x186C]
	move.b	#0x81,d0                        	| [ld   a,0x81]
l_186c:
	subq.b	#1,d0                           	| [dec  a]
	move.b	d0,PITCH_SOUND_FX_BASE_FREQ                       	| Set PITCH_SOUND_FX_BASE_FREQ [ld   (0x41C1),a]
	move.b	#0x01,d0                        	| [ld   a,0x01]
	move.b	d0,SOUND_VOL                       	| set SOUND_VOL [ld   (0x41C0),a]
	rts                                    	| [ret]




HANDLE_COIN_INSERT_SOUND:
	lea	PLAY_PLAYER_CREDIT_SOUND,a0                      	| address of PLAY_PLAYER_CREDIT_SOUND flag [ld   hl,0x41C9]
	move.b	(a0),d0                         	| read flag [ld   a,(hl)]
	subq.b	#1,d0                           	| [dec  a]
	jne	l_1886                             	| if PLAY_PLAYER_CREDIT_SOUND was not set to 1, goto 0x1886 [jp   nz,0x1886]
	move.b	d0,(a0)                         	| clear flag. [ld   (hl),a]
	
	move.w	#CREDIT_SND,d0
	jbsr	osd_sound_start
	
	move.b	#0x20,PLAYER_CREDIT_SOUND_COUNTER                      	| duration to play sound [ld   hl,0x0020]
	move.b	#0,PLAYER_CREDIT_SOUND_COUNTER+1                      	| [ld   (0x41CA),hl]
	rts                                    	| [ret]

* play the credit sound (disabled)
l_1886:
	rts
	
	lea		PLAYER_CREDIT_SOUND_COUNTER,a0                           	| bump HL to 0x41CA, which is address of PLAYER_CREDIT_SOUND_COUNTER [inc  hl]
	move.b	(a0),d0                         	| read value of count [ld   a,(hl)]
	tst.b	d0                               	| test if its zero [and  a]
	bne.b	0f
	rts                                    	| if its zero, return [ret  z]
0:
	subq.b	#1,(a0)                         	| reduce counter [dec  (hl)]
	addq.w	#1,a0                           	| bump HL to 0x41CB [inc  hl]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	addq.b	#0x04,d0                        	| [add  a,0x04]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	move.b	d0,PITCH_SOUND_FX_BASE_FREQ                       	| Set PITCH_SOUND_FX_BASE_FREQ [ld   (0x41C1),a]
	clr.b	d0                               	| [xor  a]
	move.b	d0,SOUND_VOL                       	| set SOUND_VOL [ld   (0x41C0),a]
	rts                                    	| [ret]

*
*
* This piece of code is used to make the sound of the swarm "angrier" as the level goes on.
* The longer the level takes to complete, the faster and angrier the swarm is.
*
*

HANDLE_SWARM_SOUND:
	move.b	RESET_SWARM_SOUND_TEMPO,d0                       	| read RESET_SWARM_SOUND_TEMPO flag [ld   a,(0x41D0)]
	tst.b	d0                               	| test if zero [and  a]
	jeq	l_18a6                             	| if zero, goto 0x18A6 [jr   z,0x18A6]
	clr.b	d0                               	| clear A [xor  a]
	move.b	d0,RESET_SWARM_SOUND_TEMPO                       	| reset RESET_SWARM_SOUND_TEMPO flag [ld   (0x41D0),a]
	move.b	#0x0F,d0                        	| Maximum (slowest) Tempo setting [ld   a,0x0F]
	jra	l_18b2                             	| [jr   0x18B2]

l_18a6:
	move.b	TIMING_VARIABLE,d0                       	| read TIMING_VARIABLE [ld   a,(0x425F)]
	addq.b	#0x01,d0                        	| add 1 to it [add  a,0x01]
	bcs.b	0f
	rts                                    	| return if no carry. This means the following code will only fire when A == #0xFF (255 decimal) [ret  nc]
0:
	move.b	LFO_FREQ_BITS,d0                       	| read LFO_FREQ_BITS [ld   a,(0x421F)]
	tst.b	d0                               	| test if zero [and  a]
	bne.b	0f
	rts                                    	| return if zero [ret  z]
0:
	subq.b	#1,d0                           	| otherwise reduce by 1 [dec  a]
l_18b2:
	move.b	d0,LFO_FREQ_BITS                       	| and update LFO_FREQ_BITS [ld   (0x421F),a]
*	move.b	#0x04,d1                        	| We're writing to 4 ports [ld   b,0x04]
*	lea	l_6004(pc),a0                      	| !DRIVER Background lfo freq bit0 [ld   hl,0x6004]
*l_18ba:
*	move.b	d0,(a0)                         	| write to port. Only bit 0 of register A matters [ld   (hl),a]
*	addq.w	#1,a0                           	| bump to next port [inc  hl]
*	ror.b	#1,d0                            	| shift all bits in A one place to right [rrca]
*	subq.b	#1,d1                           	| [...]
*	jne	l_18ba                             	| [djnz 0x18BA]
	rts                                    	| [ret]

	
* JOTD: added utility functions to emulate rst 10 & ldir

* < A0: source (HL)
* < A1: destination (DE)
* < D1: length (16 bit)
ldir:
	subq.w	#1,d1
0:
	move.b	(a0)+,(a1)+
	dbf		d1,0b
	clr.w	d1
	rts


* < D0: char to write
* < D1: number of chars to write
* < A0: address
rst_10:
	move.w	d1,-(a7)
	and.w	#0xFF,d1
	subq.w	#1,d1
0:
	move.b	d0,(a0)+
	dbf		d1,0b
	move.w	(a7)+,d1
	rts

* "write" to video ram (calls osd_w_bg_videoram)
* < D0: char to write
* < D1: number of chars to write
* < D6: address
rst_10_video:
	move.w	d1,-(a7)
	and.w	#0xFF,d1
	subq.w	#1,d1
0:
	jbsr	osd_w_bg_videoram
	addq.w	#1,d6
	dbf		d1,0b
	move.w	(a7)+,d1
	rts


* start of code

*
* A very primitive pseudo-random number generator.
* (seems that it just multiplies by 5, adds 1 and wraps)
*

GENERATE_RANDOM_NUMBER:
	move.b	RAND_NUMBER,d0
	move.b	d0,d1
	add.b	d0,d0
	add.b	d0,d0
	add.b	d0,d1
	addq.b	#1,d0
	move.b	d0,RAND_NUMBER
	rts

*
* Used by the aliens to determine what way to face when flying down, and what delta enemy bullets take
*
* (I have no idea how it works, just transcoded it as is)
*
* Expects:
* A (d0) = distance
* D (d3) = X coordinate
*

CALCULATE_TANGENT:
	move.w	d4,-(a7)
	moveq	#0,d2
	moveq	#8-1,d1	| do it 8 ties
0:
	cmp.b	d3,d0
	bcs.b	1f
	sub.b	d3,d0
1:
	* inverts carry (JOTD: clumsy & slow, but works)
	* z80 ccf instruction
	clr.b	d4
	roxl.b	#1,d4	| get carry in bit 0
	bchg	#0,d4	| change bit
	roxr.b	#1,d4	| set inverted carry back
	roxl.b	#1,d2
	roxr.b	#1,d3
	dbf		d1,0b
	move.w	(a7)+,d4
	rts

galaxian_irq:
	lea	OBJRAM_BACK_BUF,a0		| pointer to OBJRAM_BACK_BUF buffer held in RAM [ld   hl,0x4020]
	* update screen in one go - IMPORTANT
	jbsr	osd_update_graphics
          
*007C: 11 00 58      ld   de,0x5800            | start of screen attribute RAM
*007F: 01 80 00      ld   bc,0x0080            | number of bytes to copy from OBJRAM_BACK_BUF 
*0082: ED B0         ldir                     | update screen & sprites in one go
* read ports and stash values read in RAM
	move.b	PREV_PREV_PORT_STATE_6000,PREV_PREV_PREV_PORT_STATE_6000                       	| read previous, previous state of port 6000 (SW0) [ld   a,(0x4015)]
																							| and write to PREV_PREV_PREV_PORT_STATE_6000 [ld   (0x4016),a]
	move.b	PREV_PORT_STATE_6000,PREV_PREV_PORT_STATE_6000                       	| read previous state of port 6000 (SW0) [ld   a,(0x4013)]
																					| and write to PREV_PREV_PORT_STATE_6000 [ld   (0x4015),a]
	move.b	PORT_STATE_6800,PREV_PORT_STATE_6800                   	| read state of 6800 (SW0) and 6800 (SW1 & SOUND) [ld   hl,(0x4010)]
	move.b	PORT_STATE_6000,PREV_PORT_STATE_6000                   	| read state of 6000 (SW0) and 6800 (SW1 & SOUND) [ld   hl,(0x4010)]
																| and write to previous state value [ld   (0x4013),hl]
	jbsr		osd_read_dipswitches                       	| read state of DIPSW [ld   a,(0x7000)]
	move.b	d2,PORT_STATE_7000                       	| and write to PORT_STATE_7000 holder [ld   (0x4012),a]
														| read start button, p2 control, dipsw 1/2 state [ld   a,(0x6800)]
	move.b	d1,PORT_STATE_6800                       	| and write to PORT_STATE_6800 holder [ld   (0x4011),a]
														| read coin, p1 control, test & service state [ld   a,(0x6000)]
	move.b	d0,PORT_STATE_6000                       	| and write to PORT_STATE_6000 holder [ld   (0x4010),a]

		subq.b	#1,TIMING_VARIABLE             | decrement value

		jbsr CHECK_IF_COIN_INSERTED
		jbsr HANDLE_UNPROCESSED_COINS
		jbsr HANDLE_SOUND
		jbsr HANDLE_SWARM_SOUND
		jbsr HANDLE_TEXT_SCROLL

* invoke script [SCRIPT_NUMBER]
	moveq	#0,d0
	move.b	SCRIPT_NUMBER,d0
	add.w	d0,d0
	add.w	d0,d0
	lea		SCRIPT_TABLE(pc),a0
	move.l	(a0,d0.w),a0
	jmp		(a0)
	

SCRIPT_TABLE:
     .long	SCRIPT_ZERO   
     .long	SCRIPT_ONE
     .long	SCRIPT_TWO
     .long	SCRIPT_THREE
     .long	SCRIPT_FOUR
	

SCRIPT_ZERO:
	move.w	TEMP_CHAR_RAM_PTR,d6	| Read TEMP_CHAR_RAM_PTR. This holds character RAM to start clearing from
	move.w	#0x20-1,d1                  | #0x20 (32 decimal) bytes to fill in a row
	move.w	#0x10,d0				| ordinal of empty character
0:
	jbsr		osd_w_bg_videoram
	addq.w	#1,d6
	dbf		d1,0b
		
	move.w	d6,TEMP_CHAR_RAM_PTR       | save in TEMP_CHAR_RAM_PTR
	subq.b	#1,TEMP_COUNTER_1        | decrement value
	beq.b	1f
	rts                          | if counter hasn't hit zero, return
1:
	move.b	#1,IS_GAME_OVER		| point HL to IS_GAME_OVER (set to 1)
	clr.b   IS_GAME_IN_PLAY     | point HL to IS_GAME_IN_PLAY
	move.b	#1,SCRIPT_NUMBER    | point HL to SCRIPT_NUMBER
	clr.b	SCRIPT_STAGE   | reset SCRIPT_STAGE to 0

	move.b	PORT_STATE_6800,d0                       	| read PORT_STATE_6800 [ld   a,(0x4011)]
	rol.b	#2,d0                           	| move dip sw1 & dip sw2 state... [rlca]
												| ...into bits 0 & 1 of register a [rlca]
	and.b	#0x03,d0                         	| [and  0x03]
	move.b	d0,DIP_SWITCH_1_2_STATE            	| and store into DIP_SWITCH_1_2_STATE [ld   (0x4000),a]

	move.b	PORT_STATE_7000,d0                       	| read PORT_STATE_7000 [ld   a,(0x4012)]
	and.b	#0x04,d0                         	| mask in state of dip switch 5 [and  0x04]
	ror.b	#2,d0                           	| move bit into... [rrca]
												| bit 0 of register a [rrca]
	move.b	d0,DIP_SWITCH_5_STATE                       	| and store it in DIP_SWITCH_5_STATE [ld   (0x401F),a]

	lea	PACKED_DEFAULT_SWARM_DEFINITION(pc),a1	| load,0xDE with address of PACKED_DEFAULT_SWARM_DEFINITION
	jbsr UNPACK_ALIEN_SWARM               	| call UNPACK_ALIEN_SWARM

* read DIP switches to calculate value of BONUS GALIXIP
	jbsr		osd_read_dipswitches  	| read state of dip switch 3,4,5,6 [ld   a,(0x7000)]
	and.w	#0x03,d2                         	| mask in state of dip switches 3 & 4 [and  0x03]
	lea	table_0152(pc),a0                      	| [ld   hl,0x0152   see below table]
	move.b	(a0,d2.w),BONUS_GALIXIP_FOR                	| write BONUS GALIXIP @ value
 

* Set screen attribute colours then display "1UP" and "HIGH SCORE" 
		jbsr	SET_COLOUR_ATTRIBUTES_TABLE_1 | call SET_COLOUR_ATTRIBUTES_TABLE_1
		move.b	#1,d0
		move.w	#0x5340,d6
		jbsr	osd_w_bg_videoram		| poke "1" to character RAM
		move.b	#0x25,d0
		move.w	#0x5320,d6		          
		jbsr	osd_w_bg_videoram		| poke "U" to character RAM
		move.b	#0x20,d0
		move.w	#0x5300,d6		          
		jbsr	osd_w_bg_videoram		| poke "P" to character RAM - text "1UP" now drawn
		move.w	#0x0604,d3		      | command: PRINT_TEXT_COMMAND, parameter: 4 (index of "HIGH SCORE")
		jbsr	QUEUE_COMMAND
		move.w	#0x0503,d3              | command: DISPLAY_SCORE_COMMAND , parameter: 3 (Displays player scores and high score)
		jra		QUEUE_COMMAND
  
* Values for BONUS GALIXIP. 7 = 7000, 10 = 10000, 12 =12000, 20 = 20000
table_0152: 
	.byte	0x07,0x10,0x12,0x20 

*
* Script ONE is responsible for managing the attract mode.
*
*
*

SCRIPT_ONE:
	bsr	HANDLE_SWARM_MOVEMENT	| even on "game over"!   
	bsr	SET_ALIEN_PRESENCE_FLAGS
	moveq	#0,d0
	lea		script_one_jump_table(pc),a0
	move.b	SCRIPT_STAGE,d0		| read SCRIPT_STAGE   
	add.w	d0,d0
	add.w	d0,d0
	move.l	(a0,d0.w),a0
	jsr		(a0)

	tst.b	NUM_CREDITS   | 03D7
	bne.b	1f			| return if no credits
	rts
1:
	addq.b	#1,SCRIPT_NUMBER        | advance to next script
	clr.b	IS_GAME_OVER 			| set IS_GAME_OVER to 0
	clr.b	SCRIPT_STAGE               | set SCRIPT_STAGE to 0
	clr.b	ENABLE_ALIEN_ATTACK_SOUND  | set ENABLE_ALIEN_ATTACK_SOUND to 0
	clr.b	ALIEN_DEATH_SOUND          | set ALIEN_DEATH_SOUND to 0
	clr.b	IS_COLUMN_SCROLLING        | clear IS_COLUMN_SCROLLING flag
	rts

script_one_jump_table: 
	.long	DISPLAY_GAME_OVER_AND_REMAINING_CREDIT_1
	.long	SET_PUSH_START_BUTTON_COUNTER
	.long	HIDE_SWARM_AND_PREPARE_TO_CLEAR_SCREEN 
	.long	CLEAR_SCREEN_BEFORE_WE_ARE_THE_GALAXIANS_INTRO
	.long	DISPLAY_WE_ARE_THE_GALAXIANS_INTRO
	.long	SCROLL_ON_CONVOY_CHARGER_POINTS
	.long	DISPLAY_NAMCO_LOGO
	.long	BLINK_CONVOY_CHARGER_POINTS
	.long	HIDE_SWARM_AND_PREPARE_TO_CLEAR_SCREEN 
	.long	CLEAR_WE_ARE_GALAXIANS_SCREEN_AND_DISPLAY_GAME_OVER
	.long	DISPLAY_GAME_OVER_AND_REMAINING_CREDIT_2
	.long	WAIT_FOR_TEMP_COUNTER_2_THEN_ADVANCE_TO_NEXT_STAGE 
	.long	CLEAR_ALIEN_SWARM_AND_SUSPEND_SWARM_ANIMATION
	.long	CREATE_ATTRACT_MODE_ALIEN_SWARM
	.long	HANDLE_SPAWN_PLAYER
	.long	HANDLE_MAIN_GAME_LOGIC
	.long	HANDLE_PLAYER_ONE_KILLED
	.long	WAIT_FOR_TEMP_COUNTER_2_THEN_ADVANCE_TO_NEXT_STAGE
	.long	SET_SCRIPT_STAGE_TO_1



*
* Enables starfield, displays GAME OVER and the amount of credit remaining.
*
*
DISPLAY_GAME_OVER_AND_REMAINING_CREDIT_1:      
	move.w	#0x0701,d3            | command: DISPLAY_BOTTOM_OF_SCREEN_COMMAND, parameter: 1 (invokes DISPLAY_AVAILABLE_CREDIT)
	jbsr	QUEUE_COMMAND		| call QUEUE_COMMAND
	move.w	#0x0600,d3          | command: PRINT_TEXT_COMMAND, parameter: 0 (index of GAME OVER)
	jbsr	QUEUE_COMMAND               | call QUEUE_COMMAND
	moveq  #1,d0
	move.b	d0,IS_GAME_OVER           | set IS_GAME_OVER flag
	jbsr		osd_stars_on         | enable stars
	addq.b	#1,SCRIPT_STAGE   | advance to next stage
	clr.b	PUSH_START_BUTTON_COUNTER
	clr.b	CURRENT_PLAYER           | set CURRENT_PLAYER to 0 (player one)
	clr.b	IS_TWO_PLAYER_GAME
	clr.b	IS_GAME_IN_PLAY
	move.b	#0x60,TEMP_COUNTER_1
	.ifdef	FAST_INTRO_TEXT
    move.b	#1,TEMP_COUNTER_2
	.else
	move.b	#0x10,TEMP_COUNTER_2     | set TEMP_COUNTER_1 and TEMP_COUNTER_2 
	.endif
	rts

	
HIDE_SWARM_AND_PREPARE_TO_CLEAR_SCREEN:
    lea		ALIEN_SWARM_FLAGS,a0            | load HL with address of 
    move.w	#0x80-1,d1               | sizeof(ALIEN_SWARM_FLAGS) array
0:
	clr.b	(a0)+             | Clear all alien swarm flags 
	dbf		d1,0b
	
    clr.b	TIMING_VARIABLE          
    clr.b   HAVE_AGGRESSIVE_ALIENS 		| reset HAVE_AGGRESSIVE_ALIENS flag
	move.w	#0x5002,TEMP_CHAR_RAM_PTR       | address of column 2 in character RAM
    move.b	#0x20,TEMP_COUNTER_2			| tells to clear 32 rows in next script stage!
    addq.b	#1,SCRIPT_STAGE                | advance to next part of script.
	rts
	
*
* This piece of code clears all of the screen except the HUD (score, credits inserted etc)
*

CLEAR_SCREEN_BEFORE_WE_ARE_THE_GALAXIANS_INTRO:
	move.w	TEMP_CHAR_RAM_PTR,d6  | load HL with contents of TEMP_CHAR_RAM_PTR
     move.w	#0x1C,d1               | We want to clear #0x1C (28 characters) on this row 
     move.b	#0x10,d0               | ordinal for empty character
	 bsr	rst_10_video       | Clear 28 characters from row
                              | As a row is 32 characters wide, to get to start of next row...
     addq.w	#4,d6              | ... we need to add 4 characters.
     move.w	d6,TEMP_CHAR_RAM_PTR         | write to TEMP_CHAR_RAM_PTR
	 subq.b	#1,TEMP_COUNTER_2     | decrement value of counter
     beq.b	1f                  | if value is not zero then exit 
	rts
1:
	addq.b	#1,SCRIPT_STAGE		| advance to next part of script.
	move.b	#0x40,TEMP_COUNTER_1
	move.b	#0x04,TEMP_COUNTER_2	| set TEMP_COUNTER_1 and TEMP_COUNTER_2

	lea		HAS_PLAYER_SPAWNED,a0
	move.l	#FLAGSHIP_ATTACK_SECONDARY_COUNTER,d1
	sub.l	a0,d1
	subq.w	#1,d1
0:
	clr.b	(a0)+
	dbf		d1,0b    | Clear from 0x4200-422F
	  
      | reset regen hflip (not done)
      | reset regen vflip (not done)
      | reset DISPLAY_IS_COCKTAIL_P2  (not done)
      move.b	#1,DISABLE_SWARM_ANIMATION           | set  flag
      lea	COLOUR_ATTRIBUTE_TABLE_3(pc),a0
      bra	SET_COLOUR_ATTRIBUTES               | jump to SET_COLOUR_ATTRIBUTES

*
* The alien swarm scrolling in the attract mode has changed scroll values for some columns, 
* and these scroll values need to be reset before we can print text like "WE ARE THE GALAXIANS" "MISSION: DESTROY ALIENS"
* in those columns. If we don't reset the scroll values, the text will probably be off-centre and not look good.
*

HANDLE_ALIEN_SWARM_SCROLL_RESET:
    moveq	#0,d0                   | reset scroll offset to 0
    jra     SET_SWARM_SCROLL_OFFSET



* This routine does two things:
*
* 1. Stops the swarm from moving if the player bullet gets too close to an alien in the swarm
* 2. Sets the scroll registers for the columns containing the swarm
*
* Before I investigated this code, I never noticed the swarm stops - now I can't not notice it.
* If you want the aliens to just not care about their own safety, type the following into the debugger: maincpu.mw@0x093C=0
*

HANDLE_SWARM_MOVEMENT:
	tst.b	HAS_PLAYER_BULLET_BEEN_FIRED                         	| test bit 0. [bit  0,(hl)]
	jeq	l_093e                             	| If player hasn't fired, goto 0x093E [jr   z,0x093E]
	move.b	PLAYER_BULLET_X,d0                         	| read X coordinate of bullet [ld   a,(hl)]
	sub.b	#0x22,d0                         	| [sub  0x22]
	cmp.b	#0x50,d0                         	| compare to 0x50 (80 decimal) [cp   0x50]
	jcc	l_093e                             	| if greater than 0x50, goto 0x093E [jr   nc,0x093E]

	move.b	SWARM_SCROLL_VALUE+1,d0                       	| read SWARM_SCROLL_VALUE lsb [ld   a,(0x420E)]
	sub.b	PLAYER_BULLET_Y,d0                          	| subtract from value in PLAYER_BULLET_Y [sub  (hl)]
	neg.b	d0                               	| A = 256-A [neg]
	move.b	d0,d1                           	| [ld   b,a]
	addq.b	#0x02,d0                        	| [add  a,0x02]
	and.b	#0x0F,d0                         	| [and  0x0F]
	cmp.b	#0x03,d0                         	| [cp   0x03]
	jcc	l_093e                             	| if A >= #0x03 goto 0x093E [jr   nc,0x093E]

	move.b	d1,d0                           	| [ld   a,b]
	lsr.b	#4,d0                           	| [rrca]*4 divide by 16
	and.w	#0x0F,d0                         	| now A identifies the column of the swarm the player bullet is in [and  0x0F]
	*(note the and.w so we can use it as offset)
	lea	ALIEN_IN_COLUMN_FLAGS,a0
	tst.b	(a0,d0.w)                         	| are there any aliens in this column? [bit  0,(hl)]
	jne	l_0988                             	| yes, make the swarm stand still! [jr   nz,0x0988]

* move the swarm, and make it change direction once its hit a screen edge
l_093e:
	move.w	SWARM_SCROLL_VALUE,d5                      	| read SWARM_SCROLL_VALUE [ld   hl,(0x420E)]
	move.b	SWARM_SCROLL_MAX_EXTENTS,d3              	| read SWARM_SCROLL_MAX_EXTENTS msb [ld   de,(0x4210)]
	move.b	SWARM_SCROLL_MAX_EXTENTS+1,d4             	| read SWARM_SCROLL_MAX_EXTENTS lsb [ld   de,(0x4210)]
	move.b	SWARM_DIRECTION,d0                       	| read SWARM_DIRECTION [ld   a,(0x420D)]
	jne	l_095d                             	| if not zero, swarm is moving right, goto 0x095D [jr   nz,0x095D]

* swarm is moving left
	btst	#15,d5                            	| [bit  7,h]
	jne	l_0953                             	| [jr   nz,0x0953]
	move.b	d5,d0                           	| [ld   a,l]
	cmp.b	d4,d0							| [cp   e]
	jcc	MAKE_SWARM_MOVE_RIGHT                             	| jp to MAKE_SWARM_MOVE_RIGHT [jr   nc,0x097D]
l_0953:
	move.b	TIMING_VARIABLE,d0                       	| read TIMING_VARIABLE [ld   a,(0x425F)]
	and.b	#0x03,d0                         	| mask in bits 0 & 1 [and  0x03]
	beq.b	0f
	rts                                    	| if either bit is set, return [ret  nz]
0:
	addq.w	#1,d5                           | increment scroll value. Swarm will move left (but in reality, a pixel down). [inc  hl]
	jra	l_096c                             	| [jp   0x096C]

* swarm is moving right
l_095d:
	btst	#15,d5                          	| test bit 7 [bit  7,h]
	jeq	l_0965                             	| [jr   z,0x0965]
	move.b	d5,d0                           	| [ld   a,l]
	cmp.b	d3,d0							| [cp   d]
	jcs	MAKE_SWARM_MOVE_LEFT                             	| jp to MAKE_SWARM_MOVE_LEFT [jr   c,0x0983]
l_0965:
	move.b	TIMING_VARIABLE,d0                       	| read TIMING_VARIABLE [ld   a,(0x425F)]
	and.b	#0x03,d0                         	| mask in bits 0 & 1 [and  0x03]
	beq.b	0f
	rts                                    	| if either bit is set, return. [ret  nz]
0:
	subq.w	#1,d5                           	| decrement scroll value. Swarm will move right (in reality, a pixel up). [dec  hl]

* if you want the swarm to be static, or tinker with the scroll, fill 0x096C to 0x096E with NOP instructions.
l_096c:
	move.w	d5,SWARM_SCROLL_VALUE                       	| set SWARM_SCROLL_VALUE [ld   (0x420E),hl]
l_096f:
	move.b	d5,d0                           	| [ld   a,l]
	neg.b	d0                               	| A = 256-A [neg]
	* continues to SET_SWARM_SCROLL_OFFSET
*
* This is used to scroll the alien swarm from side to side.
*
* Expects:
* register A: Scroll offset value
*

SET_SWARM_SCROLL_OFFSET:
    lea	OBJRAM_BACK_BUF+8,a0     | pointer to attribute and column scroll data held in OBJRAM_BACK_BUF
    move.w	#8,d1                | we're doing 9 columns.
0:
	move.b	d0,(a0)
    addq.w	#2,a0        | bump HL to next scroll offset address in OBJRAM_BACK_BUF
    dbf		d1,0b
    rts


MAKE_SWARM_MOVE_RIGHT:
	move.b	#1,SWARM_DIRECTION   | Swarm now moves right.
	rts

MAKE_SWARM_MOVE_LEFT:
	clr.b	SWARM_DIRECTION   | Swarm now moves left
	rts

l_0988:
	move.w	SWARM_SCROLL_VALUE,d5         | read SWARM_SCROLL_VALUE
	jra		l_096f



*
* This routine is responsible for scrolling on the SCORE ADVANCE TABLE items.
* It is not responsible for scrolling the actual alien swarm.
*

HANDLE_TEXT_SCROLL:
	tst.b	IS_COLUMN_SCROLLING                       	| read IS_COLUMN_SCROLLING flag [ld   a,(0x40B0)]
	bne.b	0f
	rts                                    	| return if flag was not set [ret  nc]
0:
	move.l	COLUMN_SCROLL_ATTR_BACKBUF_PTR,a0   | Load HL with pointer to scroll attribute data in OBJRAM_BACK_BUF. [ld   hl,(0x40B1)]
	move.b	(a0),d0                         	| read scroll value [ld   a,(hl)]

* We only want to scroll on a new character every 8th pixel. The code below effectively checks if (scroll offset MODULO 8 == 0)
	and.b	#0x07,d0                         	| mask in bits 0..2. We now have a value from 0..7 in A. [and  0x07]
	jne	l_18e8                             	| if A is not zero, we don't scroll on a new character yet, goto 0x18E8. [jr   nz,0x18E8]

	exg		a0,a1			| swap HL and DE. This preserves value of HL elsewhere without requiring a PUSH or a store
	move.l	COLUMN_SCROLL_NEXT_CHAR_PTR,a0                   	| HL now is pointer to a character to be scrolled onto screen [ld   hl,(0x40B3)]
	move.b	(a0),d0                         	| read character to scroll on [ld   a,(hl)]
	cmp.b	#0x3F,d0                         	| is this a terminating byte marking the end of the characters to scroll on? [cp   0x3F]
	jeq	l_18e7                             	| if so, goto 0x18E7 [jr   z,0x18E7]

	addq.w	#1,a0                           	| bump pointer to next character [inc  hl]
	move.l	a0,COLUMN_SCROLL_NEXT_CHAR_PTR                       	| and update COLUMN_SCROLL_NEXT_CHAR_PTR pointer [ld   (0x40B3),hl]
	sub.b	#0x30,d0                         	| [sub  0x30]
	move.w	COLUMN_SCROLL_CHAR_RAM_PTR,d6                   	| get character RAM address to plot character at [ld   hl,(0x40B5)]
	jbsr	osd_w_bg_videoram                         	| store character into character RAM [ld   (hl),a]

	sub.w	#32,d6                              	| Add offset to HL. HL now points to character in row above, same column.
	move.w	d6,COLUMN_SCROLL_CHAR_RAM_PTR             	| And update pointer [ld   (0x40B5),hl]

l_18e7:
	exg		a0,a1                              	| now HL points to scroll attribute data in OBJRAM_BACK_BUF
l_18e8:
	subq.b	#1,(a0)                         	| update scroll offset value [dec  (hl)]
	beq.b	0f
	rts                                    	| exit if scroll offset value is not zero [ret  nz]
0:
	moveq	#0,d0                            	| We've scrolled as much as we need to. Stop the scroll. [xor  a]
	move.b	d0,IS_COLUMN_SCROLLING                       	| clear IS_COLUMN_SCROLLING flag [ld   (0x40B0),a]
	rts                                    	| [ret]


CHECK_IF_COIN_INSERTED:
	move.b	DIP_SWITCH_1_2_STATE,d0                       	| read stored state of dip switch 1 & 2 [ld   a,(0x4000)]
	cmp.b	#0x03,d0                         	| are dip switches set to FREE PLAY? [cp   0x03]
	jeq	l_1917                             	| yes, free play enabled, so goto 0x1917: we don't need to check if coins are inserted [jr   z,0x1917]
	                     	| pointer to PORT_STATE_6000 value [ld   hl,0x4010]
	move.b	PORT_STATE_6000,d0                         	| read value [ld   a,(hl)]
											| [inc  l]
											| [inc  l]
											| bump HL to 0x4013, which is PREV_PORT_STATE_6000 value [inc  l]
	or.b	PREV_PORT_STATE_6000,d0                           	| combine bits set for current state of port 6000 with bits set from previous state [or   (hl)]
	                        	| [inc  l]
	                        	| bump HL to 0x4015, which is PREV_PREV_PORT_STATE_6000 value [inc  l]
	not.b	d0                               	| flip bits [cpl]
	and.b	PREV_PREV_PORT_STATE_6000,d0
	                            	| bump HL to 0x4016, which is PREV_PREV_PREV_PORT_STATE_6000 value. [inc  l]
	and.b	PREV_PREV_PREV_PORT_STATE_6000,d0
	btst.b	#7,d0                           	| read SERVICE state [bit  7,a]
	jne	l_191e                             	| if SERVICE is pressed, goto 0x191E [jr   nz,0x191E]
	and.b	#0x03,d0                         	| mask in COIN 1 & COIN 2 bits, discard rest [and  0x03]
	bne.b	0f
	rts                                    	| if neither bits are set, meaning no coins inserted, return [ret  z]
0:
	lea	UNPROCESSED_COINS,a0                      	| address of UNPROCESSED_COINS counter [ld   hl,0x4004]
	addq.b	#1,(a0)                         	| increment UNPROCESSED_COINS counter [inc  (hl)]
	btst.b	#0,d0                           	| test COIN 1 state [bit  0,a]
	bne.b	0f
	rts                                    	| return if no coin inserted [ret  z]
0:
	and.b	#0x02,d0                         	| test COIN 2 state [and  0x02]
	bne.b	0f
	rts                                    	| return if no coin inserted [ret  z]
0:
	addq.b	#1,(a0)                         	| increment UNPROCESSED_COINS counter [inc  (hl)]
	rts                                    	| [ret]

* Only comes here if we have FREE PLAY enabled in the dip switches
l_1917:
	move.b	#1,COIN_COUNT
	move.b	#9,NUM_CREDITS               	| set COIN_COUNT to 1 and NUM_CREDITS to 9. [ld   (0x4001),hl]
	rts                                    	| [ret]

*
* This is called when SERVICE is pressed.
*

l_191e:
	lea	NUM_CREDITS,a0                      	| address of NUM_CREDITS [ld   hl,0x4002]
	move.b	(a0),d0                         	| read number of credits [ld   a,(hl)]
	cmp.b	#0x63,d0                         	| compare to 99 (decimal) [cp   0x63]
	bcs.b	0f
	rts                                    	| if A < 99 decimal, return [ret  nc]
0:
	addq.b	#1,(a0)                         	| otherwise, increment number of credits [inc  (hl)]
	move.b	#0x01,d0                        	| [ld   a,0x01]
	move.b	d0,PLAY_PLAYER_CREDIT_SOUND                       	| Play sound of credit being added [ld   (0x41C9),a]
	move.w	#0x0701,d3                      	| command: DISPLAY_BOTTOM_OF_SCREEN_COMMAND, parameter: 1 (invokes DISPLAY_AVAILABLE_CREDIT) [ld   de,0x0701]
	jra	QUEUE_COMMAND                             	| jump to QUEUE_COMMAND [jp   0x08F2]



HANDLE_UNPROCESSED_COINS:
	lea	COIN_CONTROL,a0                      	| COIN_CONTROL [ld   hl,0x4003]
	move.b	(a0),d0                         	| Read value [ld   a,(hl)]
	tst.b	d0                               	| test if zero. Zero means we process unprocessed coins [and  a]
	jne	l_1974                             	| if non-zero goto 0x1974 - don't bother processing coins. [jr   nz,0x1974]
	or.b	UNPROCESSED_COINS,d0                           	| Do we have any coins left unprocessed? [or   (hl)]
	bne.b	0f
	rts                                    	| Return if no coins left to be processed. [ret  z]
0:
	subq.b	#1,UNPROCESSED_COINS                         	| Otherwise, decrement UNPROCESSED_COINS [dec  (hl)]
	move.b	#0x0F,COIN_CONTROL                      	| reset COIN_CONTROL [ld   (hl),0x0F]
	move.b	DIP_SWITCH_1_2_STATE,d0                       	| read stored state of dip switches 1 & 2 [ld   a,(0x4000)]
	cmp.b	#0x03,d0                         	| are both switches set, meaning FREE PLAY? [cp   0x03]
	bne.b	0f
	rts                                    	| yes, so return - we don't bother about coins or credits in this case. [ret  z]
0:
	subq.b	#1,d0                           	| have we set dip switches to TWO COINS = 1 PLAY? If so, A will be 0 [dec  a]
	jeq	l_1964                             	| yes, goto 0x1964 to handle TWO COINS 1 PLAY [jr   z,0x1964]

* Nice piece of code @0x194C to add two credits if required with only one CALL. Spot it?
	lea	NUM_CREDITS,a0                      	| point HL to NUM_CREDITS [ld   hl,0x4002]
	subq.b	#1,d0                           	| have we set dip switches to ONE COIN = 2 PLAYS? If so, A will be 0 [dec  a]
	bne	0f
	jbsr	l_194f                            	| call code immediately after to add 1 credit, then return from CALL to add another credit! [call z,0x194F]
0:
l_194f:
	move.b	(a0),d0                         	| read number of credits [ld   a,(hl)]
	cmp.b	#0x63,d0                         	| have we reached 99 credits (decimal)? [cp   0x63]
	bne.b	0f
	rts                                    	| yes, so exit, no more credits allowed [ret  z]
0:
	jcc	l_1961                             	| if we have more than 99 credits (decimal) then goto 0x1961 - clamp credits to 99. [jr   nc,0x1961]
	addq.b	#1,(a0)                         	| increment credit count [inc  (hl)]
	move.b	#0x01,d0                        	| [ld   a,0x01]
	move.b	d0,PLAY_PLAYER_CREDIT_SOUND                       	| Set PLAY_PLAYER_CREDIT_SOUND flag to 1. I think you can guess what this does|) [ld   (0x41C9),a]
	move.w	#0x0701,d3                      	| command: DISPLAY_BOTTOM_OF_SCREEN_COMMAND, parameter: 1 (invokes DISPLAY_AVAILABLE_CREDIT) [ld   de,0x0701]
	jra	QUEUE_COMMAND                             	| jump to QUEUE_COMMAND [jp   0x08F2]

l_1961:
	move.b	#0x63,(a0)                      	| set NUM_CREDITS to 99 decimal. [ld   (hl),0x63]
	rts                                    	| [ret]

* Called when dip switches are set to TWO COINS ONE PLAY
l_1964:
	lea	COIN_COUNT,a0                      	| load HL with address of COIN_COUNT [ld   hl,0x4001]
	btst.b	#0,(a0)                         	| Have we only inserted one coin? [bit  0,(hl)]
	jeq	l_1971                             	| if bit test fails, we've not inserted any coins yet, goto 0x1971 [jr   z,0x1971]
	clr.b	(a0)                             	| reset COIN_COUNT to say we've acknowledged coins and awarded extra credit [ld   (hl),0x00]
	lea	NUM_CREDITS,a0 						| bump HL to point to NUM_CREDITS     
	jra	l_194f                             	| call routine to add a credit [jp   0x194F]

* Called to reset COIN_COUNT to 1.
l_1971:
	move.b	#0x01,(a0)                      	| [ld   (hl),0x01]
	rts                                    	| [ret]


* HL = 0x4003 (COIN_CONTROL)
l_1974:
	ror.b	#3,d0                            	| [rrca]*3
	*move.b	d0,l_6003                       	| write to DRIVER|COIN CONTROL [ld   (0x6003),a]
	subq.b	#1,(a0)                         	| [dec  (hl)]
	rts                                    	| [ret]



*
* Displays the following:
*
* WE ARE THE GALAXIANS
* MISSION: DESTROY ALIENS
* - SCORE ADVANCE TABLE -
* CONVOY CHARGER

DISPLAY_WE_ARE_THE_GALAXIANS_INTRO:
     bsr	HANDLE_ALIEN_SWARM_SCROLL_RESET
     subq.b	#1,TEMP_COUNTER_1
     beq.b	0f
	 rts 
0:
     move.b	#0x50,TEMP_COUNTER_1            | reset counter
     move.w	#0x0600,d3               | Command: PRINT_TEXT

* HL now points to a number between 1 and 4. This identifies a text string we want to print: 
* 1: CONVOY CHARGER             
* 2: SCORE ADVANCE TABLE
* 3: MISSION: DESTROY ALIENS    
* 4: WE ARE THE GALAXIANS
	move.b	TEMP_COUNTER_2,d3
	add.b	#6,d3      | add 6 to it to give us an index for PRINT_TEXT
    jbsr	QUEUE_COMMAND
    subq.b	#1,TEMP_COUNTER_2              | bump TEMP_COUNTER_2 to index of next string to print
    beq.b	1f
	rts
1:
	addq.b	#1,SCRIPT_STAGE     | advance to next stage
	move.b	#0x20,TEMP_COUNTER_1
	move.b	#0x04,TEMP_COUNTER_2  | set TEMP_COUNTER_1 and TEMP_COUNTER_2

* hide all sprites 
	lea		INFLIGHT_ALIENS,a0
	move.w	#0x3F,d1
0:
	clr.l	(a0)+
	dbf		d1,0b     | Fill the entire INFLIGHT_ALIENS array with zero
    clr.b	ATTRACT_MODE_SCROLL_ID
    rts

SCROLL_ON_CONVOY_CHARGER_POINTS:
	jbsr	HANDLE_ALIEN_SWARM_SCROLL_RESET
	jbsr	HANDLE_INFLIGHT_ALIEN_SPRITE_UPDATE
	jbsr	HANDLE_INFLIGHT_ALIENS
	
	jbsr	HANDLE_DRAW_CONVOY_CHARGER_POINTS
	subq.b	#1,TEMP_COUNTER_1
	beq.b	0f
	rts
0:
	move.b	#0xD2,TEMP_COUNTER_1

* get ready to scroll the next alien sprite and associated points values on screen
	jbsr	INIT_CONVOY_CHARGER_SPRITE
	addq.b	#1,ATTRACT_MODE_SCROLL_ID     | set id to next thing to scroll on
	subq.b	#1,TEMP_COUNTER_2			  | dec TEMP_COUNTER_2
	beq.b	0f
	rts
0:
	move.b	#0xD2,TEMP_COUNTER_2
	addq.b	#1,SCRIPT_STAGE
	clr.b	OBJRAM_BACK_BUF+0x38		      | write to scroll offset in OBJRAM_BACK_BUF (0x4058)
	rts


*
* This important routine is responsible for handling the enemy sprites in the game. 
* It reads the position, colour and animation frame of each item in the INFLIGHT_ALIENS array and 
* projects it into the relevant INFLIGHT_ALIEN_SPRITE of OBJRAM_BACK_BUF_SPRITES. 
*
* In plain English: the sprite back buffer is filled by this routine :) 
* 
* JOTD: removed cocktail mode

HANDLE_INFLIGHT_ALIEN_SPRITE_UPDATE:
	lea		INFLIGHT_ALIENS,a2
	lea		OBJRAM_BACK_BUF_SPRITES,a3
*
** for the first 3 alien sprites, their Y coordinates need to be offset 7 pixels vertically so that the hardware can render them correctly.
	move.w	#3-1,d1                            | number of sprites to set sprite state for
	moveq	#7,d2							   | set pixel offset to 7
0:
	jbsr	SET_SPRITE_STATE
	add.w	#inflight_alien_size,a2
	addq.w	#0x4,a3
	dbf		d1,0b
*
** for the next 5 alien sprites, their Y coordinates need to be offset 8 pixels vertically.
	move.w	#5-1,d1                            | number of sprites to set sprite state for
	moveq	#8,d2							   | set pixel offset to 8
0:
	jbsr	SET_SPRITE_STATE
	add.w	#inflight_alien_size,a2
	addq.w	#0x4,a3
	dbf		d1,0b
	rts


*
* Extract the colour, position, animation frame information from an INFLIGHT_ALIEN structure
* and project it into a INFLIGHT_ALIEN_SPRITE.
*
* Expects:
* C = pixel adjustment for Y coordinate
* IX = pointer to INFLIGHT_ALIEN structure to extract information from
* IY = pointer to INFLIGHT_ALIEN_SPRITE structure to be filled
*

SET_SPRITE_STATE:
	tst.b	(IsActive,a2)                    	| test INFLIGHT_ALIEN.IsActive [bit  0,(ix+0x00)]
	jeq	SET_INACTIVE_OR_DYING_SPRITE_STATE                             	| if alien is not active, goto SET_INACTIVE_OR_DYING_SPRITE_STATE [jp   z,0x0C98]
	move.b	(Colour,a2),(2,a3)                    	| write to INFLIGHT_ALIEN_SPRITE.Colour [ld   (iy+0x02),a]
	move.b	(inf_alien_X,a2),d0                    	| read INFLIGHT_ALIEN.X [ld   a,(ix+0x03)]
	sub.b	#0x08,d0                         	| [sub  0x08]
	move.b	d0,(0x03,a3)                    	| write to INFLIGHT_ALIEN_SPRITE.X [ld   (iy+0x03),a]
	move.b	(inf_alien_Y,a2),d0                    	| read INFLIGHT_ALIEN.Y [ld   a,(ix+0x04)]
	not.b	d0                               	| flip bits [cpl]
	sub.b	d2,d0                            	| subtract pixel adjustment [sub  c]
	move.b	d0,(a3)                    	| write to INFLIGHT_ALIEN_SPRITE.Y [ld   (iy+0x00),a]

* Determine what way the alien is facing and set the sprite XFlip/YFlip/Code properties accordingly
*
* Important point to remember: non-flagship aliens are like bats. They hang upside down in the swarm.
* If you want to see what the sprites look like before being flipped, refer to my sprite grabs @
* http://seanriddle.com/galaxiansprites.html

	move.b	(AnimationFrame,a2),d0                    	| read INFLIGHT_ALIEN.AnimationFrame [ld   a,(ix+0x05)]
l_0c40:
			                            	| set flags [and  a]
	jpl	l_0c58                             	| [jp   p,0x0C58]

	cmp.b	#0xFA,d0                         	| compare to -6 [cp   0xFA]
	jmi	l_0c82                             	| [jp   m,0x0C82]

* alien is between an angle of 90 and 180 degrees (as player sees it)
	not.b	d0                               	| [cpl]
	add.b	#0x12,d0                         	| [add  a,0x12]
	or.b	#0x40,d0                          	| set X-Flip bit for sprite [or   0x40]
	add.b	(AnimFrameStartCode,a2),d0                     	| add in INFLIGHT_ALIEN.AnimFrameStartCode [add  a,(ix+0x0f)]
	move.b	d0,(0x01,a3)                    	| write to INFLIGHT_ALIEN_SPRITE.Code [ld   (iy+0x01),a]
	addq.b	#1,(0x03,a3)                    	| increment INFLIGHT_ALIEN_SPRITE.X [inc  (iy+0x03)]
	rts                                    	| [ret]

l_0c58:
	cmp.b	#0x06,d0                         	| [cp   0x06]
	jpl	l_0c6e                             	| [jp   p,0x0C6E]

* alien is between an angle of 180 and 270 degrees (as player sees it)
	add.b	#0x11,d0                         	| [add  a,0x11]
	or.b	#0xC0,d0                          	| set X-Flip and Y-Flip bits for sprite [or   0xC0]
	add.b	(AnimFrameStartCode,a2),d0                     	| add in INFLIGHT_ALIEN.AnimFrameStartCode [add  a,(ix+0x0f)]
	move.b	d0,(0x01,a3)                    	| write to INFLIGHT_ALIEN_SPRITE.Code [ld   (iy+0x01),a]
	addq.b	#1,(0x03,a3)                    	| increment INFLIGHT_ALIEN_SPRITE.X [inc  (iy+0x03)]
	addq.b	#1,(0x00,a3)                    	| increment INFLIGHT_ALIEN_SPRITE.Y [inc  (iy+0x00)]
	rts                                    	| [ret]

l_0c6e:
	cmp.b	#0x0C,d0                         	| [cp   0x0C]
	jpl	l_0c90                             	| [jp   p,0x0C90]

* alien is between an angle of 270-360 degrees (as player sees it)
	not.b	d0                               	| [cpl]
	add.b	#0x1E,d0                         	| [add  a,0x1E]
	bset	#7,d0                          	| set Y-Flip bit for sprite [or   0x80]
	add.b	(AnimFrameStartCode,a2),d0                     	| add in INFLIGHT_ALIEN.AnimFrameStartCode [add  a,(ix+0x0f)]
	move.b	d0,(0x01,a3)                    	| write to INFLIGHT_ALIEN_SPRITE.Code [ld   (iy+0x01),a]
	addq.b	#1,(0x00,a3)                    	| increment INFLIGHT_ALIEN_SPRITE.Y [inc  (iy+0x00)]
	rts                                    	| [ret]

l_0c82:
	cmp.b	#0xF4,d0                         	| [cp   0xF4]
	jmi	l_0c94                             	| [jp   m,0x0C94]

* alien is between an angle of 0-90 degrees (as player sees it)
	add.b	#0x1D,d0                         	| [add  a,0x1D]
	add.b	(AnimFrameStartCode,a2),d0                     	| add in INFLIGHT_ALIEN.AnimFrameStartCode [add  a,(ix+0x0f)]
	move.b	d0,(0x01,a3)                    	| write to INFLIGHT_ALIEN_SPRITE.Code [ld   (iy+0x01),a]
	rts                                    	| [ret]

l_0c90:
	sub.b	#0x18,d0                         	| [sub  0x18]
	jra	l_0c40                             	| [jr   0x0C40]

l_0c94:
	add.b	#0x18,d0                         	| [add  a,0x18]
	jra	l_0c40                             	| [jr   0x0C40]


*
* Jumped to from SET_SPRITE_STATE when the INFLIGHT_ALIEN is inactive or dying.
*
* Expects:
* C = pixel adjustment for Y coordinate
* IX = pointer to INFLIGHT_ALIEN structure
* IY = pointer to INFLIGHT_ALIEN_SPRITE structure

SET_INACTIVE_OR_DYING_SPRITE_STATE:
l_0c98:
	tst.b	(IsDying,a2)                    	| test INFLIGHT_ALIEN.IsDying flag [bit  0,(ix+0x01)]
	jeq	l_0cba                             	| if the alien has finally expired, goto 0x0CBA [jp   z,0x0CBA]

* alien is dying
	move.b	#0x07,(0x02,a3)                 	| set INFLIGHT_ALIEN_SPRITE.Colour [ld   (iy+0x02),0x07]
	move.b	(inf_alien_X,a2),d0                    	| read INFLIGHT_ALIEN.X [ld   a,(ix+0x03)]
	sub.b	#0x08,d0                         	| [sub  0x08]
	move.b	d0,(0x03,a3)                    	| set INFLIGHT_ALIEN_SPRITE.X [ld   (iy+0x03),a]
	move.b	(inf_alien_Y,a2),d0                    	| read INFLIGHT_ALIEN.Y [ld   a,(ix+0x04)]
	not.b	d0                               	| [cpl]
	sub.b	d2,d0                            	| subtract pixel adjustment value [sub  c]
	move.b	d0,(0x00,a3)                    	| set INFLIGHT_ALIEN_SPRITE.Y [ld   (iy+0x00),a]
	move.b	(DyingAnimFrameCode,a2),(0x01,a3)                    	| set INFLIGHT_ALIEN_SPRITE.Code [ld   (iy+0x01),a]
	rts                                    	| [ret]

* This alien has died. Move sprite off-screen
l_0cba:
	move.b	#0xF8,(0x03,a3)                 	| set INFLIGHT_ALIEN_SPRITE.X to value offscreen [ld   (iy+0x03),0xF8]
	move.b	#0xF8,(0x00,a3)                 	| set INFLIGHT_ALIEN_SPRITE.Y to value offscreen [ld   (iy+0x00),0xF8]
	rts                                    	| [ret]



DISPLAY_NAMCO_LOGO:
	jbsr	HANDLE_ALIEN_SWARM_SCROLL_RESET
	jbsr	HANDLE_INFLIGHT_ALIEN_SPRITE_UPDATE
	jbsr	HANDLE_INFLIGHT_ALIENS
	jbsr	HANDLE_DRAW_CONVOY_CHARGER_POINTS

* wait until TEMP_COUNTER_2 reaches 0
	subq.b	#1,TEMP_COUNTER_2
	beq.b	0f
	rts
0:
	addq.b	#1,SCRIPT_STAGE		| advance to next stage
	clr.b	OBJRAM_BACK_BUF+0x38		      | write to scroll offset in OBJRAM_BACK_BUF (0x4058)
	move.b	#0x11,TEMP_COUNTER_2
	move.b	#0x40,TEMP_COUNTER_1
	addq.b	#1,ATTRACT_MODE_SCROLL_ID
	move.w	#0x060F,d3            | command: PRINT_TEXT, parameter: #0x0F (Displays NAMCO logo)
	jra		QUEUE_COMMAND               


*
*
*
*
*

BLINK_CONVOY_CHARGER_POINTS:
	jbsr	HANDLE_ALIEN_SWARM_SCROLL_RESET
	jbsr	HANDLE_INFLIGHT_ALIEN_SPRITE_UPDATE
	jbsr	HANDLE_INFLIGHT_ALIENS
	jbsr	HANDLE_DRAW_CONVOY_CHARGER_POINTS
	jra		WAIT_FOR_TEMP_COUNTERS


*
* Cleanup for the "WE ARE THE GALAXIANS" page.
*
* Clears the screen. Hides the sprites. Displays GAME OVER.
*

CLEAR_WE_ARE_GALAXIANS_SCREEN_AND_DISPLAY_GAME_OVER:
	jbsr	HANDLE_ALIEN_SWARM_SCROLL_RESET                            	| call HANDLE_ALIEN_SWARM_SCROLL_RESET [call 0x0363]
* clear everything except HUD
	move.w	TEMP_CHAR_RAM_PTR,d6                   	| read contents of TEMP_CHAR_RAM_PTR. Now HL = pointer to row to clear [ld   hl,(0x400B)]
	move.b	#0x1C,d1                        	| we want to clear 0x1C (28 decimal) characters [ld   b,0x1C]
	move.b	#0x10,d0                        	| ordinal of empty character [ld   a,0x10]
	jbsr		rst_10_video					| Clear 28 characters on column
												| As the screen is 32 characters wide, we need to add 4 to get to... [ld   de,0x0004]
	addq.w	#4,d6                              	| the start of the next column
	move.w	d6,TEMP_CHAR_RAM_PTR                       	| Update TEMP_CHAR_RAM_PTR [ld   (0x400B),hl]

* wait until TEMP_COUNTER_2 reaches 0
	lea	TEMP_COUNTER_2,a0                      	| load HL with address of TEMP_COUNTER_2 [ld   hl,0x4009]
	subq.b	#1,(a0)                         	| [dec  (hl)]
	beq.b	0f
	rts                                    	| [ret  nz]
0:
	addq.b	#1,SCRIPT_STAGE                         	| advance to next stage of script [inc  (hl)]

* clear INFLIGHT_ALIENS array.
	lea	INFLIGHT_ALIENS,a0                      	| load HL with address of INFLIGHT_ALIENS [ld   hl,0x42B0]
	moveq	#0,d0                            	| [xor  a]
	move.b	d0,d1                           	| [ld   b,a]
	jbsr	rst_10                               	| Fill B bytes of memory from HL with value in A.

* hide all sprites & bullets
	lea	OBJRAM_BACK_BUF_SPRITES,a0                      	| pointer to OBJRAM_BACK_BUF_SPRITES [ld   hl,0x4060]
	move.b	#0x40,d1                        	| [ld   b,0x40]
	jbsr	rst_10								| clear sprite and bullet information from back buffer

* display GAME OVER
	move.b	#0x40,TEMP_COUNTER_1
	move.b	#0x4,TEMP_COUNTER_2       	| set TEMP_COUNTER_1 and TEMP_COUNTER_2 [ld   (0x4008),hl]
	jbsr	SET_COLOUR_ATTRIBUTES_TABLE_1                            	| call SET_COLOUR_ATTRIBUTES_TABLE_1 [call 0x0595]
	move.w	#0x0600,d3                      	| command: PRINT_TEXT, parameter: 0 (index of "GAME OVER") [ld   de,0x0600]
	jra	QUEUE_COMMAND                             	| jump to QUEUE COMMAND [jp   0x08F2]



*
* Displays GAME over and the amount of credit remaining.
*
* See also: DISPLAY_GAME_OVER_AND_REMAINING_CREDIT_1 @ 0x018C
*

DISPLAY_GAME_OVER_AND_REMAINING_CREDIT_2:
	move.w	#0x0701,d3                      	| command: DISPLAY_BOTTOM_OF_SCREEN_COMMAND , calls DISPLAY_AVAILABLE_CREDIT [ld   de,0x0701]
	jbsr	QUEUE_COMMAND                            	| call QUEUE_COMMAND [call 0x08F2]
	move.w	#0x600,d3                      	| command: PRINT_TEXT, parameter: 0 (index of "GAME OVER") [ld   de,0x0600]
	jbsr	QUEUE_COMMAND                            	| call QUEUE_COMMAND [call 0x08F2]
	addq.b	#1,SCRIPT_STAGE                         	| advance to next stage of script [inc  (hl)]
	move.b	#0x60,TEMP_COUNTER_1
	move.b	#0x10,TEMP_COUNTER_2       	| set TEMP_COUNTER_1 and TEMP_COUNTER_2 [ld   (0x4008),hl]
	rts                                    	| [ret]



*
* Clears the alien swarm from the screen.
*
*

CLEAR_ALIEN_SWARM_AND_SUSPEND_SWARM_ANIMATION:
	lea	ALIEN_SWARM_FLAGS,a0                      	| load HL with address of ALIEN_SWARM_FLAGS [ld   hl,0x4100]
	move.b	#0x80,d1                        	| sizeof(ALIEN_SWARM_FLAGS) [ld   b,0x80]
	moveq	#0,d0                            	| [xor  a]
	jbsr	rst_10		| Reset all flags in ALIEN_SWARM_FLAGS array
	move.b	d0,TIMING_VARIABLE                       	| clear TIMING_VARIABLE [ld   (0x425F),a]
	move.b	d0,DISABLE_SWARM_ANIMATION                       	| clear DISABLE_SWARM_ANIMATION [ld   (0x4238),a]
	move.b	#0x40,TEMP_COUNTER_2                      	| [ld   (hl),0x40]
	jra	l_0593                             	| advance to next stage of script [jp   0x0593]



*
*
*
*
*

CREATE_ATTRACT_MODE_ALIEN_SWARM:
	lea	PACKED_DEFAULT_SWARM_DEFINITION(pc),a1                      	| load DE with address of PACKED_DEFAULT_SWARM_DEFINITION [ld   de,0x051B]
	jbsr	UNPACK_ALIEN_SWARM                            	| call UNPACK_ALIEN_SWARM [call 0x0646]
	lea		DEFAULT_PLAYER_STATE,a0		| now HL = pointer to DEFAULT_PLAYER_STATE (0x052B)
	lea	CURRENT_PLAYER_STATE,a1                      	| load DE with address of CURRENT_PLAYER_STATE [ld   de,0x4218]
	move.w	#8,d1			| sizeof (CURRENT_PLAYER_STATE)
	jbsr	ldir                                    	| reset current player state to default
	clr.b	TIMING_VARIABLE                       	| reset TIMING_VARIABLE [ld   (0x425F),a]

* Give the demo player 1 life
	move.b	#1,PLAYER_LIVES                       	| set PLAYER_LIVES [ld   (0x421D),a]
	lea	SCRIPT_STAGE,a0                      	| pointer to SCRIPT_STAGE [ld   hl,0x400A]
	addq.b	#1,(a0)                         	| advance to next stage of script [inc  (hl)]
	move.w	    TEMP_CHAR_RAM_PTR,d6                        	| bump HL to point to TEMP_CHAR_RAM_PTR [inc  l]
	move.b	#0x96,d0                      	| [ld   (hl),0x96]
	bsr		osd_w_bg_videoram
	move.b	#0x40,FLAGSHIP_ATTACK_MASTER_COUNTER_1
	move.b	#0x06,FLAGSHIP_ATTACK_MASTER_COUNTER_2  	| set FLAGSHIP_ATTACK_MASTER_COUNTER_1 and FLAGSHIP_ATTACK_MASTER_COUNTER_2 [ld   (0x4245),hl]
	rts                                    	| [ret]


*
* In the demo mode, this erases all of the points values underneath the text "CHARGER"
*
* in D1: number of rows

CLEAR_DEMO_CONVOY_CHARGER_POINTS:
     move.w	#0x5193,d6            | address in character RAM
     move.w	#-32,d3            | offset to add to character RAM address  (-32 decimal.)
	 and.w	#0xFF,d1
	 subq.w	#1,d1
0:
     move.b	#3,d2               | 3 characters to erase
     move.b	#0x10,d0               | ordinal of empty character
1:
     jbsr	osd_w_bg_videoram           | write empty character to screen       
     add.w	d3,d6               | add offset. HL now points to character a row above, same column               
     subq.b	#1,d2               | decrement count of characters to erase
     bne.b	1b            | if not done goto 0x03CA
     add.w	#0x62,d6
     dbf	d1,0b
     rts


*
* Handles the drawing and blinking of the CONVOY CHARGER points values in the demo.
*
*
* Handles the drawing and blinking of the CONVOY CHARGER points values in the demo.
*

HANDLE_DRAW_CONVOY_CHARGER_POINTS:
	move.b	ATTRACT_MODE_SCROLL_ID,d0                       	| read ATTRACT_MODE_SCROLL_ID [ld   a,(0x4241)]
	bne.b	0f
	rts                                    	| if its zero, not time to scroll anything in yet, return [ret  z]
0:
	subq.b	#1,d0                           	| [dec  a]
	bne.b	0f
	rts                                    	| [ret  z]
0:

	move.b	d0,d1                           	| [ld   b,a]
	move.b	TIMING_VARIABLE,d0                       	| read TIMING_VARIABLE [ld   a,(0x425F)]
	move.b	d0,d2                           	| save it in C [ld   c,a]
	and.b	#0x3F,d0                         	| mask in bits 0..5. Now A is a value from 0..63 decimal. [and  0x3F]
	jeq	CLEAR_DEMO_CONVOY_CHARGER_POINTS                             	| if bits 0..5 are not set, call CLEAR_DEMO_CONVOY_CHARGER_POINTS [jr   z,0x03C0]

	cmp.b	#0x20,d0                         	| If A is not exactly 0x20.. [cp   0x20]
	beq.b	0f
	rts                                    	| .. exit [ret  nz]
0:

* When we get here, we need to compute what flagship scores we are going to draw.
* We basically take the value in TIMING_VARIABLE, AND the value by 3 to give an index value in range of 0..3, then
* multiply the index by 3 to give an offset into the flagship score table @0x039A.
* The end result is cycling flagship values.
	move.b	d2,d0                           	| A = TIMING_VARIABLE saved in C [ld   a,c]
	rol.b	#2,d0                            	| [rlca]*2
	and.b	#0x03,d0                         	| now A is a value from 0..3. A is now an index into table @0x039A [and  0x03]
	move.b	d0,d2                           	| multiply A... [ld   c,a]
	add.b	d0,d0                            	| [add  a,a]
	add.b	d2,d0                            	| .. by 3 [add  a,c]
	and.w	#0xff,d0                     	| extend A into DE. Now DE is an offset to add to HL

	lea	flagship_table_039A(pc),a0                      	| pointer to Flagship score table [ld   hl,0x039A]
	add.w	d0,a0
	move.w	#0x5193,d3                      	| address in character RAM [ld   de,0x5193]
	jbsr	DRAW_3_CHARACTERS                            	| call DRAW_3_CHARACTERS [call 0x03AF]
	subq.b	#1,d1                           	| [dec  b]
	bne.b	0f
	rts                                    	| [ret  z]
0:

* The alien scores are static and don't cycle, so we just draw them straight from the table
	lea	alien_table_03A6(pc),a0                      	| pointer to Alien score table [ld   hl,0x03A6]
l_0394:
	jbsr	DRAW_3_CHARACTERS                            	| call DRAW_3_CHARACTERS [call 0x03AF]
	subq.b	#1,d1                           	| [...]
	jne	l_0394                             	| [djnz 0x0394]
	rts                                    	| [ret]



*
* This routine is responsible for positioning alien sprites off screen ready to be scrolled onto the CONVOY CHARGER points table.
* Once the positioning is done, the sprite is "handed over" to the routine @ 0x109B.
*
* Expects: HL(a0) points to TEMP_COUNTER_2
*
* The value in TEMP_COUNTER_2 specifies what type of alien we are scrolling on:
*
* 4: Flagship
* 3: Red alien
* 2: Purple alien
* 1: Blue alien
*

INIT_CONVOY_CHARGER_SPRITE:
	moveq	#0,d0
	move.b	TEMP_COUNTER_2,d0     | read type of alien to scroll on
	subq.b	#1,d0		| convert A into a 0-based index 
	move.b	d0,d1
	
	lsl.w	#5,d0		| multiply A by 32 (which is sizeof(INFLIGHT_ALIEN))
	lea		INFLIGHT_ALIENS+4*inflight_alien_size,a0	  | HL = address of INFLIGHT_ALIENS[3]
	add.w	d0,a0					   | Add offset to HL. HL now points to INFLIGHT_ALIEN record we're using to scroll sprite on with
	move.b	#1,(IsActive,a0)            | set INFLIGHT_ALIEN.IsActive to 1 
	clr.b	(IsDying,a0)				| reset INFLIGHT_ALIEN.IsDying 
	move.b	#0xD,(StageOfLife,a0)			| set INFLIGHT_ALIEN.StageOfLife to INFLIGHT_ALIEN_CONVOY_CHARGER_SET_COLOUR_POS_ANIM
	clr.b	(inf_alien_Y,a0)               | set INFLIGHT_ALIEN.Y to position offscreen
	move.b	#0xC,(AnimationFrame,a0)		        | set INFLIGHT_ALIEN.AnimationFrame
	move.b	d1,(IndexInSwarm,a0)				     | set INFLIGHT_ALIEN.IndexInSwarm 
	rts


SET_SCRIPT_STAGE_TO_1:
	move.b	#1,SCRIPT_STAGE         | set SCRIPT_STAGE to 1
	move.b	#3,TEMP_COUNTER_1
	move.b	#3,TEMP_COUNTER_2
	rts

*
* Decrements value in TEMP_COUNTER_2. When counter value hits zero, advance script to next stage.
* 

WAIT_FOR_TEMP_COUNTER_2_THEN_ADVANCE_TO_NEXT_STAGE:
	subq.b	#1,TEMP_COUNTER_2        | decrement value of TEMP_COUNTER_2 counter
	beq.b	0f
	rts
0:
	addq.b	#1,SCRIPT_STAGE		| advance script to next stage
	rts

*
* Draw 3 characters in the same *column*.
* Because the Galaxian monitor is turned on its side, the characters look like they are on the same row.
* 
* Expects:
* A0 to point to 3 bytes defining the characters to draw 
* D3 to point to character RAM to draw to
*

DRAW_3_CHARACTERS:
    move.b	#3,d2               | number of characters to draw
	move.w	d3,d6
0:    
	move.b	(a0)+,d0           | read character to draw  
    jbsr		osd_w_bg_videoram  | write to character RAM
    sub.w	#0x20,d6           | subtract #0x20 (32 decimal) from it. Now DE points to character in same column, row above 
    subq.b	#1,d2              | decrement counter of characters to draw. 
    bne.b	0b                 | if counter !=0, more characters are to be drawn, goto 0x03B1
    add.w	#0x62,d6           | Add #0x62 (98 decimal) to DE. Now DE is back on row we started drawing from.
	move.w	d6,d3
    rts


*
* Decrements value in TEMP_COUNTER_1. When counter value hits zero, reset value of TEMP_COUNTER_1 to 0x3C (60 decimal)
* and then decrement value of TEMP_COUNTER_2. 
*
* When value of TEMP_COUNTER_2 hits zero, advance script to next stage.
*

WAIT_FOR_TEMP_COUNTERS:
	subq.b	#1,TEMP_COUNTER_1        | decrement value of TEMP_COUNTER_1 counter
	beq.b	0f
	rts
0:
	move.b	#0x3C,TEMP_COUNTER_1             | reset counter to 0x3C (50 decimal)
	bra.b	WAIT_FOR_TEMP_COUNTER_2_THEN_ADVANCE_TO_NEXT_STAGE	| and go check if that counter 2 has counted down to 0 yet 


SET_PUSH_START_BUTTON_COUNTER:
	move.b	#1,PUSH_START_BUTTON_COUNTER
	bra.b	WAIT_FOR_TEMP_COUNTERS
	
* < A1: player score which replaces high score
UPDATE_HIGH_SCORE:
		bsr	LEA_DE_OF_CURRENT_PLAYER_SCORE	| Now DE = pointer to current player score
		lea	HI_SCORE,a0		| address of high score
		moveq	#2,d2			| high score occupies 3 bytes
0:
		move.b	(a1)+,(a0)+
		dbf		d2,0b
		subq.w	#1,a1
l_21F8: move.w	#0x5241,d6            | character RAM address where HIGH SCORE will be drawn
		jbra	PLOT_SCORE_CHARACTERS

*
* This routine is responsible for processing all 8 elements in the INFLIGHT_ALIENS array. 
*

HANDLE_INFLIGHT_ALIENS:
	lea		INFLIGHT_ALIENS,a2           | load IX with address of 
	move.w	#8-1,d1							| 1 misc + 7 attacking aliens to process
0:
	move.l	d1,-(a7)
	jbsr	HANDLE_INFLIGHT_ALIEN_STAGE_OF_LIFE
	move.l	(a7)+,d1
	add.w	#inflight_alien_size,a2		        | bump IX to point to next INFLIGHT_ALIEN structure
	dbf		d1,0b               | do while b!=0
	rts

*
* Like humans, inflight aliens go through stages of life. They leave home, attack humans, maybe do a loop the loop,
* then (maybe) return home. Just like we do!
* 
* This routine is used to invoke actions appropriate for the alien's stage of life.
*
* Expects:
* IX = pointer to INFLIGHT_ALIEN structure.
*

HANDLE_INFLIGHT_ALIEN_STAGE_OF_LIFE:
	tst.b	(IsDying,a2)          | test INFLIGHT_ALIEN.IsDying flag
	jne		HANDLE_INFLIGHT_ALIEN_DYING    | if alien is dying, goto 
	tst.b	(IsActive,a2)          | test INFLIGHT_ALIEN.IsActive flag 
	bne.b	0f		| exit if not active
	rts
0:
* We need to determine what stage of life the inflight alien is at, then call the appropriate function to
* tell it how to behave. 
	moveq	#0,d0
	move.b	(StageOfLife,a2),d0 	| read INFLIGHT_ALIEN.StageOfLife
	add.w	d0,d0
	add.w	d0,d0
	lea		table_0CE6(pc),a0
	move.l	(a0,d0.w),a0
	jmp		(a0)

table_0CE6: 
      .long		INFLIGHT_ALIEN_PACKS_BAGS
      .long		INFLIGHT_ALIEN_FLIES_IN_ARC
      .long		INFLIGHT_ALIEN_READY_TO_ATTACK
      .long		INFLIGHT_ALIEN_ATTACKING_PLAYER
      .long		INFLIGHT_ALIEN_NEAR_BOTTOM_OF_SCREEN
      .long		INFLIGHT_ALIEN_REACHED_BOTTOM_OF_SCREEN
      .long		INFLIGHT_ALIEN_RETURNING_TO_SWARM
      .long		INFLIGHT_ALIEN_CONTINUING_ATTACK_RUN_FROM_TOP_OF_SCREEN 
      .long		INFLIGHT_ALIEN_FULL_SPEED_CHARGE 
      .long		INFLIGHT_ALIEN_ATTACKING_PLAYER_AGGRESSIVELY
      .long		INFLIGHT_ALIEN_LOOP_THE_LOOP
      .long		INFLIGHT_ALIEN_COMPLETE_LOOP
      .long		INFLIGHT_ALIEN_UNKNOWN_1091
      .long		INFLIGHT_ALIEN_CONVOY_CHARGER_SET_COLOUR_POS_ANIM
      .long		INFLIGHT_ALIEN_CONVOY_CHARGER_START_SCROLL  
      .long		INFLIGHT_ALIEN_CONVOY_CHARGER_DO_SCROLL


*
* Called when the alien is dying.
*

HANDLE_INFLIGHT_ALIEN_DYING:
	moveq	#0,d0
	move.b	(StageOfLife,a2),d0 	| read INFLIGHT_ALIEN.StageOfLife
	add.w	d0,d0
	add.w	d0,d0
	lea		table_10E8(pc),a0
	move.l	(a0,d0.w),a0
	jmp		(a0)

table_10E8:
    .long	INFLIGHT_ALIEN_DYING_SETUP_ANIM_AND_SOUND    
    .long	INFLIGHT_ALIEN_DYING_DISPLAY_EXPLOSION
    .long	INFLIGHT_ALIEN_DYING_FINALLY_BUYS_FARM
    .long	JUST_RTS

JUST_RTS:
	rts
	

*
* An alien's just about to break away from the swarm. It's leaving home!
* Before it can do so, we need to set up an INFLIGHT_ALIEN structure with defaults.
*
* Expects:
* IX = pointer to INFLIGHT_ALIEN structure
*

INFLIGHT_ALIEN_PACKS_BAGS:
	clr.b	(SortieCount,a2)                        	| clear INFLIGHT_ALIEN.SortieCount [ld   (ix+0x17),0x00]
	move.b	#0x01,d0                        	| [ld   a,0x01]
	move.b	d0,ENABLE_ALIEN_ATTACK_SOUND                       	| set ENABLE_ALIEN_ATTACK_SOUND to 1. [ld   (0x41C2),a]
	jbsr	SET_INFLIGHT_ALIEN_START_POSITION                            	| call SET_INFLIGHT_ALIEN_START_POSITION [call 0x1147]
	move.w	#0x100,d3					| command: DELETE_ALIEN_COMMAND
	move.b	(IndexInSwarm,a2),d3                        	| set command parameter to INFLIGHT_ALIEN.IndexInSwarm
                        	
	jbsr	QUEUE_COMMAND                            	| call QUEUE_COMMAND [call 0x08F2]
	move.b	d3,d0                           	| load A with INFLIGHT_ALIEN.IndexInSwarm [ld   a,e]
	and.b	#0x70,d0                         	| keep the row start, remove the column number [and  0x70]
	lea		l_1DD1(pc),a0                      	| [ld   hl,0x1DD1]
	ror.b	#3,d0                            	| divide the row offset... [rrca]
										| [rrca]
										| .. by 8. [rrca]
							| [ld   e,a]
	and.w	#0xFF,d3							| Extend A into DE  [ld   d,0x00]
	add.w	d3,a0                              	| HL = 0x1DD1 + (row number of alien /8)
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d0,(Colour,a2)                    	| set INFLIGHT_ALIEN.Colour [ld   (ix+0x16),a]

	addq.w	#1,a0                           	| [inc  hl]
	move.b	(a0),d0                         	| [ld   a,(hl)]
	move.b	d0,(Speed,a2)                    	| set INFLIGHT_ALIEN.Speed [ld   (ix+0x18),a]

	                         	| [ld   a,e]
	cmp.b	#0x0E,d3                         	| flagship? [cp   0x0E]
	jeq	l_0d58                             	| yes, goto 0x0D58 [jr   z,0x0D58]

	clr.b	(AnimFrameStartCode,a2)                          	| set INFLIGHT_ALIEN.AnimFrameStartCode [ld   (ix+0x0f),0x00]
l_0d39:
	move.b	#0x03,(TempCounter1,a2)                 	| set INFLIGHT_ALIEN.TempCounter1 to speed of animation (higher number = slower) [ld   (ix+0x10),0x03]
	move.b	#0x0C,(TempCounter2,a2)                 	| set INFLIGHT_ALIEN.TempCounter2 to total number of animation frames [ld   (ix+0x11),0x0C]
	clr.b	(ArcTableLsb,a2)                        	| set INFLIGHT_ALIEN.ArcTableLsb [ld   (ix+0x13),0x00]
	addq.b	#1,(StageOfLife,a2)                    	| set INFLIGHT_ALIEN.StageOfLife to INFLIGHT_ALIEN_FLIES_IN_ARC [inc  (ix+0x02)]

	btst.b	#0,(ArcClockwise,a2)                    	| test INFLIGHT_ALIEN.ArcClockwise [bit  0,(ix+0x06)]
	jne	l_0d53                             	| if alien will be facing right when it breaks away from swarm, goto 0x0D53 [jr   nz,0x0D53]
	move.b	#0x0C,(AnimationFrame,a2)                 	| set INFLIGHT_ALIEN.AnimationFrame [ld   (ix+0x05),0x0C]
	rts                                    	| [ret]

l_0d53:
	move.b	#0xF4,(AnimationFrame,a2)                 	| set INFLIGHT_ALIEN.AnimationFrame [ld   (ix+0x05),0xF4]
	rts                                    	| [ret]

* This code is called for flagships. We need to count how many escorts we have.
l_0d58:
	move.b	#0x18,(AnimFrameStartCode,a2)                   	| set INFLIGHT_ALIEN.AnimFrameStartCode [ld   (ix+0x0f),0x18]
	moveq	#0,d0                            	| [xor  a]
	tst.b	(inflight_alien_size+IsActive,a2)                    	| test if we have an escort [bit  0,(ix+0x20)]
	jeq	l_0d64                             	| no, goto 0x0D64 [jr   z,0x0D64]
	addq.b	#1,d0                           	| increment escort count [inc  a]
l_0d64:
	btst.b	#0,(inflight_alien_size*2+IsActive,a2)                    	| test if we have an escort [bit  0,(ix+0x40)]
	jeq	l_0d6b                             	| no, goto 0x0D6B [jr   z,0x0D6B]
	addq.b	#1,d0                           	| increment escort count [inc  a]
l_0d6b:
	move.b	d0,FLAGSHIP_ESCORT_COUNT                       	| set FLAGSHIP_ESCORT_COUNT [ld   (0x422A),a]
	jra	l_0d39                             	| finalise setting up flagship [jp   0x0D39]



*
* This function is used to animate an inflight alien flying in a,0x90 degree arc.
* It is called when an alien is breaking off from the swarm to attack the player,
* or when it is completing the last,0x90 degrees of a 360 degree loop the loop.
* As soon as the arc is complete, the alien's stage of life is set to
* INFLIGHT_ALIEN_READY_TO_ATTACK.
*
* Expects:
* IX = pointer to INFLIGHT_ALIEN that is breaking away from swarm.
*

INFLIGHT_ALIEN_FLIES_IN_ARC:
	moveq	#0,d6
	move.b	(ArcTableLsb,a2),d6                        	| read INFLIGHT_ALIEN.ArcTableLsb
	lea		INFLIGHT_ALIEN_ARC_TABLE(pc),a0			| Now HL points to start of INFLIGHT_ALIEN_ARC_TABLE at 0x1E00.
	move.b	(inf_alien_X,a2),d0                    	| read INFLIGHT_ALIEN.X [ld   a,(ix+0x03)]
	add.b	(a0,d6.w),d0                          	| add in X delta from table [add  a,(hl)]
	
	move.b	d0,(inf_alien_X,a2)                    	| update INFLIGHT_ALIEN.X [ld   (ix+0x03),a]
	addq.b	#1,d6                           	| bump HL to Y coordinate in table [inc  l]
	btst.b	#0,(ArcClockwise,a2)                    	| test INFLIGHT_ALIEN.ArcClockwise [bit  0,(ix+0x06)]
	jne	l_0da8                             	| if alien is facing right, goto 0x0DA8 [jr   nz,0x0DA8]

* alien that is leaving swarm to attack player will arc up and left.
* HL = pointer to table defining arc (see 0x1E00 for table layout)
	move.b	(inf_alien_Y,a2),d0                    	| load A with INFLIGHT_ALIEN.Y [ld   a,(ix+0x04)]
	add.b	(a0,d6.w),d0                          	| add in Y delta from table [add  a,(hl)]
	move.b	d0,(inf_alien_Y,a2)                    	| update INFLIGHT_ALIEN.Y [ld   (ix+0x04),a]
	addq.b	#0x07,d0                        	| [add  a,0x07]
	cmp.b	#0x0E,d0                         	| is the alien off-screen? [cp   0x0E]
	jcs	l_0dcc                             	| if A< #0x0E, its gone off screen, so make alien return to swarm from top of screen. [jr   c,0x0DCC]
	addq.w	#1,d6                            	| bump HL to point to next X,Y coordinate pair in table [inc  l]
	move.b	d6,(ArcTableLsb,a2)                     	| and update INFLIGHT_ALIEN.ArcTableLsb [ld   (ix+0x13),l]
* Tempcounter1 = delay before changing animation frame
* Tempcounter2 = number of animation frames left to do
	subq.b	#1,(TempCounter1,a2)                    	| decrement INFLIGHT_ALIEN.TempCounter1 [dec  (ix+0x10)]
	beq.b	0f
	rts                                    	| [ret  nz]
0:
	move.b	#0x04,(TempCounter1,a2)                 	| reset INFLIGHT_ALIEN.TempCounter1 [ld   (ix+0x10),0x04]
	subq.b	#1,(AnimationFrame,a2)                    	| update INFLIGHT_ALIEN.AnimationFrame to rotate the alien left [dec  (ix+0x05)]
	subq.b	#1,(TempCounter2,a2)                    	| decrement INFLIGHT_ALIEN.TempCounter2 [dec  (ix+0x11)]
	beq.b	0f
	rts                                    	| if we've not done all of the animation frames, exit [ret  nz]
0:

* OK, we've done all of the animation frames. The alien's ready to attack the player.
	addq.b	#1,(StageOfLife,a2)                    	| set stage of alien's life to INFLIGHT_ALIEN_READY_TO_ATTACK [inc  (ix+0x02)]
	rts                                    	| [ret]

* alien that is leaving swarm to attack player is arcing up and right
* HL = pointer to table defining arc
* IX = pointer to INFLIGHT_ALIEN structure
l_0da8:
	move.b	(inf_alien_Y,a2),d0                    	| read INFLIGHT_ALIEN.Y [ld   a,(ix+0x04)]
	sub.b	(a0,d6.w),d0                          	| read Y delta from table and subtract from INFLIGHT_ALIEN.Y [sub  (hl)]
	move.b	d0,(inf_alien_Y,a2)                    	| update INFLIGHT_ALIEN.Y [ld   (ix+0x04),a]
	addq.b	#0x07,d0                        	| [add  a,0x07]
	cmp.b	#0x0E,d0                         	| is the alien off-screen? [cp   0x0E]
	jcs	l_0dcc                             	| if A < #0x0E, its gone off screen, so make alien return to swarm from top of screen. [jr   c,0x0DCC]
	addq.b	#1,d6                            	| bump HL to point to next X,Y coordinate pair in table [inc  l]
	move.b	d6,(ArcTableLsb,a2)                     	| and update INFLIGHT_ALIEN.ArcTableLsb [ld   (ix+0x13),l]
* Tempcounter1 = delay before changing animation frame
* Tempcounter2 = number of animation frames left to do
	subq.b	#1,(TempCounter1,a2)                    	| decrement INFLIGHT_ALIEN.TempCounter1 [dec  (ix+0x10)]
	beq.b	0f
	rts                                    	| [ret  nz]
0:
	move.b	#0x04,(TempCounter1,a2)                 	| reset INFLIGHT_ALIEN.TempCounter1 [ld   (ix+0x10),0x04]
	addq.b	#1,(AnimationFrame,a2)                    	| update INFLIGHT_ALIEN.AnimationFrame to rotate the alien right [inc  (ix+0x05)]
	subq.b	#1,(TempCounter2,a2)                    	| decrement INFLIGHT_ALIEN.TempCounter2 [dec  (ix+0x11)]
	beq.b	0f
	rts                                    	| if we've not done all of the animation frames, exit [ret  nz]
0:

* OK, we've done all of the animation frames. The alien's ready to attack the player.
	addq.b	#1,(StageOfLife,a2)                    	| move to next stage of alien's life [inc  (ix+0x02)]
	rts                                    	| [ret]

* if we get here, an alien leaving the swarm has gone offscreen. It will return to the swarm from the top of the screen.
l_0dcc:
	move.b	#0x05,(StageOfLife,a2)                 	| set INFLIGHT_ALIEN.StageOfLife [ld   (ix+0x02),0x05]
	rts                                    	| [ret]

	
	



* Set the colour, X coordinate and animation frame of the INFLIGHT_ALIEN to,0xbe scrolled on
* beneath CONVOY CHARGER.
*
* Expects:
* IX = pointer to INFLIGHT_ALIEN structure
*
*

INFLIGHT_ALIEN_CONVOY_CHARGER_SET_COLOUR_POS_ANIM:
	move.b	(IndexInSwarm,a2),d0                    	| read INFLIGHT_ALIEN.IndexInSwarm [ld   a,(ix+0x07)]
* Value in A now identifies type of alien:
* 3: Flagship
* 2: Red alien
* 1: Purple alien
* 0: Blue alien
	not.b	d0                               	| flip the bits [cpl]
	and.b	#0x03,d0                         	| [and  0x03]

* now A is 0..3, where:
* 0: Flagship
* 1: Red alien
* 2: Purple alien
* 3: Blue alien
	move.b	d0,d1                           	| [ld   b,a]
	addq.b	#1,d0                           	| ensure colour value is nonzero [inc  a]
	move.b	d0,(Colour,a2)                    	| set INFLIGHT_ALIEN.Colour [ld   (ix+0x16),a]
	rol.b	#4,d0                            	| multiply A.. [rlca]*4 by 16
	add.b	#0x8C,d0                         	| X coord = 0x8C + (A * 16) [add  a,0x8C]
	move.b	d0,(inf_alien_X,a2)                    	| set INFLIGHT_ALIEN.X [ld   (ix+0x03),a]
	move.b	#0x18,(TempCounter1,a2)                 	| set INFLIGHT_ALIEN.TempCounter1 [ld   (ix+0x10),0x18]
	addq.b	#1,(StageOfLife,a2)                    	| advance alien to its next stage of life [inc  (ix+0x02)]
	clr.b	(AnimFrameStartCode,a2)                        	| set INFLIGHT_ALIEN.AnimFrameStartCode [ld   (ix+0x0f),0x00]
	move.b	d1,d0                           	| [ld   a,b]
	tst.b	d0                               	| flagship? [and  a]
	beq.b	0f
	rts                                    	| return if not [ret  nz]
0:

* This is a flagship, the animation frame start is different from the other aliens
	move.b	#0x18,(AnimFrameStartCode,a2)                 	| set INFLIGHT_ALIEN.AnimFrameStartCode [ld   (ix+0x0f),0x18]
	rts                                    	| [ret]



* On the WE ARE THE GALAXIANS.. CONVOY CHARGER attract mode page,
* start scrolling an alien sprite onto screen, and print its associated points values
*
* Expects:
* IX = pointer to INFLIGHT_ALIEN structure
*

INFLIGHT_ALIEN_CONVOY_CHARGER_START_SCROLL:
	addq.b	#1,(inf_alien_Y,a2)                    	| keep incrementing INFLIGHT_ALIEN.Y.. [inc  (ix+0x04)]
	subq.b	#1,(TempCounter1,a2)                    	| ..until this counter hits zero. [dec  (ix+0x10)]
	beq.b	0f
	rts                                    	| [ret  nz]
0:

	move.b	(IndexInSwarm,a2),d0                    	| read INFLIGHT_ALIEN.IndexInSwarm [ld   a,(ix+0x07)]
	add.b	#0x4B,d0                         	| set bit 6 to indicate the text needs to be scrolled on [add  a,0x4B]
	move.w	#0x600,d3		| command is PRINT_TEXT
	move.b	d0,d3
	jbsr	QUEUE_COMMAND                            	| call QUEUE_COMMAND [call 0x08F2]
	addq.b	#1,(StageOfLife,a2)                    	| advance to next stage of alien's life [inc  (ix+0x02)]
	rts                                    	| [ret]



*
* Scroll alien sprite onto screen
*
* Expects:
* IX = pointer to INFLIGHT_ALIEN structure
*

INFLIGHT_ALIEN_CONVOY_CHARGER_DO_SCROLL:
	move.b	(inf_alien_Y,a2),d0                    	| read INFLIGHT_ALIEN.Y [ld   a,(ix+0x04)]
	sub.b	#0xC8,d0                         	| [sub  0xC8]
	cmp.b	#0x05,d0                         	| [cp   0x05]
	bcc.b	0f
	* alien reached leftmost scroll: don't move anymore
	rts                                    	| [ret  c]
0:
	addq.b	#1,(inf_alien_Y,a2)                    	| update INFLIGHT_ALIEN.Y [inc  (ix+0x04)]
	rts                                    	| [ret]



*
* Set up a dying alien's death animation and sound effect.
*
* Expects:
* IX = pointer to INFLIGHT_ALIEN structure

INFLIGHT_ALIEN_DYING_SETUP_ANIM_AND_SOUND:
	move.b	#0x04,(TempCounter1,a2)                 	| set INFLIGHT_ALIEN.TempCounter1 to speed of death animation (lower = faster) [ld   (ix+0x10),0x04]
	move.b	#0x04,(TempCounter2,a2)                 	| set INFLIGHT_ALIEN.TempCounter2 to number of times to repeat death animation [ld   (ix+0x11),0x04]
	move.b	#0x1C,(DyingAnimFrameCode,a2)                 	| set INFLIGHT_ALIEN.DyingAnimFrameCode [ld   (ix+0x12),0x1C]
	addq.b	#1,(StageOfLife,a2)                    	| bump INFLIGHT_ALIEN.StageOfLife to next stage [inc  (ix+0x02)]
	move.b	(IndexInSwarm,a2),d0                    	| read INFLIGHT_ALIEN.IndexInSwarm [ld   a,(ix+0x07)]
	cmp.b	#0x70,d0                         	| is this a flagship? [cp   0x70]
	jcc	l_110c                             	| yes, goto 0x110C to play flagship hit sound [jr   nc,0x110C]
	move.b	#0x07,d0                        	| [ld   a,0x07]
	move.b	d0,ALIEN_DEATH_SOUND                       	| play sound effect of alien hit [ld   (0x41DF),a]
	rts                                    	| [ret]

* play flagship hit sound
l_110c:
	move.b	#0x17,d0                        	| [ld   a,0x17]
	move.b	d0,ALIEN_DEATH_SOUND                       	| play sound effect of flagship hit [ld   (0x41DF),a]
	rts                                    	| [ret]


*
* Show the dying alien explosion animation.
*
* Expects:
* IX = point to INFLIGHT_ALIEN structure
*

INFLIGHT_ALIEN_DYING_DISPLAY_EXPLOSION:
	subq.b	#1,(TempCounter1,a2)                    	| decrement INFLIGHT_ALIEN.TempCounter1 [dec  (ix+0x10)]
	beq.b	0f
	rts                                    	| if counter hasn't reached zero, not time to update explosion animation frame yet [ret  nz]
0:
	move.b	#0x04,(TempCounter1,a2)                 	| reset animation counter. Higher number = slower explosion animation speed [ld   (ix+0x10),0x04]
	addq.b	#1,(DyingAnimFrameCode,a2)       	| bump INFLIGHT_ALIEN.DyingAnimFrameCode to next frame [inc  (ix+0x12)]
	subq.b	#1,(TempCounter2,a2)      	| decrement INFLIGHT_ALIEN.TempCounter2 which holds count of frames left to show [dec  (ix+0x11)]
	beq.b	0f
	rts                                    	| if we've not shown all the explosion frames, exit [ret  nz]
0:

	move.b	(IndexInSwarm,a2),d0                    	| read INFLIGHT_ALIEN.IndexInSwarm [ld   a,(ix+0x07)]
	cmp.b	#0x70,d0                         	| is this a flagship? [cp   0x70]
	jcc	DISPLAY_FLAGSHIP_POINTS_VALUE                             	| yes, goto DISPLAY_FLAGSHIP_POINTS_VALUE [jr   nc,0x112D]
	clr.b	(IsDying,a2)                        	| alien's not a flagship, so just clear INFLIGHT_ALIEN.IsDying to say "we've finished dying, thanks". [ld   (ix+0x01),0x00]
	rts                                    	| [ret]


*
* After you shoot a flagship, display its points value for a while.
*

DISPLAY_FLAGSHIP_POINTS_VALUE:
	move.b	#0x32,(TempCounter1,a2)                 	| set INFLIGHT_ALIEN.TempCounter1 to length of time to keep points on screen [ld   (ix+0x10),0x32]
	move.b	FLAGSHIP_SCORE_FACTOR,d0                       	| read FLAGSHIP_SCORE_FACTOR. 3 = full (800) points [ld   a,(0x422D)]
	add.b	#0x20,d0                         	| [add  a,0x20]
	move.b	d0,(DyingAnimFrameCode,a2)                    	| set INFLIGHT_ALIEN.DyingAnimFrameCode [ld   (ix+0x12),a]
	addq.b	#1,(StageOfLife,a2)                    	| set INFLIGHT_ALIEN.StageOfLife (or death, should I say.) [inc  (ix+0x02)]
	rts                                    	| [ret]


* keeps points value on screen until counter hits zero.
*
* After that, the alien is officially dead and the INFLIGHT_ALIEN structure is ready for re-use by another (living) attacking alien.
*
INFLIGHT_ALIEN_DYING_FINALLY_BUYS_FARM:
	subq.b	#1,(TempCounter1,a2)                    	| decrement INFLIGHT_ALIEN.TempCounter1 [dec  (ix+0x10)]
	beq.b	0f
	rts                                    	| if points value countdown isn't zero, exit [ret  nz]
0:
	clr.b	(IsDying,a2)                        	| clear INFLIGHT_ALIEN.IsDying flag. [ld   (ix+0x01),0x00]
	rts                                    	| [ret]
	

*
* An alien that has just completed an arc animation (see docs @ 0x0D71 and 0x101F) is now ready to attack the player. 
*
* Expects:
* IX = pointer to INFLIGHT_ALIEN that will attack
*

INFLIGHT_ALIEN_READY_TO_ATTACK:
	addq.b	#1,(inf_alien_X,a2)				  | increment INFLIGHT_ALIEN.X
	move.b	(IndexInSwarm,a2),d0			 | read INFLIGHT_ALIEN.IndexInSwarm
	and.b	#0x70,d0                          | keep the row, remove the column
	cmp.b	#0x60,d0                          | is this a red alien?
	jbeq	l_0E20							   | yes, goto 0x0E20

INFLIGHT_ALIEN_DEFINE_FLIGHTPATH:
	move.b	PLAYER_Y,d1		| read PLAYER_Y 
	move.b	(inf_alien_Y,a2),d0 | read INFLIGHT_ALIEN.Y 
	sub.b	d1,d0               | A = INFLIGHT_ALIEN.Y  - PLAYER_Y
	jcs		l_0E0F             | if alien is to right of player, goto 0x0E0F

* alien is to left of player (d0 >= 0)
* A = signed number representing distance in pixels between alien Y and player Y. 
	asr.b	#1,d0	 				| divide distance by 2     
	add.b	#0x10,d0               | add 0x10 (16 decimal) to product
* clamp A between 0x30 and 0x70
	cmp.b   #0x30,d0                 | compare to 48 (decimal)
	jcc		0f            | if A>=48 goto 0x0DF0
	move.b   #0x30,d0
0:
	cmp.b   #0x70,d0                 | compare to 112 (decimal)  NB: 112 is half the screen height in pixels
	jcs		l_0DF6
	move.b	#0x70,d0

* PivotYValue is a Y coordinate to pivot around. You could think of it like the "origin" Y coordinate. 
* PivotYValueAdd is a delta (offset) to add to PivotYValue to produce the correct Y coordinate of the alien.
*
* PivotYValueAdd will increment if the player is to the left of the alien when it leaves the swarm,
* or decrement if the player is to the right. 

l_0DF6:
	move.b	d0,(PivotYValueAdd,a2)          | set INFLIGHT_ALIEN.PivotYValueAdd
	sub.b	(inf_alien_Y,a2),d0            | subtract INFLIGHT_ALIEN.Y 
	neg.b	d0
	move.b	d0,(a2,PivotYValue)          | set INFLIGHT_ALIEN.PivotYValue. Now PivotYValue + PivotYValueAdd = INFLIGHT_ALIEN.Y
	clr.b	(0x1a,a2)
	clr.b	(0x1b,a2)			| ???? unknown stuff, but probably useful!!
	clr.b	(0x1c,a2)

	addq.b	#1,(StageOfLife,a2)    | set stage of life to INFLIGHT_ALIEN_ATTACKING_PLAYER or INFLIGHT_ALIEN_ATTACKING_PLAYER_AGGRESSIVELY
	rts

* alien is to right of player (d0 < 0)
* A = signed number representing distance in pixels between alien and player.
	
l_0E0F:
	asr.b	#1,d0              | perform a shift right, with sign bit preserved
    sub  #0x10,d0
* clamp A between -48 and -112 decimal
	cmp.b   #0xD0,d0                  | compare to -48 (decimal)
	bcs.b	0f
	move.b	#0xD0,d0
0:           
	cmp.b   #0x90,d0                  | compare to -112 (decimal)  NB: 112 is half the screen height in pixels
	bcc.b	l_0DF6
	move.b	#0x90,d0		| clamp to 0x90 (-16)
	jra		l_0DF6


l_0E20:
	tst.b	INFLIGHT_ALIENS+inflight_alien_size+IsActive      | address of INFLIGHT_ALIENS[1].IsActive
	jeq		INFLIGHT_ALIEN_DEFINE_FLIGHTPATH                  | if not set then we are not part of a convoy, goto INFLIGHT_ALIEN_DEFINE_FLIGHTPATH

* make the alien accompany the flagship as part of a convoy. The PivotYValueAdd of the alien is the same as the flagship,
* so it will fly the same path.
	move.b	INFLIGHT_ALIENS+inflight_alien_size+PivotYValueAdd,d0	| read flagship INFLIGHT_ALIENS[1].PivotYValueAdd  
	jra		l_0DF6

*
* This is probably the most important routine for the INFLIGHT_ALIEN. 
*
* It is responsible for making an INFLIGHT_ALIEN fly down the screen, dropping bombs when it can.
*
* Expects:
* IX = pointer to INFLIGHT_ALIEN structure
*

INFLIGHT_ALIEN_ATTACKING_PLAYER:
	addq.b	#1,(inf_alien_X,a2)       | increment INFLIGHT_ALIEN.X 
	jbsr	UPDATE_INFLIGHT_ALIEN_YADD
	move.b	(PivotYValue,a2),d0         | load A with INFLIGHT_ALIEN.PivotYValue
	add.b	(PivotYValueAdd,a2),d0      | add in INFLIGHT_ALIEN.PivotYValueAdd to produce a Y coordinate      
	move.b	d0,(inf_alien_Y,a2)         | write to INFLIGHT_ALIEN.Y 
	addq.b	#7,d0
	cmp.b	#14,d0
	bcs.b	2f                          | if the alien has gone off the side of the screen, return to swarm
	move.b	(inf_alien_X,a2),d0			| load A with INFLIGHT_ALIEN.X
	add.b	#0x48,d0
	bcs.b	3f                          | if the alien is nearing the bottom of the screen, speed it up!
	tst.b	HAS_PLAYER_SPAWNED
	bne.b	0f
	rts		| return if player has not spawned
0:
	jbsr	CALCULATE_INFLIGHT_ALIEN_LOOKAT_ANIM_FRAME
* alien won't shoot at you if a flagship has been hit
	tst.b	IS_FLAGSHIP_HIT
	beq.b	1f		    | return if flagship was hit
	rts
1:
* Can this alien start shooting at you?
*
* code from 0x0E54-0E63 is akin to:
*
* byte yToCheck = INFLIGHT_ALIEN.X|
* for (byte l=0| l<INFLIGHT_ALIEN_SHOOT_RANGE_MUL|l++)
* {
*     if (yToCheck == INFLIGHT_ALIEN_SHOOT_EXACT_X)
*        goto TRY SPAWN_ENEMY_BULLET|
*     else
*        yToCheck+=0x19|
* }
*
	jra		l_0E54			| avoids code duplication


* If only one of these INCs are called (see 0x0E45), INFLIGHT_ALIEN.StageOfLife will be set to INFLIGHT_ALIEN_NEAR_BOTTOM_OF_SCREEN.
* If both these INCs are called (see 0x0E3E), set INFLIGHT_ALIEN.StageOfLife to INFLIGHT_ALIEN_REACHED_BOTTOM_OF_SCREEN. 
2:
	addq.b	#1,(StageOfLife,a2)
3:   
	addq.b	#1,(StageOfLife,a2)
	rts

*
* When an alien is close to the horizontal plane where the player resides, it speeds up to zoom by (or into) the player.
*
* Expects:
* IX = pointer to INFLIGHT_ALIEN structure
*

INFLIGHT_ALIEN_NEAR_BOTTOM_OF_SCREEN:
	move.b	TIMING_VARIABLE,d0
	and.b	#1,d0							| ..now A is either 0 or 1.
	addq.b	#1,d0		                    | ..now A is either 1 or 2. 
	add.b	(inf_alien_X,a2),d0
	move.b	d0,(inf_alien_X,a2)		        | Add either 1 or 2 pixels to INFLIGHT_ALIEN.X
	subq.b	#6,d0
	cmp.b	#3,d0                            | has alien gone off the bottom of the screen?
	jcs		0f
	jbsr		UPDATE_INFLIGHT_ALIEN_YADD
	move.b	(PivotYValueAdd,a2),d0           | read INFLIGHT_ALIEN.PivotYValueAdd
											 | set flags - we are interested if its a minus value
	bmi.b	1f								| if the PivotYValueAdd is a negative value, goto 0x0E90
	add.b	(a2,PivotYValue),d0             | add INFLIGHT_ALIEN.PivotYValue
	bcs.b	0f                              | carry flag set if alien has gone off side of screen,  goto 0x0E95
2:
	move.b	d0,(inf_alien_Y,a2)			            | set INFLIGHT_ALIEN.Y 
	rts
1:
	add.b	(a2,PivotYValue),d0             | add INFLIGHT_ALIEN.PivotYValue
	bcs.b	2b
	
* alien's went off the bottom or the side of the screen. 
0:
	addq.b	#1,(StageOfLife,a2)       | now call INFLIGHT_ALIEN_REACHED_BOTTOM_OF_SCREEN stage of life.
	rts


*
* An inflight alien has flown past the player and left the bottom of the visible screen. 
* 
*
* If the alien is not a flagship, it will always return to the top of the screen.
* Then, its behaviour is determined by flag state:
* 
*    If the HAS_PLAYER_SPAWNED flag is clear, the alien will rejoin the swarm. 
*
*    If both of the HAVE_AGGRESSIVE_ALIENS and HAVE_NO_BLUE_OR_PURPLE_ALIENS flags are clear, 
*    the alien will rejoin the swarm.
*
*    Otherwise, if the criteria above is not satisfied, the alien will keep attacking the player.  
*    
*        
* If the alien is a flagship, then the rules described @ 0x0EDA (INFLIGHT_ALIEN_FLAGSHIP_REACHED_BOTTOM_OF_SCREEN) apply. 
*
* Expects:
* IX = pointer to INFLIGHT_ALIEN structure
*

INFLIGHT_ALIEN_REACHED_BOTTOM_OF_SCREEN:
	move.b	#0x08,(inf_alien_Y,a2)          | set INFLIGHT_ALIEN.X to position at very top of screen
	addq.b	#1,(SortieCount,a2)             | increment INFLIGHT_ALIEN.SortieCount
	clr.b	(AnimationFrame,a2)             | clear INFLIGHT_ALIEN.AnimationFrame

* what type of alien are we dealing with?
	move.b	(IndexInSwarm,a2),d0			  | read INFLIGHT_ALIEN.IndexInSwarm  
	and.b	#0x70,d0                          | remove the column number from the index, keep the row
	cmp.b 	#0x70,d0						  | is this alien a flagship?
	jeq	INFLIGHT_ALIEN_FLAGSHIP_REACHED_BOTTOM_OF_SCREEN  | yes, goto INFLIGHT_ALIEN_FLAGSHIP_REACHED_BOTTOM_OF_SCREEN

l_0EAD:
*if the player has not spawned, the alien will return to the swarm.
	tst.b	HAS_PLAYER_SPAWNED
	jeq		0f	| if player has not spawned yet, goto 0x0ED6 - aliens return to swarm

*  if HAVE_AGGRESSIVE_ALIENS OR HAVE_NO_BLUE_OR_PURPLE_ALIENS flags are set, the alien will keep attacking (see 0x0EBF).
*  otherwise the alien returns to the swarm (see 0x0ED3 and 0x0F07)
	tst.b	HAVE_AGGRESSIVE_ALIENS
	jne		1f					| if aliens are aggressive, make alien reappear at top of screen, keep attacking 
	tst.b	HAVE_NO_BLUE_OR_PURPLE_ALIENS		| read HAVE_NO_BLUE_OR_PURPLE_ALIENS
	jeq		0f             | if we do have any blue or purple aliens, goto 0x0ED6 - aliens return to swarm

* alien reappears at top of screen and will keep attacking - it will not return to swarm. 
* add some unpredictability to where it reappears, so that player can't wait for it and shoot it easily
1:
	move.b	(inf_alien_Y,a2),d0              | read INFLIGHT_ALIEN.Y 
	lsr.b	#1,d0							 | divide by 2 (don't worry about carry, it was cleared by AND above)
	move.b	d0,d2
	jbsr	GENERATE_RANDOM_NUMBER
	and.b	#0x1F,d0                 | ensure random number is between 0..31 decimal
	add.b	d2,d0
	add.b	#0x20,d0
	move.b	d0,(inf_alien_Y,a2)        | set INFLIGHT_ALIEN.Y
	move.b	#0x28,(TempCounter1,a2)    | set INFLIGHT_ALIEN.TempCounter1 for INFLIGHT_ALIEN_UNKNOWN_OF3C to use.

* if both of these incs are called, the stage of life will be set to INFLIGHT_ALIEN_CONTINUING_ATTACK_RUN_FROM_TOP_OF_SCREEN. 
* if only the inc @ 0x0ED6 is invoked (see 0x0EB1), then the stage of life will be set to INFLIGHT_ALIEN_RETURNING_TO_SWARM.
	addq.b	#1,(StageOfLife,a2)		| increment INFLIGHT_ALIEN.StageOfLife
0:
	addq.b	#1,(StageOfLife,a2)		| increment INFLIGHT_ALIEN.StageOfLife
	rts

*
* A flagship has gone off screen.
*
* If the flagship had an escort, it will return to the top of the screen to fight again.
* If the flagship had no escort, it will flee the level. 
* A maximum of 2 fleeing flagships can be carried over to the next level.
*
* Expects:
* IX = pointer to INFLIGHT_ALIEN structure
*

INFLIGHT_ALIEN_FLAGSHIP_REACHED_BOTTOM_OF_SCREEN:
	tst.b	FLAGSHIP_ESCORT_COUNT        | test if flagship actually had any escort!
	jne	INFLIGHT_ALIEN_COUNT_FLAGSHIP_ESCORTS  | if flagship has escort, goto INFLIGHT_ALIEN_COUNT_FLAGSHIP_ESCORTS

* This flagship has no escort. It has escaped the level. 
* Deactivate the INFLIGHT_ALIEN record, and check if this flagship can be carried over to the next wave.
	clr.b	(IsActive,a2)			       | reset INFLIGHT_ALIEN.IsActive
	move.b	FLAGSHIP_SURVIVOR_COUNT,d0
	addq.b	#1,d0                  | add another one to the survivor count!
	cmp.b	#3,d0				   | have we got 3 surviving flagships?
	bcs.b	0f                     | if we have less than 3, that's OK, goto 0x0EEE

* We seem to have 3 flagships but only 2 flagships are allowed to be carried over...
	move.b	#2,d0				  | clamp surviving flagship count to 2.
0:
	move.b	d0,FLAGSHIP_SURVIVOR_COUNT
	rts


* count how many aliens were escorting the flagship. 
INFLIGHT_ALIEN_COUNT_FLAGSHIP_ESCORTS:
	moveq	#0,d0
	tst.b	(inflight_alien_size,a2)          | test IsActive flag of first escort  
	beq.b	0f 
	addq.b	#1,d0		| increment escort count
0:
	tst.b	(inflight_alien_size*2,a2)          | test IsActive flag of second escort  
	beq.b	1f 
	addq.b	#1,d0		| increment escort count
1:
	move.b	d0,FLAGSHIP_ESCORT_COUNT
	jra	l_0EAD         | make flagship reappear at top of screen



*
* An alien has either flown off the side or the bottom of the screen, and is returning to the swarm.
* 
* Expects:
* IX = pointer to INFLIGHT_ALIEN structure           
*

INFLIGHT_ALIEN_RETURNING_TO_SWARM:
	move.b	(inf_alien_X,a2),d1     | keep copy of INFLIGHT_ALIEN.X in B as SET_INFLIGHT_ALIEN_START_POSITION changes it 
    addq.b	#1,d1
    jbsr	SET_INFLIGHT_ALIEN_START_POSITION               | to determine where alien needs to go  

* INFLIGHT_ALIEN.Y  and INFLIGHT_ALIEN.X have been changed by SET_INFLIGHT_ALIEN_START_POSITION
	move.b	(inf_alien_X,a2),d0             | A = destination INFLIGHT_ALIEN.X
	move.b	d1,(inf_alien_X,a2)				| restore INFLIGHT_ALIEN.X back to what it was before
	sub.b	d1,d0                           | OK, how far away is this alien from where it wants to be?
	jbeq	INFLIGHT_ALIEN_BACK_IN_SWARM    | distance is zero, it's got where it wants to be, goto INFLIGHT_ALIEN_BACK_IN_SWARM
	cmp.b	#0x19,d0                 | 25 pixels away?
	bcs.b	0f
	rts		     | if distance is more than 0x19 (25 decimal), not near enough to destination, so exit
0:
	btst	#0,d0            | is distance an odd number?
	beq.b	1f
	rts						    | yes, so exit
1:
* Alien is less than 25 pixels away from its destination back in the swarm.
* We now need to determine what way to rotate the sprite so that it returns to the swarm upside-down, bat-style. 
	tst.b	(ArcClockwise,a2)       | read INFLIGHT_ALIEN.ArcClockwise
	bne.b	2f
	addq.b	#1,(AnimationFrame,a2)    | update INFLIGHT_ALIEN.AnimationFrame to rotate the alien right
	rts
2:
	subq.b	#1,(AnimationFrame,a2)    | update INFLIGHT_ALIEN.AnimationFrame to rotate the alien left
	rts
	
* alien has returned to swarm. Remove sprite and substitute sprite with characters.
INFLIGHT_ALIEN_BACK_IN_SWARM:
	clr.b	(IsActive,a2)                     | set INFLIGHT_ALIEN.IsActive to 0 - will hide sprite (see 0x0C98)
	lea		ALIEN_SWARM_FLAGS,a3          | MSB of ALIEN_SWARM_FLAGS address 
	moveq	#0,d6
	move.b	(IndexInSwarm,a2),d6                                              | Now a3+d6 = pointer to address in ALIEN_SWARM_FLAGS where alien belongs
	moveq	#0,d3							  | command: DRAW_ALIEN_COMMAND
	move.b	#1,(a3,d6.w)                      | mark flag in ALIEN_SWARM_FLAGS as "occupied". Our alien's back in the swarm!
	move.b	d6,d3							  | E = index of alien in swarm
	jra		QUEUE_COMMAND                     | jump to QUEUE COMMAND. Alien will be drawn in its place in the swarm.

*
* Called when aliens are aggressive and refuse to return to the swarm.
*
* This routine makes the alien fly from the top of the screen for [TempCounter1] pixels vertically.
* During this time it won't shoot, but it will gravitate towards the player's horizontal position (as the player sees it).
* 
* The trigger for this stage of life is when:
*     HAVE_AGGRESSIVE_ALIENS is set OR 
*     HAVE_NO_BLUE_OR_PURPLE_ALIENS flag is set 
* 
*

INFLIGHT_ALIEN_CONTINUING_ATTACK_RUN_FROM_TOP_OF_SCREEN:
	addq.b	#1,(inf_alien_X,a2)		| increment INFLIGHT_ALIEN.X
	move.b	PLAYER_Y,d0			  | read PLAYER_Y     
	sub.b	(inf_alien_Y,a2),d0		  | subtract INFLIGHT_ALIEN.Y 
	neg.b	d0
	add.b	d0,d0                     | A = A * 2
	move.b	d0,d4
	subx.b	d0,d0					 | A= 0 - Carry flag
	move.b	d0,d3
	lsl.w	#8,d3
	move.b	d4,d3
	add.w	d3,d3                    | DE = DE * 2
	move.b	(inf_alien_Y,a2),d4
	lsl.w	#8,d4
	move.b	(PivotYValue,a2),d4
	sub.w	d3,d4
	move.b	d4,(PivotYValue,a2)    | update INFLIGHT_ALIEN.Y 
	lsr.w	#8,d4                  
	move.b	d4,(inf_alien_X,a2)    | update INFLIGHT_ALIEN.PivotYValue
	subq.b	#1,(TempCounter1,a2)   | counter was set @ 0x0ECF
	beq.b	0f
	rts
0:
	addq.b	#1,(StageOfLife,a2)				| set INFLIGHT_ALIEN.StageOfLife to INFLIGHT_ALIEN_FULL_SPEED_CHARGE
	rts


*
* The inflight alien is now going to fly at full speed and zigzag to make it harder to shoot. 
* It won't drop bombs, but it will gravitate towards the player.
*
* When the alien gets to the vertical (as the player sees it) centre of the screen, the alien will loop
* the loop if there's enough space to do so. 
*
* After the loop is complete, the alien will start shooting.
*

INFLIGHT_ALIEN_FULL_SPEED_CHARGE:
	addq.b	#1,(inf_alien_X,a2)		| increment INFLIGHT_ALIEN.X

* first check the X coordinate to see if the alien is in the centre
	move.b	(inf_alien_X,a2),d0         | read INFLIGHT_ALIEN.X 
	sub.b  #0x60,d0                       
	cmp.b   #0x40,d0
	bcc.b	l_0F7B           | if INFLIGHT_ALIEN.X-0x60 >= 0x40, we're not centre horizontally   

* next thing we need to do is check if we have enough space for a loop.
	move.b	(inf_alien_Y,a2),d0          | read INFLIGHT_ALIEN.Y 
	sub.b  #0x60,d0                       
	cmp.b   #0x40,d0
	bcs.b	1f                 | yes, we have space, make alien loop the loop
l_0F7B:
* otherwise, make the alien veer erratically. 
	jbsr	INFLIGHT_ALIEN_DEFINE_FLIGHTPATH
	move.b	#3,(Speed,a2)                     | set INFLIGHT_ALIEN.Speed to maximum!
	move.b	#0x64,(TempCounter1,a2)            | set INFLIGHT_ALIEN.TempCounter1
	rts   
1:
	addq.b	#2,(StageOfLife,a2)                | set INFLIGHT_ALIEN.StageOfLife to INFLIGHT_ALIEN_LOOP_THE_LOOP 
	move.b	#3,(TempCounter1,a2)               | set INFLIGHT_ALIEN.TempCounter1 to delay before changing animation frame
	move.b	#0xc,(TempCounter2,a2)             | set INFLIGHT_ALIEN.TempCounter2 to number of animation frames in total
	clr.b	(AnimationFrame,a2)                | set INFLIGHT_ALIEN.AnimationFrame
	clr.b	(ArcTableLsb,a2)				  | set INFLIGHT_ALIEN.ArcTableLsb 
	move.b	PLAYER_Y,d0					| read PLAYER_Y 
	sub.b   (inf_alien_Y,a2),d0             | subtract INFLIGHT_ALIEN.Y 
	bcs.b	2f								| if player to right of alien, make alien loop the loop clockwise

* alien will perform an anti-clockwise loop
	clr.b	(ArcClockwise,a2)      | reset INFLIGHT_ALIEN.ArcClockwise
	rts
2:
	move.b	#1,(ArcClockwise,a2)      | set INFLIGHT_ALIEN.ArcClockwise
	rts


*
* You've killed a lot of the alien's friends. It's going to keep coming after you until one of you dies.
*
*
*

INFLIGHT_ALIEN_ATTACKING_PLAYER_AGGRESSIVELY:
	addq.b	#1,(inf_alien_X,a2)          | increment INFLIGHT_ALIEN.X
	jbsr	UPDATE_INFLIGHT_ALIEN_YADD
	move.b	(SortieCount,a2),d0           | read INFLIGHT_ALIEN.SortieCount           
	cmp.b	#4,d0						  | has the alien made it past the player 4 times?
	beq.b	4f							  | yes, exactly 4 times, *maybe* make alien closer to player                                                                 
	bcc.b	5f							| more than 4 times, make aliens hug player closer 
l_0FBE:
	move.b	(PivotYValue,a2),d0         | INFLIGHT_ALIEN.PivotYValue
	add.b	(PivotYValueAdd,a2),d0      | Add INFLIGHT_ALIEN.PivotYValueAdd 
	move.b	d0,(inf_alien_Y,a2)         | set INFLIGHT_ALIEN.Y 
* has alien wandered off left or right side of screen as player sees it?
	add.b	#7,d0
	cmp.b	#0xE,d0
	bcs.b	1f                          | alien has gone off side of screen, goto 0x0FF6

* is alien near bottom of the screen?
      move.b	(inf_alien_X,a2),d0          | read INFLIGHT_ALIEN.X
      add.b	#0x40,d0               | 
      bcs.b	2f             | if adding 0x40 pixels to X gives a result >255, then alien is near bottom of screen, goto 0x0FFB
      subq.b	#1,(TempCounter1,a2)
      beq.b	3f
	  tst.b	HAS_PLAYER_SPAWNED
      bne.b	11f
      rts                  | return if player has not spawned
11:
      jbsr	CALCULATE_INFLIGHT_ALIEN_LOOKAT_ANIM_FRAME
      tst.b	IS_FLAGSHIP_HIT
      beq.b	l_0E54
      rts                   | return if flagship has been hit
l_0E54:
* OK, can this alien start firing at you? Exact duplicate of code @0x0E54, look there for docs on how algorithm works. 
* Can this alien start shooting at you?
*
* code from 0x0E54-0E63 is akin to:
*
* byte yToCheck = INFLIGHT_ALIEN.X;
* for (byte l=0; l<INFLIGHT_ALIEN_SHOOT_RANGE_MUL;l++)
* {
*     if (yToCheck == INFLIGHT_ALIEN_SHOOT_EXACT_X)
*        goto TRY SPAWN_ENEMY_BULLET;
*     else
*        yToCheck+=0x19;
* }
*

	move.b	INFLIGHT_ALIEN_SHOOT_EXACT_X,d5
	move.b	INFLIGHT_ALIEN_SHOOT_RANGE_MUL,d6
	move.b	(inf_alien_X,a2),d0
10:
	cmp.b	d5,d0		| compare A to INFLIGHT_ALIEN_SHOOT_EXACT_X 
	jeq	TRY_SPAWN_ENEMY_BULLET	| if equal, jump to TRY_SPAWN_ENEMY_BULLET
	add.b	#0x19,d0				| add 0x19 (25 decimal) to A
	subq.b	#1,d6		| and try again...
	bne.b	10b
	rts
1:
	move.b	#0x05,(StageOfLife,a2)        | set INFLIGHT_ALIEN.StageOfLife to INFLIGHT_ALIEN_REACHED_BOTTOM_OF_SCREEN
    rts
2:
	move.b	#0x04,(StageOfLife,a2)        | set INFLIGHT_ALIEN.StageOfLife to INFLIGHT_ALIEN_NEAR_BOTTOM_OF_SCREEN
    rts
3:
	subq.b	#1,(StageOfLife,a2)
	rts
4:
* If we get here, the alien has survived exactly 4 continuous sorties.     
	btst	#0,TIMING_VARIABLE      | is the number odd?
	jeq		l_0FBE             | no, the number's even, it's business as usual, goto 0x0FBE
5:
* If we get here, the alien is going to "hug" the player a little bit closer than he might like.
* Note: This routine is *always* called if the alien survives 5 continuous sorties or more. 
	move.b	PLAYER_Y,d0		| read PLAYER_Y 
	sub.b  (a2,PivotYValue),d0  | subtract INFLIGHT_ALIEN.PivotYValue
	bcs.b	6f					|   if a carry occurred, alien is, as player sees it, to left of player ship

* Make the alien's pivot Y coordinate a bit closer to the player...
	addq.b	#1,(PivotYValue,a2)            | Update INFLIGHT_ALIEN.PivotYValue
	jra		l_0FBE
6:
	subq.b	#1,(PivotYValue,a2)            | Update INFLIGHT_ALIEN.PivotYValue
	jra		l_0FBE


*
* Aggressive aliens sometimes do a 360 degree loop to taunt the player.
*
* This routine rotates the alien 270 degrees. The remaining 90 degrees is done by the INFLIGHT_ALIEN_FLIES_IN_ARC routine. 
*
* Expects:  
* IX = pointer to INFLIGHT_ALIEN structure
*

INFLIGHT_ALIEN_LOOP_THE_LOOP:
	moveq	#0,d6
	move.b	(ArcTableLsb,a2),d6
	lea		INFLIGHT_ALIEN_ARC_TABLE(pc),a3
	add.w	d6,a3
* Now a3 is a pointer to an entry in the INFLIGHT_ALIEN_ARC_TABLE (see docs @ 0x1E00)
	move.b	(inf_alien_X,a2),d0
	sub.b	(a3)+,d0
	move.b	d0,(inf_alien_X,a2)     | subtract X component from table  

	tst.b	(ArcClockwise,a2)         | is this alien going to do a clockwise loop?
	jne		INFLIGHT_ALIEN_LOOPING_CLOCKWISE

* Alien is performing a counter-clockwise loop-the-loop maneuvre
	move.b	(inf_alien_Y,a2),d0			   | read INFLIGHT_ALIEN.Y
	sub.b	(a3),d0					      | subtract Y component from INFLIGHT_ALIEN_ARC_TABLE
	move.b	d0,(inf_alien_Y,a2)            | set INFLIGHT_ALIEN.Y 
* now update to next X,Y pair in INFLIGHT_ALIEN_ARC_TABLE
	addq.b	#2,d6
	move.b	d6,(ArcTableLsb,a2)             | set INFLIGHT_ALIEN.ArcTableLsb
	subq.b	#1,(TempCounter1,a2)            | decrement INFLIGHT_ALIEN.TempCounter1 
	beq.b	0f
	rts
0:

* When INFLIGHT_ALIEN.TempCounter1 counts down to zero, its time to change the animation frame
	move.b	#4,(TempCounter1,a2)    | reset INFLIGHT_ALIEN.TempCounter1 
	subq.b	#1,(AnimationFrame,a2)            | change sprite frame to appear to rotate LEFT

* INFLIGHT_ALIEN.TempCounter2 is used to count down number of animation frames left
	subq.b	#1,(TempCounter2,a2)            | decrement INFLIGHT_ALIEN.TempCounter2
	beq.b	2f                  | return if we haven't done 
	rts
2:
* we've done 270 degrees rotation, hand off the remaining 90 to the INFLIGHT_ALIEN_FLIES_IN_ARC 
	addq.b	#1,(StageOfLife,a2)   | bump INFLIGHT_ALIEN.StageOfLife to INFLIGHT_ALIEN_COMPLETE_LOOP
	move.b	#3,(TempCounter1,a2)        | set INFLIGHT_ALIEN.TempCounter1 to delay before changing animation frame
	move.b	#0xC,(TempCounter2,a2)        | set INFLIGHT_ALIEN.TempCounter2 to number of animation frames
	move.b	#0xC,(AnimationFrame,a2)       | set INFLIGHT_ALIEN.AnimationFrame
	clr.b	(a2,ArcTableLsb)          | set INFLIGHT_ALIEN.ArcTableLsb
	rts


* Alien is performing a clockwise loop-the-loop maneuvre
INFLIGHT_ALIEN_LOOPING_CLOCKWISE:
	move.b	(inf_alien_Y,a2),d0          | read INFLIGHT_ALIEN.Y
	add.b	(a3),d0              | add Y component from INFLIGHT_ALIEN_ARC_TABLE
	move.b	d0,(inf_alien_Y,a2)             | set INFLIGHT_ALIEN.Y
	                               | bump HL to point to next X,Y pair in INFLIGHT_ALIEN_ARC_TABLE
	addq.b	#2,d6
	move.b	d6,(ArcTableLsb,a2)             | set INFLIGHT_ALIEN.ArcTableLsb
	subq.b	#1,(TempCounter1,a2)            | decrement INFLIGHT_ALIEN.TempCounter1 
	beq.b	1f
	rts
1:

* When INFLIGHT_ALIEN.TempCounter1 counts down to zero, its time to change the animation frame
	move.b	#4,(TempCounter1,a2)           |  reset INFLIGHT_ALIEN.TempCounter1 
	addq.b	#1,(AnimationFrame,a2)         | change sprite frame to appear to rotate RIGHT
	subq.b	#1,(TempCounter2,a2)
	beq.b	2f
	rts
2:
* we've done 270 degrees rotation, hand off the remaining 90 to the INFLIGHT_ALIEN_FLIES_IN_ARC
	addq.b	#1,(StageOfLife,a2)            | bump INFLIGHT_ALIEN.StageOfLife to INFLIGHT_ALIEN_COMPLETE_LOOP
	move.b	#3,(TempCounter1,a2)        | set INFLIGHT_ALIEN.TempCounter1 to delay before changing animation frame
	move.b	#0xC,(TempCounter2,a2)        | set INFLIGHT_ALIEN.TempCounter2 to number of animation frames
	move.b	#0xF4,(AnimationFrame,a2)        | set INFLIGHT_ALIEN.AnimationFrame
	clr.b	(a2,ArcTableLsb)        | set INFLIGHT_ALIEN.ArcTableLsb
	rts


INFLIGHT_ALIEN_COMPLETE_LOOP:
		jra		INFLIGHT_ALIEN_FLIES_IN_ARC


INFLIGHT_ALIEN_UNKNOWN_1091:
	addq.b	#1,(inf_alien_X,a2)               | update INFLIGHT_ALIEN.X
	move.b	#8,(StageOfLife,a2)        | set INFLIGHT_ALIEN.StageOfLife to INFLIGHT_ALIEN_FULL_SPEED_CHARGE
	jra		l_0F7B               

*
* When an alien breaks off from the swarm to attack the player, the characters it occupies in the swarm are deleted and an alien sprite is substituted.
* This function calculates a starting X and Y coordinate for the sprite.
*
* This function is also used by INFLIGHT_ALIEN_RETURNING_TO_SWARM (see 0x0F07) to determine where in the swarm a returning alien should fly to.
*
*
* Expects:
* IX to point to an INFLIGHT_ALIEN structure.
*     (IX + 7) to be the index of the alien in the ALIEN_SWARM_FLAGS array.
*
*

SET_INFLIGHT_ALIEN_START_POSITION:
	move.b	(IndexInSwarm,a2),d0                    	| read INFLIGHT_ALIEN.IndexInSwarm [ld   a,(ix+0x07)]
	and.b	#0x70,d0                         	| compute row that alien is in [and  0x70]
	ror.b	#1,d0                            	| [rrca]
	move.b	d0,d2                           	| [ld   c,a]
	ror.b	#1,d0                            	| [rrca]
	add.b	d2,d0                            	| [add  a,c]
	neg.b	d0                               	| [neg]
	add.b	#0x7C,d0                         	| [add  a,0x7C]
	move.b	d0,(inf_alien_X,a2)                    	| set INFLIGHT_ALIEN.X [ld   (ix+0x03),a]

	move.b	(IndexInSwarm,a2),d0                    	| read INFLIGHT_ALIEN.IndexInSwarm [ld   a,(ix+0x07)]
	and.b	#0x0F,d0                         	| compute column that alien is in [and  0x0F]
	lsl.b	#4,d0   							| multiply by 16.. [rlca]*4
	addq.b	#0x07,d0                        	| [add  a,0x07]
	move.b	d0,d2                           	| [ld   c,a]
	move.b	SWARM_SCROLL_VALUE+1,d0                       	| read SWARM_SCROLL_VALUE [ld   a,(0x420E)]
	add.b	d2,d0                            	| [add  a,c]
	move.b	d0,(inf_alien_Y,a2)                    	| set INFLIGHT_ALIEN.Y [ld   (ix+0x04),a]
	rts                                    	| [ret]


*
* To monitor the input parameters type the following into the MAME debugger:
* bp 117E,1,{printf "IX=%04X:   H=%01X L=%01X D=%01X E=%01X", IX,H,L,D,E| g}
*

UPDATE_INFLIGHT_ALIEN_YADD:
	move.b	(Speed,a2),d0   | read INFLIGHT_ALIEN.Speed
    and.b  #0x03,d0
	addq.b	#1,d0         | now A is between 1 and 4.
	move.b	d0,d1

    move.b	(PivotYValueAdd,a2),d5          | read INFLIGHT_ALIEN.PivotYValueAdd in h
    move.b	(PivotYValueAdd+1,a2),d6		| in l
    move.b	(PivotYValueAdd+2,a2),d3
    move.b	(PivotYValueAdd+3,a2),d4
10:
	move.b	d6,d0  

* Part 1 - do H
	move.b	d5,d2                 | preserve H in C
	add.b	d0,d0
	bcc.b	0f

    subq.b	#1,d5
0:
    add.b	d0,d3
	move.b	d0,d3
    clr		d0
    addx.b	d5,d0

* I *think* this is to ensure that the signed byte in H never loses its sign.
* If it's positive it'll stay positive. If it's negative, it'll stay negative.
    cmp.b	#0x80,d0
	bne.b	1f
	move.b	d2,d0
1:
    move.b	d0,d5

* Part 2 - now do L
	move.b	d6,d2        | preserve L in C
	neg.b	d0
    add.b	d0,d0
	bcc.b	2f

    subq.b	#1,d6
2:
	add.b	d0,d4
	clr		d0
	addx.b	d6,d0
    cmp.b	#0x80,d0
	bne.b	3f
	move.b	d2,d0
3:
	move.b	d0,d6     | restore L from C
    dbf		D1,10b

    move.b	d5,(PivotYValueAdd,a2)          | stpre INFLIGHT_ALIEN.PivotYValueAdd
    move.b	d6,(PivotYValueAdd+1,a2)
    move.b	d3,(PivotYValueAdd+2,a2)
    move.b	d4,(PivotYValueAdd+3,a2)

	rts





* if we get here, the player bullet has hit an alien inflight.

	
*
* Value in register A       What it represents
* =====================================================
* 0                         Display Player one's score 
* 1                         Display Player two's score 
* 2                         Display high score.
* 3                         Do all of the above.
*

DISPLAY_SCORE_COMMAND:	
	cmp.b	#3,d0
	bcc.b		DISPLAY_ALL_SCORES       	| if A>= #0x03, goto 0x224D, DISPLAY_ALL_SCORES
	lea			PLAYER_ONE_SCORE+2,a0	| pointer to last 2 BCD digits of PLAYER_ONE_SCORE
	tst.b	d0
	beq.b		DECIDE_TO_DISPLAY_PLAYER_ONE_OR_PLAYER_TWO_SCORE	| if A is 0
	subq.b		#1,d0				    | if A was 1 on entry, then Z flag is now set
	bne.b		DISPLAY_HIGH_SCORE
	tst.b		IS_TWO_PLAYER_GAME
	bne.b		0f
	rts					| if it's zero, then we're just in a single player game, return
0:
	lea			PLAYER_TWO_SCORE+2,a0	        | pointer to last 2 BCD digits of PLAYER_TWO_SCORE
	jra			DECIDE_TO_DISPLAY_PLAYER_ONE_OR_PLAYER_TWO_SCORE

DISPLAY_HIGH_SCORE:
	lea		HI_SCORE+2,a0            | pointer to last 2 BCD digits of HI_SCORE
	jra		l_21F8

* This displays player scores and high scores
DISPLAY_ALL_SCORES:
	subq.b	#1,d0
	move.w	d0,-(a7)
	jbsr	DISPLAY_SCORE_COMMAND
	move.w	(a7)+,d0
	bne.b	DISPLAY_ALL_SCORES
	rts


* 
* Expects:
*
* Value in register A       Action taken                     
* ====================================================
* 0                         Display player one's score       
* 1                         Display player two's score
*      
* DE = pointer to *last* byte of 3 BCD bytes representing a score (ie: player 1 score, player 2 score)

DECIDE_TO_DISPLAY_PLAYER_ONE_OR_PLAYER_TWO_SCORE:
	move.w	#0x5381,d6            | pointer to character RAM location for player one's score
	tst.b	d0                    | test if A is 0.  
	beq.b	PLOT_SCORE_CHARACTERS | if A is 0 then we want to draw player one's score, goto 0x2261
	move.w	#0x5121,d6            | pointer to character RAM location for player one's score

*
* Plot score to the screen. 
*
* Expects:
*
* DE = pointer to *last* byte of 3 BCD bytes representing a score (ie: player 1 score, player 2 score, or high score)
*      See docs for PLAYER_ONE_SCORE to understand how scores are packed as BCD 
*
* D6 = pointer to character RAM to begin plotting characters from
*
*

PLOT_SCORE_CHARACTERS:
	move.w	#-0x20,d5	| load HL with 0xFFE0 (-32 decimal) 
	moveq	#2,d3       | a score is 3 bytes in size..                
	moveq	#4,d2		| max number of leading zeros that can be skipped. For example,
                                             | when you start the game you have a score of zero. It renders as "00". 
                                             | So this says "skip the first 4 zeros in the score, but display the rest"
0:
	move.b	(a0),d0		| read BCD digits from score byte
	lsr.b	#4,d0       | move high nibble (first digit of BCD number)...
	jbsr	PLOT_LOWER_NIB_AS_DIGIT   | call  to plot the first digit                 
	move.b	(a0),d0		| read BCD digits from score byte
	jbsr	PLOT_LOWER_NIB_AS_DIGIT     | call to plot the second digit 
	subq.w	#1,a0		| bump to *previous* BCD byte
	dbf		d3,0b       | do until all BCD digits in score have been drawn
	rts


* Pokes a digit of the score to character RAM.
*
* Expects:
*
* Lower nibble of D0: BCD digit to be plotted as a character on screen 
* D2 = max number of leading zero digits in the score that can be skipped. 
* If D2 is 0, zero digits will always be drawn
* D6 = pointer to character RAM where digit will be plotted.

PLOT_LOWER_NIB_AS_DIGIT:
	and.b	#0xF,d0		| mask in lower nibble
	beq.b	0f			| if the lower nibble is zero, goto 0x2281

* OK, we have a nonzero digit.
	clr		d2              | tell the plot routine to draw all digits, even if they are zero, from now on
	bra.b	1f				| go plot the character

* we have a zero digit. Do we print it, or print a space instead?
0:
	tst.b	d2        | how many zero digits can we skip over?   
	beq.b	1f		| if we can't skip over any more leading zero digits, then goto 0x2288 to draw "0". 

* Otherwise, we are skipping a leading "0" digit and will print an empty space instead..
	move.b	#0x80,d0	| when added to 0x90 this will produce 0x10 (16 decimal) - ordinal for empty character
	subq.b	#1,d2		| decrement count of leading zeros we are allowed to ignore
1:
	add.b	#0x90,d0    | transform A into ordinal of character to be plotted
	jbsr	osd_w_bg_videoram		| plot character for score to screen
	add.w	d5,d6		| now IX points to character directly above one just plotted
	rts


*
* Load DE (A1) with the [effective] address of the current player's score.
* 


LEA_DE_OF_CURRENT_PLAYER_SCORE:
	lea	PLAYER_ONE_SCORE,a1            | address of 
	tst.b	CURRENT_PLAYER     | read CURRENT_PLAYER           
	bne.b	0f					| if it is zero, then current player is player one. Return.
	rts
0:
	lea		PLAYER_TWO_SCORE,a1	| address of PLAYER_TWO_SCORE
	rts


*
* Credit has been inserted. Now wait for a start button to be pushed.
*
*
*

SCRIPT_TWO:
	jbsr	HANDLE_SWARM_MOVEMENT                            	| call HANDLE_SWARM_MOVEMENT [call 0x090D]
	jbsr	SET_ALIEN_PRESENCE_FLAGS                            	| call SET_ALIEN_PRESENCE_FLAGS [call 0x098E]
	moveq	#0,d0
	lea	l_0400(pc),a0
	move.b	SCRIPT_STAGE,d0                       	| read SCRIPT_STAGE [ld   a,(0x400A)]
	add.w	d0,d0
	add.w	d0,d0
	move.l	(a0,d0.w),a0
	jsr		(a0)				| jump to code @ 0x0400 + (A*2)
	jra		HANDLE_START_BUTTONS		| address of HANDLE_START_BUTTONS [ld   hl,0x0492]
	
l_0400:
	.long	INIT_0408
	.long	WAIT_BEFORE_DISPLAYING_PUSH_START_BUTTON
	.long	DISPLAY_PUSH_START_BUTTON_AND_BONUS_GALIXIP_FOR
	.long	BLINK_LAMPS_IF_CREDIT_INSERTED


INIT_0408:
	lea	COLOUR_ATTRIBUTE_TABLE_2(pc),a0                      	| pointer to COLOUR_ATTRIBUTE_TABLE_2 [ld   hl,0x1D91]
	jbsr	SET_COLOUR_ATTRIBUTES                            	| call SET_COLOUR_ATTRIBUTES [call 0x0598]

* hide all sprites
	lea	OBJRAM_BACK_BUF_SPRITES,a0 	| load HL with address of OBJRAM_BACK_BUF_SPRITES [ld   hl,0x4060]
	move.b	#0x40,d1                        	| [ld   b,0x40]
	moveq	#0,d0                            	| [xor  a]
	jbsr	rst_10		            	| Fill B bytes of memory from HL with value in A.

* hide all bullets and inflight aliens
	lea	ENEMY_BULLETS_START,a0                      	| load HL with address of ENEMY_BULLETS_START [ld   hl,0x4260]
	jbsr	rst_10			| Fill B bytes of memory from HL with value in A.
	lea	INFLIGHT_ALIENS,a0		| JOTD: added this, cleaner
	move.b	#0x50,d1                        	| [ld   b,0x50]
	jbsr	rst_10                               	| Fill B bytes of memory from HL with value in A.

	clr.b	DISABLE_SWARM_ANIMATION                       	| clear DISABLE_SWARM_ANIMATION [ld   (0x4238),a]
	clr.b	IS_COLUMN_SCROLLING                       	| clear IS_COLUMN_SCROLLING [ld   (0x40B0),a]
	move.w	#0x5002,TEMP_CHAR_RAM_PTR                       	| set TEMP_CHAR_RAM_PTR [ld   (0x400B),hl]
	move.b	#0x10,TEMP_COUNTER_2                      	| set countdown to 0x10 (16 decimal) [ld   (hl),0x10]
	addq.b	#1,SCRIPT_STAGE                         	| advance to next stage of script [inc  (hl)]
	rts                                    	| [ret]



WAIT_BEFORE_DISPLAYING_PUSH_START_BUTTON:
	lea	PUSH_START_BUTTON_COUNTER,a0                      	| pointer to PUSH_START_BUTTON_COUNTER [ld   hl,0x4019]
	subq.b	#1,(a0)                         	| decrement counter [dec  (hl)]
	jne	BLINK_LAMPS_IF_CREDIT_INSERTED                             	| if non zero, goto BLINK_LAMPS_IF_CREDIT_INSERTED [jp   nz,0x0473]
* counter's hit zero, go to next stage of script.
	                     	| pointer to SCRIPT_STAGE [ld   hl,0x400A]
	addq.b	#1,SCRIPT_STAGE                         	| advance to next stage of script [inc  (hl)]
	lea	ALIEN_SWARM_FLAGS,a0                      	| load HL with address of ALIEN_SWARM_FLAGS [ld   hl,0x4100]
	move.b	#0x80,d1                        	| sizeof(ALIEN_SWARM_FLAGS) [ld   b,0x80]
	moveq	#0,d0                            	| [xor  a]
	jbsr	rst_10	| Fill B bytes of memory from HL with value in A.
	rts                                    	| [ret]




DISPLAY_PUSH_START_BUTTON_AND_BONUS_GALIXIP_FOR:
	move.w	TEMP_CHAR_RAM_PTR,d6                   	| Get pointer to row to clear from TEMP_CHAR_RAM_PTR [ld   hl,(0x400B)]
	move.b	#0x1C,d1                        	| #0x1C (28 decimal) characters to clear [ld   b,0x1C]
	move.b	#0x10,d0                        	| Ordinal for empty space character [ld   a,0x10]
	jbsr	rst_10_video							| Fill B bytes of memory from HL with value in A.
	addq.w	#4,d6	                      	| We've done 28 characters. Need 4 more to move to next row. [ld   de,0x0004]
											| Adjust HL to point to start of next row
	move.b	#0x1C,d1                        	| #0x1C (28 decimal) characters to clear [ld   b,0x1C]
    jbsr	rst_10_video                           	| Fill B bytes of memory from HL with value in A.
	addq.w	#4,d6                              	| Adjust HL to point to start of next row
	move.w	d6,TEMP_CHAR_RAM_PTR                       	| And update TEMP_CHAR_RAM_PTR pointer [ld   (0x400B),hl]

* wait for TEMP_COUNTER_2 to reach 0
	subq.b	#1,TEMP_COUNTER_2                         	| [dec  (hl)]
	beq.b	0f
	rts                                    	| [ret  nz]
0:

* then move to next stage of script
	addq.b	#1,SCRIPT_STAGE                         	| advance to next stage of script [inc  (hl)]

* reset screen orientation to defaults
	moveq	#0,d0                            	| [xor  a]
	*move.b	d0,l_7006                       	| set regen hflip [ld   (0x7006),a]
	*move.b	d0,l_7007                       	| set regen vflip [ld   (0x7007),a]
	move.b	d0,DISPLAY_IS_COCKTAIL_P2                       	| set DISPLAY_IS_COCKTAIL_P2 [ld   (0x4018),a]

* display BONUS GALIXIP FOR and PUSH START BUTTON messages
	move.w	#0x601,d3                      	| command: PRINT_TEXT, parameter: 1 (index of "PUSH START BUTTON") [ld   de,0x0601]
	jbsr	QUEUE_COMMAND                            	| call QUEUE_COMMAND [call 0x08F2]
	move.w	#0x702,d3                      	| command: DISPLAY_BOTTOM_OF_SCREEN_COMMAND , parameter: 2 (invokes DISPLAY_BONUS_GALIXIP_FOR) [ld   de,0x0702]
	jbsr	QUEUE_COMMAND                            	| call QUEUE_COMMAND [call 0x08F2]
	
	* continue below...

*
*
* Make the lamps on the arcade cabinet blink if credit(s) available.
*
*

BLINK_LAMPS_IF_CREDIT_INSERTED:
	move.b	TIMING_VARIABLE,d0                       	| read TIMING_VARIABLE [ld   a,(0x425F)]
	and.b	#0x20,d0                         	| mask in bit 5 [and  0x20]
	jeq	l_048b                             	| if bit 5 is not set, turn off the lamps [jr   z,0x048B]

* Does player have credit? If not, then don't turn the lamps on.
	move.b	NUM_CREDITS,d0                       	| read NUM_CREDITS [ld   a,(0x4002)]
	tst.b	d0                               	| test if credits is 0 [and  a]
	bne.b	0f
	rts                                    	| return if no credits [ret  z]
0:

* turn the lamps on to show you have credit
	move.b	d0,d1                           	| [ld   b,a]
	move.b	#0x01,d0                        	| [ld   a,0x01]
	*move.b	d0,l_6000                       	| turn on lamp 1 [ld   (0x6000),a]
	subq.b	#1,d1                           	| [dec  b]
	bne.b	0f
	rts                                    	| [ret  z]
0:
	*move.b	d0,l_6001                       	| turn on lamp 2 [ld   (0x6001),a]
	rts                                    	| [ret]

* turn lamps off
l_048b:
	*move.b	d0,l_6000                       	| turn on/off lamp 1 [ld   (0x6000),a]
	*move.b	d0,l_6001                       	| turn on/off lamp 2 [ld   (0x6001),a]
	rts                                    	| [ret]




*
*
* Handle 1P or 2P being pressed.
*
* Notes:
* 1P = deducts 1 credit.
* 2P = deducts 2 credits
*

HANDLE_START_BUTTONS:
	move.b	PORT_STATE_6800,d0                       	| read PORT_STATE_6800 [ld   a,(0x4011)]
	btst.b	#0,d0                           	| test for 1P START button being hit [bit  0,a]
	jne	ONEP_START_BUTTON_HANDLER                             	| if button is hit, goto 1P_START_BUTTON_HANDLER [jr   nz,0x04F2]
	btst.b	#1,d0                           	| test for 2P START button being hit [bit  1,a]
	bne.b	0f
	rts                                    	| [ret  z]
0:

* The following piece of code executes when 2P START button is pushed
TWOP_START_BUTTON_HANDLER:
	move.b	NUM_CREDITS,d0                       	| read NUM_CREDITS [ld   a,(0x4002)]
	cmp.b	#0x02,d0                         	| do we have at least 2 credits for a 2 player game? [cp   0x02]
	bcc.b	0f
	rts                                    	| if credits < 2, then we don't have enough credit, return [ret  c]
0:
	subq.b	#0x02,d0                        	| otherwise, reduce credits by 2 [sub  0x02]
	move.b	d0,NUM_CREDITS                       	| and update NUM_CREDITS with remainder [ld   (0x4002),a]

* initialise player 2's state (lives etc) to defaults
	lea	PACKED_DEFAULT_SWARM_DEFINITION(pc),a0                      	| load HL with address of PACKED_DEFAULT_SWARM_DEFINITION [ld   hl,0x051B]
	lea	PLAYER_TWO_PACKED_SWARM_DEF,a1                      	| load DE with address of PLAYER_TWO_PACKED_SWARM_DEF [ld   de,0x41A0]
	move.w	#0x0020,d1                          	| sizeof (PLAYER_TWO_STATE+PLAYER_TWO_PACKED_SWARM_DEF)
	bsr		ldir

* if dip switch 5 is on, then player 2 gets 3 lives
	move.b	DIP_SWITCH_5_STATE,d0                       	| read DIP_SWITCH_5_STATE [ld   a,(0x401F)]
	ror.b	#1,d0                            	| move bit 0 into carry [rrca]
	bcc	0f
	jbsr	AWARD_PLAYER_TWO_THREE_LIVES                            	| if carry is set, call AWARD_PLAYER_TWO_THREE_LIVES [call c,0x050F]
0:
	move.w	#0,d5                      	| CURRENT_PLAYER will be set to 0, IS_TWO_PLAYER_GAME set to 1 [ld   hl,0x0100]
	move.w	#1,d6
l_04bc:
	move.b	d5,CURRENT_PLAYER                       	| set CURRENT_PLAYER, and IS_TWO_PLAYER_GAME [ld   (0x400D),hl]
	move.b	d6,IS_TWO_PLAYER_GAME                       	| set CURRENT_PLAYER, and IS_TWO_PLAYER_GAME [ld   (0x400D),hl]

* Create alien swarm and load default settings for player 1
	lea	PACKED_DEFAULT_SWARM_DEFINITION(pc),a0                      	| load HL with address of PACKED_DEFAULT_SWARM_DEFINITION [ld   hl,0x051B]
	lea	PLAYER_ONE_PACKED_SWARM_DEF,a1                      	| load DE with address of PLAYER_ONE_PACKED_SWARM_DEF [ld   de,0x4180]
	move.w	#0x0020,d1                          	| sizeof (PLAYER_ONE_PACKED_SWARM_DEF)+sizeof(PLAYER_ONE_STATE)
	bsr		ldir
* if dip switch 5 is on, then player 1 gets 3 lives
	move.b	DIP_SWITCH_5_STATE,d0                       	| read DIP_SWITCH_5_STATE [ld   a,(0x401F)]
	ror.b	#1,d0                            	| move bit 0 into carry [rrca]
	bcc	0f
	jbsr	AWARD_PLAYER_ONE_THREE_LIVES                            	| if carry is set, call AWARD_PLAYER_ONE_THREE_LIVES [call c,0x0515]
0:

	moveq	#0,d0                            	| [xor  a]
	move.b	d0,SCRIPT_STAGE                       	| set SCRIPT_STAGE to 0 [ld   (0x400A),a]
	move.b	#0x03,d0                        	| [ld   a,0x03]
	move.b	d0,SCRIPT_NUMBER                       	| set SCRIPT_NUMBER to 3 [ld   (0x4005),a]
	move.b	#0x01,d0                        	| [ld   a,0x01]
	move.b	d0,IS_GAME_IN_PLAY                       	| set IS_GAME_IN_PLAY [ld   (0x4006),a]
	move.b	d0,PLAY_GAME_START_MELODY                       	| [ld   (0x41D1),a]

* Display high score, reset P1 and P2's score to 0
	move.w	#0x604,d3                      	| command: PRINT_TEXT, parameter: 4 (index of "HIGH SCORE") [ld   de,0x0604]
	jbsr	QUEUE_COMMAND                            	| call QUEUE_COMMAND [call 0x08F2]
	move.w	#0x400,d3                      	| command: RESET_SCORE_COMMAND, parameter: 0 (reset player 1's score and clear life awarded) [ld   de,0x0400]
	jbsr	QUEUE_COMMAND                            	| call QUEUE_COMMAND [call 0x08F2]
	addq.b	#1,d3                            	| command: RESET_SCORE_COMMAND, parameter: 1 (reset player 2's score and clear life awarded) [inc  e]
	jra	QUEUE_COMMAND                             	| jump to QUEUE COMMAND [jp   0x08F2]


*
* Called when 1P START is pressed
*

ONEP_START_BUTTON_HANDLER:
l_04f2:
	move.b	NUM_CREDITS,d0                       	| read number of credits [ld   a,(0x4002)]
	tst.b	d0                               	| test if number of credits is zero [and  a]
	jeq	l_0509                             	| if number of credits is zero, goto 0x0509 [jr   z,0x0509]
	subq.b	#1,d0                           	| otherwise reduce number of credits by 1 [dec  a]
	move.b	d0,NUM_CREDITS                       	| and store back in credit counter [ld   (0x4002),a]
	lea	PLAYER_TWO_PACKED_SWARM_DEF,a0                      	| load HL with address of PLAYER_TWO_PACKED_SWARM_DEF [ld   hl,0x41A0]
	move.b	#0x20,d1                        	| sizeof(PLAYER_TWO_PACKED_SWARM_DEF) + sizeof(PLAYER_TWO_STATE) [ld   b,0x20]
	moveq	#0,d0                            	| [xor  a]
	jbsr	rst_10						| clear player 2 swarm & state as we're not using them
	moveq	#0,d5                      	| CURRENT_PLAYER will be set to 0, IS_TWO_PLAYER_GAME set to 0 [ld   hl,0x0000]
	moveq	#0,d6                      	| CURRENT_PLAYER will be set to 0, IS_TWO_PLAYER_GAME set to 0 [ld   hl,0x0000]
	jra	l_04bc                             	| go set CURRENT_PLAYER, and IS_TWO_PLAYER_GAME. [jp   0x04BC]

l_0509:
	move.b	#0x01,SCRIPT_NUMBER                       	| set SCRIPT_NUMBER to 1 [ld   (0x4005),a]
	rts                                    	| [ret]



* Only called if Dip Switch 5 is set to ON
AWARD_PLAYER_TWO_THREE_LIVES:
	move.b	#0x03,d0                        	| [ld   a,0x03]
	move.b	d0,PLAYER_TWO_LIVES                       	| Set number of lives for player 2 [ld   (0x41B5),a]
	rts                                    	| [ret]


* Only called if Dip Switch 5 is set to ON
AWARD_PLAYER_ONE_THREE_LIVES:
	move.b	#0x03,d0                        	| [ld   a,0x03]
	move.b	d0,PLAYER_ONE_LIVES                       	| Set number of lives for player 1 [ld   (0x4195),a]
	rts                                    	| [ret]



*DEFAULT_SWARM_DEFINITION_AND_PLAYER_STATE    | EQU 0x051B:
*    PACKED_DEFAULT_SWARM_DEFINITION:
*    | The first 16 bytes defining the default alien swarm. 
*    | For information on how the bytes are unpacked, please see docs @ 0x0646
*    051B: 00 00 00 00 F8 1F F8 1F F8 1F F0 0F E0 07 40 02            
*
*    | When starting a new game, these are the default values 
*    DEFAULT_PLAYER_STATE:
*    052B: 3C                                 | Default value for DIFFICULTY_COUNTER_1 
*    052C: 14                                 | Default value for DIFFICULTY_COUNTER_2
*    00 02 00 02 00 0F 00 00 00            
*
*
*
* This script is responsible for managing PLAYER 1's game.
*
*
*

SCRIPT_THREE:
	jbsr	HANDLE_SWARM_MOVEMENT                            	| call HANDLE_SWARM_MOVEMENT [call 0x090D]
	jbsr	SET_ALIEN_PRESENCE_FLAGS                            	| call SET_ALIEN_PRESENCE_FLAGS [call 0x098E]
	moveq	#0,d0
	move.b	SCRIPT_STAGE,d0                       	| [ld   a,(0x400A)]
	add.w	d0,d0
	add.w	d0,d0
	lea		l_0540(pc),a0		
	move.l	(a0,d0.w),a0		| jump to code @ l_0540 + (A*2)
	jmp		(a0)
l_0540:
	.long	l_0550
	.long	CLEAR_ROW_OF_SCREEN
	.long	PLAYER_ONE_INIT
	.long	CLEAR_PLAYER_TEXT
	.long	HANDLE_SPAWN_PLAYER
	.long	HANDLE_MAIN_GAME_LOGIC
	.long	HANDLE_PLAYER_ONE_KILLED
	.long	SWITCH_TO_PLAYER_TWO


*
l_0550:
	lea	ALIEN_SWARM_FLAGS,a0                      	| load HL with address of ALIEN_SWARM_FLAGS [ld   hl,0x4100]
	move.b	#0x80,d1                        	| sizeof (ALIEN_SWARM_FLAGS) [ld   b,0x80]
	moveq	#0,d0                            	| [xor  a]
	*move.b	d0,l_6000                       	| clear !DRIVER lamp 1 [ld   (0x6000),a]
	*move.b	d0,l_6001                       	| clear !DRIVER lamp 2 [ld   (0x6001),a]
	jbsr	rst_10	| Clear the alien swarm

	move.b	d0,TIMING_VARIABLE                       	| set TIMING_VARIABLE [ld   (0x425F),a]

	lea	HAS_PLAYER_SPAWNED,a0                      	| pointer to HAS_PLAYER_SPAWNED. Also start of player state [ld   hl,0x4200]
	move.b	#0x17,d1                        	| 0x17 (23 decimal) bytes to clear [ld   b,0x17]
	jbsr	rst_10                               	| Clear all player state
	addq.w	#1,a0                            	| [inc  l]
	move.b	#0x18,d1                        	| [ld   b,0x18]
	jbsr	rst_10                               	| Fill B bytes of memory from HL with value in A.
	lea	ENEMY_BULLETS_START,a0                      	| load HL with address of ENEMY_BULLETS_START [ld   hl,0x4260]
	move.b	#0x46,d1                        	| [ld   b,0x46]
	jbsr	rst_10                               	| Fill B bytes of memory from HL with value in A.
	move.b	#0x01,d0                        	| [ld   a,0x01]
	move.b	d0,HAVE_NO_INFLIGHT_ALIENS                       	| set HAVE_NO_INFLIGHT_ALIENS flag [ld   (0x4226),a]

	addq.b	#1,SCRIPT_STAGE                         	| advance to next stage of script [inc  (hl)]
	move.b	#0x20,TEMP_COUNTER_2                      	| load counter with 0x20 (32 decimal) [ld   (hl),0x20]
	move.w	#0x5000,TEMP_CHAR_RAM_PTR                       	| store in TEMP_CHAR_RAM_PTR [ld   (0x400B),hl]
	rts                                    	| [ret]



CLEAR_ROW_OF_SCREEN:
	move.w	TEMP_CHAR_RAM_PTR,d6                   	| read TEMP_CHAR_RAM_PTR [ld   hl,(0x400B)]
	move.b	#0x20,d1                        	| 0x20 (32 decimal) characters in a row [ld   b,0x20]
	move.b	#0x10,d0                        	| ordinal of empty character [ld   a,0x10]
	jbsr	rst_10_video	| Clear row of characters
	move.w	d6,TEMP_CHAR_RAM_PTR                       	| update TEMP_CHAR_RAM_PTR [ld   (0x400B),hl]
	subq.b	#1,TEMP_COUNTER_2                         	| decrement counter [dec  (hl)]
	beq.b	0f
	rts                                    	| return if not zero [ret  nz]
0:
l_0593:
	addq.b	#1,SCRIPT_STAGE                         	| advance to next stage of script [inc  (hl)]

SET_COLOUR_ATTRIBUTES_TABLE_1:
	lea	COLOUR_ATTRIBUTE_TABLE_1(pc),a0                      	| pointer to COLOUR_ATTRIBUTE_TABLE_1 [ld   hl,0x1D71]

SET_COLOUR_ATTRIBUTES:
	lea	OBJRAM_BACK_BUF+1,a1                      	| address of first attribute in OBJRAM_BACK_BUF [ld   de,0x4021]
	move.b	#0x20,d1                        	| we're setting attributes for all 32 columns in the row [ld   b,0x20]
l_059d:
	move.b	(a0)+,d0                         	| read attribute value from ROM [ld   a,(hl)]
	move.b	d0,(a1)                         	| write to attribute value in OBJRAM_BACK_BUF [ld   (de),a]
												| bump HL to next value in ROM [inc  hl]
	addq.w	#2,a1                            	| Add 2 to DE.. [inc  e]
												| .. so that it points to the next attribute value [inc  e]
	subq.b	#1,d1                           	| [...]
	jne	l_059d                             	| and do until b==0 [djnz 0x059D]
	rts                                    	| [ret]


*
* Player one's turn is about to commence.
*

PLAYER_ONE_INIT:
* restore alien swarm to what it was last turn
	lea	PLAYER_ONE_PACKED_SWARM_DEF,a1                      	| load DE with address of PLAYER_ONE_PACKED_SWARM_DEF [ld   de,0x4180]
	jbsr	UNPACK_ALIEN_SWARM                            	| call UNPACK_ALIEN_SWARM [call 0x0646]
* copy player 1's state (ie: game settings) to current player state
	lea		PLAYER_ONE_STATE,a0							| now HL = pointer to PLAYER_ONE_STATE
	lea	CURRENT_PLAYER_STATE,a1                      	| load DE with address of CURRENT_PLAYER_STATE [ld   de,0x4218
	move.w	#8,d1			| sizeof(CURRENT_PLAYER_STATE)
	jbsr	ldir                                    	| write P1 player state
* reset any game settings
	moveq	#0,d0                            	| [xor  a]
	move.b	d0,TIMING_VARIABLE                       	| set TIMING_VARIABLE [ld   (0x425F),a]
	move.b	d0,HAVE_NO_ALIENS_IN_SWARM                       	| clear HAVE_NO_ALIENS_IN_SWARM flag [ld   (0x4220),a]
	*move.b	d0,l_7006                       	| reset regen hflip [ld   (0x7006),a]
	*move.b	d0,l_7007                       	| reset regen vflip [ld   (0x7007),a]
	move.b	d0,DISPLAY_IS_COCKTAIL_P2                       	| reset DISPLAY_IS_COCKTAIL_P2 [ld   (0x4018),a]
	addq.b	#1,SCRIPT_STAGE                         	| advance to next stage in script [inc  (hl)]
	                            	| bump HL to address of TEMP_COUNTER_2 [dec  l]
	move.b	#0x96,TEMP_COUNTER_2                      	| set counter value [ld   (hl),0x96]
	move.b	#0x40,FLAGSHIP_ATTACK_MASTER_COUNTER_1
	move.b	#0x06,FLAGSHIP_ATTACK_MASTER_COUNTER_2		| set FLAGSHIP_ATTACK_MASTER_COUNTER_1 and FLAGSHIP_ATTACK_MASTER_COUNTER_2 [ld   (0x4245),hl]
* if its not demo mode, display the scores
	move.b	IS_GAME_IN_PLAY,d0                       	| read IS_GAME_IN_PLAY [ld   a,(0x4006)]
	ror.b	#1,d0                            	| move flag into carry [rrca]
	bcs.b	0f
	rts                                    	| return if game is not in play [ret  nc]
0:
	tst.b	IS_TWO_PLAYER_GAME                       	| read IS_TWO_PLAYER_GAME [ld   a,(0x400E)]
	jne	l_05fc                             	| if carry is set, we're in a 2 player game, goto 0x05FC [jr   c,0x05FC]
* the next 2 lines are only executed if its a one player game
	move.w	#0x500,d3                      	| command: DISPLAY_SCORE_COMMAND, parameter: 0  (Displays Player 1's score) [ld   de,0x0500]
	jbsr	QUEUE_COMMAND                            	| call QUEUE_COMMAND [call 0x08F2]
* the remaining lines are executed regardless of number of players
l_05e2:
	move.b	#2,d3								| command: DISPLAY_SCORE_COMMAND, parameter: 2  (invokes DISPLAY_HIGH_SCORE)
	jbsr	QUEUE_COMMAND                            	| call QUEUE_COMMAND [call 0x08F2]
	move.w	#0x602,d3                            	| command: PRINT_TEXT, parameter: 2 (index of "PLAYER ONE") [inc  d]
	jbsr	QUEUE_COMMAND                            	| call QUEUE_COMMAND [call 0x08F2]
	move.b	#4,d3						| command: PRINT_TEXT, parameter: 4 (index of "HIGH SCORE")
	jbsr	QUEUE_COMMAND                            	| call QUEUE_COMMAND [call 0x08F2]
	move.w	#0x703,d3                      	| command: DISPLAY_BOTTOM_OF_SCREEN_COMMAND, calls DISPLAY_PLAYER_SHIPS_REMAINING [ld   de,0x0703]
	jbsr	QUEUE_COMMAND                            	| call QUEUE_COMMAND [call 0x08F2]
	move.w	#0x700,d3                      	| command: DISPLAY_BOTTOM_OF_SCREEN_COMMAND, calls DISPLAY_LEVEL_FLAGS [ld   de,0x0700]
	jra	QUEUE_COMMAND                             	| jump to QUEUE COMMAND [jp   0x08F2]

* Called when we're in a two player game. Displays player one's score, player two's score and high score.
l_05fc:
	move.w	#0x503,d3                      	| command: DISPLAY_SCORE_COMMAND, parameter: 3 (invokes DISPLAY_ALL_SCORES) [ld   de,0x0503]
	jbsr	QUEUE_COMMAND                            	| call QUEUE_COMMAND [call 0x08F2]
	jra	l_05e2                             	| go display high score, ships remaining [jp   0x05E2]


*
*
* Remove the text "PLAYER ONE" / "PLAYER TWO" from the screen.
*
*

CLEAR_PLAYER_TEXT:
	lea	TEMP_COUNTER_2,a0                      	| load HL with address of TEMP_COUNTER_2 [ld   hl,0x4009]
	subq.b	#1,(a0)                         	| [dec  (hl)]
	beq.b	0f
	rts                                    	| [ret  nz]
0:
	move.b	#0x14,(a0)                      	| [ld   (hl),0x14]
	addq.b	#1,SCRIPT_STAGE                         	| advance to next stage of script [inc  (hl)]
* the text "PLAYER ONE" and "PLAYER TWO" are plotted to the same character cells
	move.w	#0x0682,d3                      	| command: PRINT_TEXT, parameter: #0x82 - clear "PLAYER ONE" from screen [ld   de,0x0682]
	jra	QUEUE_COMMAND                             	| jump to QUEUE COMMAND [jp   0x08F2]




HANDLE_SPAWN_PLAYER:
* Wait until its time to spawn the player
	lea	TEMP_COUNTER_2,a0                      	| load HL with address of TEMP_COUNTER_2 [ld   hl,0x4009]
	subq.b	#1,(a0)                         	| [dec  (hl)]
	beq.b	0f
	rts                                    	| [ret  nz]
0:
	move.b	#0x0A,(a0)                      	| reset TEMP_COUNTER_2 [ld   (hl),0x0A]
	addq.b	#1,SCRIPT_STAGE                         	| advance to next stage of script [inc  (hl)]

* Spawn the player
	
	clr.b	IS_PLAYER_DYING
	move.b	#1,HAS_PLAYER_SPAWNED	| set HAS_PLAYER_SPAWNED to 1, IS_PLAYER_DYING to 0 [ld   (0x4200),hl]
	move.b	#0x80,d0                        	| [ld   a,0x80]
	move.b	d0,PLAYER_Y                       	| set PLAYER_Y [ld   (0x4202),a]

	lea	ALIEN_ATTACK_COUNTER_DEFAULT_VALUES(pc),a0                      	| load HL with address of ALIEN_ATTACK_COUNTER_DEFAULT_VALUES [ld   hl,0x15E3]
	lea	ALIEN_ATTACK_COUNTERS,a1                      	| load DE with address of ALIEN_ATTACK_COUNTERS [ld   de,0x424A]
	move.w	#0x10,d1		| sizeof(ALIEN_ATTACK_COUNTERS) array
	jbsr	ldir                                    	| reset all counters to their default values

	moveq	#0,d0                            	| [xor  a]
	move.b	d0,OBJRAM_BACK_BUF+0x38                       	| reset scroll offset in OBJRAM_BACK_BUF [ld   (0x4058),a]
	move.b	d0,OBJRAM_BACK_BUF+0x3A                       	| reset scroll offset in OBJRAM_BACK_BUF [ld   (0x405A),a]

* Draw lives left
	move.w	#0x703,d3                      	| command: DISPLAY_BOTTOM_OF_SCREEN_COMMAND, calls DISPLAY_PLAYER_SHIPS_REMAINING [ld   de,0x0703]
	jbsr	QUEUE_COMMAND                            	| call QUEUE_COMMAND [call 0x08F2]
	move.w	#0x200,d3                      	| command: DISPLAY_PLAYER_COMMAND, parameter: 0 (invokes DRAW_PLAYER_SHIP) [ld   de,0x0200]
	jra	QUEUE_COMMAND                             	| jump to QUEUE COMMAND [jp   0x08F2]


HANDLE_MAIN_GAME_LOGIC:
	jbsr	HANDLE_PLAYER_MOVE
	jbsr	HANDLE_PLAYER_BULLET
	jbsr	HANDLE_ENEMY_BULLETS
	jbsr	HANDLE_INFLIGHT_ALIENS
	jbsr	HANDLE_INFLIGHT_ALIEN_SPRITE_UPDATE
	jbsr	HANDLE_PLAYER_SHOOT
	jbsr	HANDLE_SWARM_ALIEN_TO_PLAYER_BULLET_COLLISION_DETECTION
	jbsr	HANDLE_PLAYER_TO_ENEMY_BULLET_COLLISION_DETECTION
	jbsr	HANDLE_INFLIGHT_ALIEN_TO_PLAYER_BULLET_COLLISION_DETECTION
	jbsr	HANDLE_PLAYER_TO_INFLIGHT_ALIEN_COLLISION_DETECTION
	jbsr	HANDLE_PLAYER_BULLET_EXPIRED
	jbsr	HANDLE_FLAGSHIP_ATTACK
	jbsr	HANDLE_SINGLE_ALIEN_ATTACK
	jbsr	SET_ALIEN_ATTACK_FLANK
	jbsr	HANDLE_LEVEL_DIFFICULTY
	jbsr	HANDLE_PLAYER_HIT
	jbsr	HANDLE_PLAYER_DYING
	jbsr	CHECK_IF_ALIEN_CAN_ATTACK
	jbsr	UPDATE_ATTACK_COUNTERS
	jbsr	CHECK_IF_FLAGSHIP_CAN_ATTACK
	jbsr	HANDLE_CALC_INFLIGHT_ALIEN_SHOOTING_DISTANCE
	jbsr	CHECK_IF_LEVEL_IS_COMPLETE
	jbsr	HANDLE_LEVEL_COMPLETE
	jbsr	HANDLE_ALIEN_AGGRESSIVENESS
	jbsr	HANDLE_SHOCKED_SWARM
	jbsr	HANDLE_SIMULATE_PLAYER_IN_ATTRACT_MODE

* OK, this part of the main game loop determines under what circumstances we can end the level.
* First we check the status of the player and the player bullet. Are they visible?
	move.b	HAS_PLAYER_BULLET_BEEN_FIRED,d0                       	| read HAS_PLAYER_BULLET_BEEN_FIRED flag [ld   a,(0x4208)]
	or.b	HAS_PLAYER_SPAWNED,d0                   	| read both HAS_PLAYER_SPAWNED and IS_PLAYER_DYING flags in one go [ld   hl,(0x4200)]
	or.b	IS_PLAYER_DYING,d0                   	| read both HAS_PLAYER_SPAWNED and IS_PLAYER_DYING flags in one go [ld   hl,(0x4200)]
														| combine all three flags.. [or   h]
														| into 1. If any of the three is set, A will be 1 [or   l]
														| Test if A was set to 1. [rrca]
	beq.b	0f
	rts                                    	| Return if player bullet has been fired, or player has spawned or is dying [ret  c]
0:

* Wait until all aliens are dead.
	move.b	HAVE_NO_INFLIGHT_OR_DYING_ALIENS,d0                       	| read HAVE_NO_INFLIGHT_OR_DYING_ALIENS [ld   a,(0x4225)]
	ror.b	#1,d0                            	| move flag value into carry. [rrca]
	bcs.b	0f
	rts                                    	| if carry flag is not set, then that means there are still aliens attacking or going through a death animation [ret  nc]
0:

* wait until all enemy bullets are off screen.
	lea	ENEMY_BULLETS_START,a0                      	| load HL with address of ENEMY_BULLETS_START [ld   hl,0x4260]
	move.b	#0x0E,d1                        	| #0x0E (14 decimal) bullets max to process [ld   b,0x0E]
	moveq	#0,d0                            	| clear A [xor  a]
l_06ca:
	or.b	(a0),d0                           	| read ENEMY_BULLET.IsActive flag. set A to 1 if bullet is active. [or   (hl)]
	addq.w	#5,a0
	subq.b	#1,d1                           	| [...]
	jne	l_06ca                             	| repeat until B==0 [djnz 0x06CA]
	ror.b	#1,d0                            	| are there any bullets still active on screen? If so, carry will be set [rrca]
	bcc.b	0f
	rts                                    	| yes, bullets still active, return [ret  c]
0:

* OK, when we get here, the level is complete. We can go to the next level.
	subq.b	#1,TEMP_COUNTER_2                         	| [dec  (hl)]
	beq.b	0f
	rts                                    	| [ret  nz]
0:
	                            | bump HL to point to address of SCRIPT_STAGE [inc  l]
	addq.b	#1,SCRIPT_STAGE                         	| advance to next stage of script [inc  (hl)]
	rts                                    	| [ret]



*
* Player 1 has just been killed.
*
* See also: 0x07E8

HANDLE_PLAYER_ONE_KILLED:
	lea	SCRIPT_STAGE,a0                      	| load HL with pointer to SCRIPT_STAGE [ld   hl,0x400A]

	move.b	PLAYER_LIVES,d0                       	| read PLAYER_LIVES [ld   a,(0x421D)]
	tst.b	d0                               	| test if zero [and  a]
	jne	l_0701                             	| if player 1 has lives remaining, goto 0x0701 [jr   nz,0x0701]

* OK, player 1 has no lives. What about player 2?
	move.b	PLAYER_TWO_LIVES,d0                       	| read PLAYER_TWO_LIVES [ld   a,(0x41B5)]
	tst.b	d0                               	| test if zero [and  a]
	jeq	l_0722                             	| if player 2 has no lives, goto GAME_OVER [jr   z,0x0722]

* player 1 has no lives. If its not a 2 player game, then its GAME OVER.
	move.b	IS_TWO_PLAYER_GAME,d0                       	| read IS_TWO_PLAYER_GAME [ld   a,(0x400E)]
	tst.b	d0                               	| test if zero [and  a]
	jeq	l_0722                             	| if zero, it's not a 2 player game, goto GAME_OVER [jr   z,0x0722]

* OK, its a 2 player game and player 2 has some lives.
	addq.b	#1,(a0)                         	| bump to next stage of the script [inc  (hl)]
	move.b	#0x82,TEMP_COUNTER_2                      	| set counter [ld   (hl),0x82]

	move.b	IS_GAME_IN_PLAY,d0                       	| read IS_GAME_IN_PLAY [ld   a,(0x4006)]
	ror.b	#1,d0                            	| move flag into carry [rrca]
	bcs.b	0f
	rts                                    	| return if game is not in play [ret  nc]
0:

* Display PLAYER ONE GAME OVER
	move.w	#0x0602,d3                      	| command: PRINT_TEXT, parameter: 2 (index of "PLAYER ONE") [ld   de,0x0602]
	jbsr	QUEUE_COMMAND                            	| call QUEUE_COMMAND [call 0x08F2]
	move.w	#0x0600,d3                             	| index of "GAME OVER"
	jra	QUEUE_COMMAND                             	| jump to QUEUE COMMAND [jp   0x08F2]

* Player one's been killed. Is it player two's turn now?
l_0701:
	move.b	PLAYER_TWO_LIVES,d0                       	| read PLAYER_TWO_LIVES [ld   a,(0x41B5)]
	tst.b	d0                               	| test if zero [and  a]
	jeq	l_0712                             	| [jr   z,0x0712]
	move.b	IS_TWO_PLAYER_GAME,d0                       	| read IS_TWO_PLAYER_GAME [ld   a,(0x400E)]
	tst.b	d0                               	| test if flag is set [and  a]
	jeq	l_0712                             	| if its not a two player game goto 0x0712 [jr   z,0x0712]
l_070d:
	addq.b	#1,(a0)                         	| bump to next stage of the script [inc  (hl)]
l_070e:
	move.b	#0x50,TEMP_COUNTER_2                      	| set counter [ld   (hl),0x50]
	rts                                    	| [ret]

* If we get here, either its a single player game or player two has lost all their lives.
l_0712:
	move.b	IS_GAME_IN_PLAY,d0                       	| read IS_GAME_IN_PLAY [ld   a,(0x4006)]
	ror.b	#1,d0                            	| move bit 0 into carry [rrca]
	jcc	l_071d                             	| if carry is not set, game is not in play, goto 0x071D [jr   nc,0x071D]
	move.b	#0x04,(a0)                      	| set SCRIPT_STAGE to 4 [ld   (hl),0x04]
	jra	l_070e                             	| [jp   0x070E]

l_071d:
	move.b	#0x0E,(a0)                      	|set SCRIPT_STAGE to 0x0E (14 decimal) [ld   (hl),0x0E]
	jra	l_070e                             	| [jp   0x070E]


*
* Player 1 and player 2 have used up all their lives.
*

GAME_OVER:
l_0722:
	move.b	IS_GAME_IN_PLAY,d0                       	| read IS_GAME_IN_PLAY [ld   a,(0x4006)]
	ror.b	#1,d0                            	| move bit 0 into carry [rrca]
	jcc	l_070d                             	| if carry is not set, game is not in play, goto 0x070D [jr   nc,0x070D]
	move.b	#0x01,d0                        	| [ld   a,0x01]
	move.b	d0,SCRIPT_NUMBER                       	| set SCRIPT_NUMBER to 1 [ld   (0x4005),a]
	moveq	#0,d0                            	| [xor  a]
	move.b	d0,IS_GAME_IN_PLAY                       	| clear IS_GAME_IN_PLAY [ld   (0x4006),a]
	move.b	d0,SCRIPT_STAGE                       	| clear SCRIPT_STAGE [ld   (0x400A),a]
	jbsr	RESET_SOUND                            	| call RESET_SOUND [call 0x1CB5]
	move.w	#0x600,d3                      	| command: PRINT_TEXT, parameter: 0 (index of "GAME OVER") [ld   de,0x0600]
	jra	QUEUE_COMMAND                             	| jump to QUEUE COMMAND [jp   0x08F2]



*
* Player one has died. It's player two's turn now.
*

SWITCH_TO_PLAYER_TWO:
	lea	TEMP_COUNTER_2,a0                      	| load HL with address of TEMP_COUNTER_2 [ld   hl,0x4009]
	subq.b	#1,(a0)                         	| decrement counter [dec  (hl)]
	beq.b	0f
	rts                                    	| return if count !=0 [ret  nz]
0:
	clr.b	SCRIPT_STAGE                         	| [ld   (hl),a]
	clr.b	LEVEL_COMPLETE                       	| reset LEVEL_COMPLETE flag [ld   (0x4222),a]
	clr.b	IS_FLAGSHIP_HIT                       	| reset IS_FLAGSHIP_HIT flag [ld   (0x422B),a]

* preserve state of the swarm so that it can,0xbe restored for player one's next turn.
	lea	PLAYER_ONE_PACKED_SWARM_DEF,a1                      	| load DE with pointer to PLAYER_ONE_PACKED_SWARM_DEF [ld   de,0x4180]
	jbsr	PACK_ALIEN_SWARM                            	| call PACK_ALIEN_SWARM [call 0x0764]

* save rest of player state so it can be restored too.
	lea	PLAYER_ONE_STATE,a1			| jotd: added for clarity
	lea	CURRENT_PLAYER_STATE,a0                      	| load HL with address of CURRENT_PLAYER_STATE [ld   hl,0x4218]
	move.w	#8,d1
	jbsr	ldir                                    	| update player one's state

* OK, now execute script to handle player two.
	move.b	#0x01,CURRENT_PLAYER                  	| set CURRENT_PLAYER to 1 (Player TWO) [ld   (0x400D),a]
	move.b	#0x04,SCRIPT_NUMBER           	| set SCRIPT_NUMBER to 4 [ld   (0x4005),a]
	rts                                    	| [ret]


*
* Packs the 128 byte array that defines the alien swarm into a,0x16 byte buffer.
*
* This is used when a player dies and the game has to persist (ie: remember) the current state of the alien swarm
* before the other player's turn starts.
*
* See also UNPACK_ALIEN_SWARM which unpacks the,0x16 byte buffer back into ALIEN_SWARM_FLAGS.
*
*
* Expects:
*,0xDE = pointer to,0x16 byte buffer.
*

PACK_ALIEN_SWARM:
	lea	ALIEN_SWARM_FLAGS,a0                      	| load HL with address of ALIEN_SWARM_FLAGS [ld   hl,0x4100]
	move.b	#0x10,d1                        	| buffer is 0x10 (16 decimal) bytes in length [ld   b,0x10]
	move.b	#0x01,d2                        	| [ld   c,0x01]
l_076b:
	moveq	#0,d0                            	| [xor  a]
l_076c:
	btst.b	#0,(a0)                         	| [bit  0,(hl)]
	jeq	l_0771                             	| [jr   z,0x0771]
	or.b	d2,d0                             	| [or   c]
l_0771:
	addq.w	#1,a0                           	| [inc  hl]
	rol.b	#1,d2                            	| [rlc  c]
	jcc	l_076c                             	| [jr   nc,0x076C]
	move.b	d0,(a1)                         	| [ld   (de),a]
	addq.w	#1,a1                           	| [inc  de]
	subq.b	#1,d1                           	| [...]
	jne	l_076b                             	| [djnz 0x076B]
	rts                                    	| [ret]



*
* This script is responsible for managing PLAYER 2's game.
*
*
*

SCRIPT_FOUR:
	jbsr	HANDLE_SWARM_MOVEMENT                            	| call HANDLE_SWARM_MOVEMENT [call 0x090D]
	jbsr	SET_ALIEN_PRESENCE_FLAGS                            	| call SET_ALIEN_PRESENCE_FLAGS [call 0x098E]
	moveq	#0,d0
	move.b	SCRIPT_STAGE,d0                       	| [ld   a,(0x400A)]
	add.w	d0,d0
	add.w	d0,d0
	lea		l_0785(pc),a0		
	move.l	(a0,d0.w),a0		| jump to code @ 0x0785 + (A*2)
	jmp		(a0)

l_0785:
	.long	l_0550
	.long	CLEAR_ROW_OF_SCREEN
	.long	PLAYER_TWO_INIT
	.long	CLEAR_PLAYER_TEXT
	.long	HANDLE_SPAWN_PLAYER
	.long	HANDLE_MAIN_GAME_LOGIC
	.long	HANDLE_PLAYER_TWO_KILLED
	.long	SWITCH_TO_PLAYER_ONE


*
* Player two's turn is about to commence.
*


PLAYER_TWO_INIT:
* restore alien swarm to what it was last turn
	lea	PLAYER_TWO_PACKED_SWARM_DEF,a1                      	| address of PLAYER_TWO_PACKED_SWARM_DEF [ld   de,0x41A0]
	jbsr	UNPACK_ALIEN_SWARM                            	| call UNPACK_ALIEN_SWARM [call 0x0646]
* copy player two's state (ie: game settings) to current player state
	lea  PLAYER_TWO_STATE,a0			| now HL = pointer to PLAYER_TWO_STATE
	lea	CURRENT_PLAYER_STATE,a1                      	| load DE with address of CURRENT_PLAYER_STATE [ld   de,0x4218]
	move.w	#8,d1
	jbsr		ldir                                    	| move player 2's state to CURRENT_PLAYER_STATE

* reset any game settings
	moveq	#0,d0                            	| [xor  a]
	move.b	d0,TIMING_VARIABLE                       	| set TIMING_VARIABLE [ld   (0x425F),a]
	move.b	d0,HAVE_NO_ALIENS_IN_SWARM                       	| clear HAVE_NO_ALIENS_IN_SWARM flag. [ld   (0x4220),a]

* if the cabinet is cocktail, flip the screen for player two
	move.b	IS_COCKTAIL,d0                       	| read IS_COCKTAIL [ld   a,(0x400F)]
	tst.b	d0                               	| test if its zero (meaning UPRIGHT) [and  a]
	jeq	l_07ba                             	| if its upright, goto 0x07BA [jr   z,0x07BA]
	move.b	d0,DISPLAY_IS_COCKTAIL_P2                       	| set DISPLAY_IS_COCKTAIL_P2 to true [ld   (0x4018),a]
	*move.b	d0,l_7006                       	| enable "regen hflip" which hardware flips the screen horizontally [ld   (0x7006),a]
	*move.b	d0,l_7007                       	| enable "regen vflip" which hardware flips the screen vertically [ld   (0x7007),a]

l_07ba:
	lea	SCRIPT_STAGE,a0                      	| load HL with address of SCRIPT_STAGE [ld   hl,0x400A]
	addq.b	#1,(a0)                         	| advance to next stage [inc  (hl)]
	move.b	#0x96,TEMP_COUNTER_2                      	| set counter [ld   (hl),0x96]
	move.b	#0x30,FLAGSHIP_ATTACK_MASTER_COUNTER_1
	move.b	#8,FLAGSHIP_ATTACK_MASTER_COUNTER_2		| set FLAGSHIP_ATTACK_MASTER_COUNTER_1 and FLAGSHIP_ATTACK_MASTER_COUNTER_2 [ld   (0x4245),hl]

* if its not demo mode, display the scores
	move.b	IS_GAME_IN_PLAY,d0                       	| read IS_GAME_IN_PLAY [ld   a,(0x4006)]
	ror.b	#1,d0                            	| move bit 0 into carry [rrca]
	bcs.b	0f
	rts                                    	| return if game is not in play [ret  nc]
0:
	move.w	#0x0503,d3                      	| command: DISPLAY_SCORE_COMMAND, parameter: 3 (invokes DISPLAY_ALL_SCORES) [ld   de,0x0503]
	jbsr	QUEUE_COMMAND                            	| call QUEUE_COMMAND [call 0x08F2]
	move.w	#0x0603,d3                      	| command: PRINT_TEXT, parameter: 3 (index of "PLAYER TWO") [ld   de,0x0603]
	jbsr	QUEUE_COMMAND                            	| call QUEUE_COMMAND [call 0x08F2]
	addq.b	#1,d3                            	| index of "HIGH SCORE" [inc  e]
	jbsr	QUEUE_COMMAND                            	| call QUEUE_COMMAND [call 0x08F2]
	move.w	#0x0703,d3                      	| command: DISPLAY_BOTTOM_OF_SCREEN_COMMAND, parameter: 3 (invokes DISPLAY_PLAYER_SHIPS_REMAINING) [ld   de,0x0703]
	jbsr	QUEUE_COMMAND                            	| call QUEUE_COMMAND [call 0x08F2]
	move.w	#0x0700,d3                      	| command: DISPLAY_BOTTOM_OF_SCREEN_COMMAND, parameter: 0 (invokes DISPLAY_LEVEL_FLAGS) [ld   de,0x0700]
	jra	QUEUE_COMMAND                             	| jump to QUEUE COMMAND [jp   0x08F2]


*
* Player 2 has just been killed.
*
* See also: 0x06D8 (HANDLE_PLAYER_ONE_KILLED)
*

HANDLE_PLAYER_TWO_KILLED:
	lea	SCRIPT_STAGE,a0                      	| load HL with address of SCRIPT_STAGE [ld   hl,0x400A]
	move.b	PLAYER_LIVES,d0                       	| read PLAYER_LIVES [ld   a,(0x421D)]
	tst.b	d0                               	| test if zero [and  a]
	jne	l_080c                             	| if player 2 has lives remaining, goto 0x080C [jr   nz,0x080C]

* OK, player 1 has no lives. What about player 1?
	move.b	PLAYER_ONE_LIVES,d0                       	| read PLAYER_ONE_LIVES [ld   a,(0x4195)]
	tst.b	d0                               	| test if zero [and  a]
	jeq	l_0722                             	| if player one is out of lives then that means GAME OVER for both players, goto 0x0722 [jp   z,0x0722]

* player 1 has some lives left
	addq.b	#1,SCRIPT_STAGE                         	| increment SCRIPT_STAGE [inc  (hl)]
	move.b	#0x82,TEMP_COUNTER_2                      	| set value of counter [ld   (hl),0x82]

* are we in demo mode?
	move.b	IS_GAME_IN_PLAY,d0                       	| read IS_GAME_IN_PLAY flag [ld   a,(0x4006)]
	ror.b	#1,d0                            	| move flag into carry [rrca]
	bcs.b	0f
	rts                                    	| return if game is not in play [ret  nc]
0:

* Display PLAYER TWO GAME OVER
	move.w	#0x603,d3                      	| command: PRINT_TEXT, parameter: 3 (index of "PLAYER TWO") [ld   de,0x0603]
	jbsr	QUEUE_COMMAND                            	| call QUEUE_COMMAND [call 0x08F2]
	clr.b	d3			| index of text string "GAME OVER"
	jra	QUEUE_COMMAND                             	| jump to QUEUE COMMAND [jp   0x08F2]

* Player two's been killed. Is it player one's turn now?
l_080c:
	move.b	PLAYER_ONE_LIVES,d0                       	| read PLAYER_ONE_LIVES [ld   a,(0x4195)]
	tst.b	d0                               	| test if zero [and  a]
	jeq	l_0712                             	| if zero, goto 0x0712 [jp   z,0x0712]
	addq.b	#1,SCRIPT_STAGE                         	| increment SCRIPT_STAGE [inc  (hl)]
	move.b	#0x50,TEMP_COUNTER_2                      	| [ld   (hl),0x50]
	rts                                    	| [ret]


*
*
* Called when player two has died and it's now player one's turn.
*
*

SWITCH_TO_PLAYER_ONE:
	lea	TEMP_COUNTER_2,a0                      	| load HL with address of TEMP_COUNTER_2 [ld   hl,0x4009]
	subq.b	#1,(a0)                         	| [dec  (hl)]
	beq.b	0f
	rts                                    	| [ret  nz]
0:

	clr.b	SCRIPT_STAGE                         	| set SCRIPT_STAGE to 0 [ld   (hl),a]

	clr.b	CURRENT_PLAYER                       	| set CURRENT_PLAYER to 0 (player one) [ld   (0x400D),a]
	move.b	#0x03,SCRIPT_NUMBER             	| set SCRIPT_NUMBER [ld   (0x4005),a]

* preserve state of the swarm so that it can,0xbe restored for player two's next turn.
	lea	PLAYER_TWO_PACKED_SWARM_DEF,a1                      	| Address of PLAYER_TWO_PACKED_SWARM_DEF [ld   de,0x41A0]
	jbsr	PACK_ALIEN_SWARM                            	| call PACK_ALIEN_SWARM to convert the swarm into bit flags and write to DE [call 0x0764]

* save rest of player state so it can,0xbe restored too.
	lea	CURRENT_PLAYER_STATE,a0                      	| load HL with address of CURRENT_PLAYER_STATE [ld   hl,0x4218]
	move.w	#8,d1
	jbra	ldir                                    	| preserve player two's state



*
* Read player joystick/ movement controls and move player ship accordingly.
* As stated in DISPLAY_PLAYER_COMMAND (0x215F), the player ship isn't a sprite, its 4x4 characters.
* When you move the ship, the columns containing the ship are scrolled.
*
* See also:
* HANDLE_PLAYER_SHOOT.
*

HANDLE_PLAYER_MOVE:
	tst.b	HAS_PLAYER_SPAWNED        	| has player spawned? [bit  0,(hl)]
	jeq	SPAWN_PLAYER_OR_DIE                             	| no, goto SPAWN_PLAYER_OR_DIE [jr   z,0x0877]
	lea	PLAYER_Y,a0                  	| now HL points to PLAYER_Y [inc  l]

* are we in demo mode?
	tst.b	IS_GAME_IN_PLAY                       	| read IS_GAME_IN_PLAY [ld   a,(0x4006)]
	jeq	l_0892                             	| carry not set, game is not in play, goto 0x0892 to simulate moving player ship in attract mode [jp   nc,0x0892]
	move.b	DISPLAY_IS_COCKTAIL_P2,d0                       	| read DISPLAY_IS_COCKTAIL_P2 flag [ld   a,(0x4018)]
	ror.b	#1,d0                            	| move bit 0 into carry [rrca]
	jcs	l_088c                             	| if carry is set, we're in cocktail mode and it's player 2 in control. Goto 0x088C [jr   c,0x088C]

* read movement controls
	move.b	PORT_STATE_6000,d0                       	| read PORT_STATE_6000 [ld   a,(0x4010)]
l_0850:
	move.b	d0,d1                           	| save a copy in B [ld   b,a]
	btst.b	#3,d0                           	| has MOVE RIGHT been pushed? [bit  3,a]
	jeq	TEST_JOYSTICK_PUSHED_LEFT                             	| no, goto TEST_JOYSTICK_PUSHED_LEFT [jr   z,0x085B]

* player pushed stick right
	move.b	(a0),d0                         	| load PLAYER_Y into A [ld   a,(hl)]
	cmp.b	#0x17,d0                         	| compare to #0x17 (23 decimal) [cp   0x17]
	jcs	TEST_JOYSTICK_PUSHED_LEFT                             	| if A < #0x17 then player is at far right screen edge and can go no further, goto 0x085B [jr   c,0x085B]
	subq.b	#1,(a0)                         	| decrement PLAYER_Y (moving ship RIGHT: remember, the monitor is flipped 90 degrees) [dec  (hl)]

TEST_JOYSTICK_PUSHED_LEFT:
	btst.b	#2,d1                           	| has MOVE LEFT been pushed? [bit  2,b]
	jeq	l_0865                             	| No, goto 0x0865 [jr   z,0x0865]

* player pushed stick left
	move.b	(a0),d0                         	| get Y coordinate of player ship into A [ld   a,(hl)]
	cmp.b	#0xE9,d0                         	| compare to #0xE9 (233 decimal) [cp   0xE9]
	jcc	l_0865                             	| if A>= #0xE9 then player is at far left screen edge and can go no further, goto 0x0865 [jr   nc,0x0865]
	addq.b	#1,(a0)                         	| increment PLAYER_Y (moving ship LEFT) [inc  (hl)]

* set scroll value for columns containing the player ship characters
SET_PLAYER_SHIP_SCROLL_OFFSET:
l_0865:
	move.b	(a0),d0                         	| get ship Y coordinate into A [ld   a,(hl)]
	not.b	d0                               	| flip the bits [cpl]
	add.b	#0x80,d0                         	| add an offset. Now we have a scroll value in A. [add  a,0x80]
	move.b	#0x06,d2                        	| set colour of player ship [ld   c,0x06]
l_086b:
	lea	OBJRAM_BACK_BUF+0x34,a0                      	| set hl to point to first column containing player ship pseudosprite. [ld   hl,0x4054]

* the players ship is 2x2 characters when alive, 4x4 when its exploding. We need to set the scroll offset for the 4 columns.
	move.b	#0x04,d1                        	| we're doing 4 columns [ld   b,0x04]
l_0870:
	move.b	d0,(a0)+                         	| write scroll offset to OBJRAM_BACK_BUF (see docs @top) [ld   (hl),a]
	                            	| bump pointer to colour value for column [inc  l]
	move.b	d2,(a0)+                         	| write colour to OBJRAM_BACK_BUF (see docs @ top) [ld   (hl),c]
	                            	| bump pointer to scroll offset value for column [inc  l]
	subq.b	#1,d1                           	| [...]
	jne	l_0870                             	| do until b==0 [djnz 0x0870]
	rts                                    	| [ret]

* if we get here, then either the player hasn't spawned, or the player is hit.
SPAWN_PLAYER_OR_DIE:
	tst.b	IS_PLAYER_DYING                         	| test flag [bit  0,(hl)]
	jne	PLAYER_EXPLOSION_INIT                             	| if flag is set, player will die, goto PLAYER_EXPLOSION_INIT [jr   nz,0x0882]

* spawn player
	lea		PLAYER_Y,a0                            	| otherwise, point HL to PLAYER_Y [inc  l]
	clr.b	(a0)                             	| set value of PLAYER_Y to 0 [ld   (hl),0x00]
	jra	l_0865                             	| and set the scroll for the player ship [jp   0x0865]

* if we get here, the player is about to explode.
PLAYER_EXPLOSION_INIT:
	lea		PLAYER_Y,a0                            	| point HL to PLAYER_Y [inc  l]
	move.b	(a0),d0                         	| read value of PLAYER_Y [ld   a,(hl)]
	not.b	d0                               	| [cpl]
	add.b	#0x80,d0                         	| add an offset. Now we have a scroll value in A. [add  a,0x80]
	move.b	#0x07,d2                        	| colour value (see 0x0872) [ld   c,0x07]
	jra	l_086b                             	| and set the scroll offsets and colour values for the exploding ship [jp   0x086B]


l_088c:
	move.b	PORT_STATE_6800,d0                       	| read PORT_STATE_6800 [ld   a,(0x4011)]
	jra	l_0850                             	| now test player 2's movement stick [jp   0x0850]

* In ATTRACT MODE, this piece of code supplies faked joystick movements and FIRE button presses to the player move logic.
* The player spaceship looks like someone is controlling it.
l_0892:
	move.b	ATTRACT_MODE_FAKE_CONTROLLER,d0                       	| read bit flags from ATTRACT_MODE_FAKE_CONTROLLER. [ld   a,(0x423F)]
	jra	l_0850                             	| [jp   0x0850]




*
* This routine is responsible for moving the player bullet, and positioning the player bullet sprite.
*
*

HANDLE_PLAYER_BULLET:
	jbsr	POSITION_PLAYER_BULLET                            	| call POSITION_PLAYER_BULLET [call 0x08BC]
	move.b	PLAYER_BULLET_X,d6
	move.b	PLAYER_BULLET_Y,d5         	| load value of PLAYER_BULLET_Y  into H, PLAYER_BULLET_X into L [ld   hl,(0x4209)]

* This code updates the bullet sprite state in the OBJRAM back buffer.
	move.b	d6,d0                           	| load A with PLAYER_BULLET_X [ld   a,l]
	not.b	d0                               	| [cpl]
	sub.b	#4,d0                            	| subtract 4 [add  a,-4]
	move.b	d0,OBJRAM_BUF_PLAYER_BULLET_X                       	| update OBJRAM_BUF_PLAYER_BULLET_X [ld   (0x409F),a]
	move.b	d5,d0                           	| load A with PLAYER_BULLET_Y [ld   a,h]
	not.b	d0                               	| [cpl]
	move.b	d0,OBJRAM_BUF_PLAYER_BULLET_Y                       	| update OBJRAM_BUF_PLAYER_BULLET_Y [ld   (0x409D),a]
	rts                                    	| [ret]


*
* If the player bullet has not been fired, position it just above the player ship.
*
* Otherwise, move player bullet upscreen. When bullet reaches its limit, set IS_PLAYER_BULLET_DONE flag to 1.
*

POSITION_PLAYER_BULLET:
	lea	  PLAYER_BULLET_X,a0                         	| HL now points to PLAYER_BULLET_X [inc  hl]
	tst.b	HAS_PLAYER_BULLET_BEEN_FIRED                      	| pointer to HAS_PLAYER_BULLET_BEEN_FIRED flag [ld   hl,0x4208]
												| test if flag is set [bit  0,(hl)]
	jeq	POSITION_PLAYER_BULLET_ABOVE_SHIP                             	| if player has not fired, goto POSITION_PLAYER_BULLET_ABOVE_SHIP [jr   z,0x08D3]

* player bullet has been fired. Subtract 4 from its X coordinate and check if its gone off screen.
	move.b	(a0),d0                         	| get X coordinate of bullet [ld   a,(hl)]
	subq.b	#0x04,d0                        	| subtract 4, moving bullet UP the screen [sub  0x04]
	move.b	d0,(a0)                         	| update X coordinate of bullet [ld   (hl),a]
	sub.b	#0x0E,d0                         	| [sub  0x0E]
	subq.b	#0x04,d0                        	| subtract 18 (decimal) total from X coordinate [sub  0x04]
	bcs.b	0f
	rts                                    	| if there's no carry, then the players bullet has not reached its limit [ret  nc]
0:

* player bullet has gone offscreen
	move.b	#0x01,IS_PLAYER_BULLET_DONE                       	| set IS_PLAYER_BULLET_DONE flag [ld   (0x420B),a]
	rts                                    	| [ret]

* the player bullet isn't fired, so place it above the player ship.
POSITION_PLAYER_BULLET_ABOVE_SHIP:
	move.b	#0xDC,(a0)                      	| set PLAYER_BULLET_X [ld   (hl),0xDC]
	lea	PLAYER_BULLET_Y,a0                            	| point HL to PLAYER_BULLET_Y [inc  l]
	tst.b	HAS_PLAYER_SPAWNED                       	| read HAS_PLAYER_SPAWNED flag [ld   a,(0x4200)]
											| test if player has spawned [bit  0,a]
	jeq	l_08e2                             	| no, player has not spawned, goto 0x08E2 [jr   z,0x08E2]
	move.b	PLAYER_Y,(a0)                         	| write to PLAYER_BULLET_Y [ld   (hl),a]
	rts                                    	| [ret]

* player hasn't spawned. Hide the bullet!
l_08e2:
	clr.b	(a0)                             	| write 0 to PLAYER_BULLET_Y [ld   (hl),0x00]
	rts                                    	| [ret]


*
* Check if the player bullet has gone all the way upscreen. If so, allow player to shoot again.
*

HANDLE_PLAYER_BULLET_EXPIRED:
	move.b	IS_PLAYER_BULLET_DONE,d0                       	| read IS_PLAYER_BULLET_DONE flag [ld   a,(0x420B)]
	ror.b	#1,d0                            	| move bit 0 into carry. If carry is set then the player bullet's gone as far as it can. [rrca]
	bcs.b	0f
	rts                                    	| if no carry, then return. [ret  nc]
0:
	clr.b	IS_PLAYER_BULLET_DONE                       	| reset the IS_PLAYER_BULLET_DONE flag [ld   (0x420B),a]
	clr.b	HAS_PLAYER_BULLET_BEEN_FIRED                       	| reset HAS_PLAYER_BULLET_BEEN_FIRED flag. Player can shoot again. [ld   (0x4208),a]
	rts                                    	| [ret]






UNPACK_ALIEN_SWARM:
	lea	ALIEN_SWARM_FLAGS,a0                      	| load HL with address of ALIEN_SWARM_FLAGS [ld   hl,0x4100]
	move.b	#0x10,d1                        	| There's 16 bytes to be unpacked to 128 flags [ld   b,0x10]
	move.b	#0x01,d2                        	| [ld   c,0x01]

l_064d:
	move.b	(a1),d0                         	| read from (de) [ld   a,(de)]
	and.b	d2,d0                            	| test if bit is set [and  c]
	jeq	l_065c                             	| if bit is not set, goto 0x065C [jr   z,0x065C]
	move.b	#0x01,(a0)                      	| bit is set, write 1 to (hl) - create an alien [ld   (hl),0x01]
l_0653:
	addq.w	#1,a0                           	| bump hl to next byte [inc  hl]
	rol.b	#1,d2                            	| rotate c left one bit [rlc  c]
	jcc	l_064d                             	| if bit 7 of C wasn't set, goto 0x064D [jr   nc,0x064D]
	addq.w	#1,a1                           	| move to next byte [inc  de]
	subq.b	#1,d1                           	| [...]
	jne	l_064d                             	| do until b ==0 [djnz 0x064D]
	rts                                    	| [ret]
l_065c:
	clr.b	(a0)                      	| write 0 to (hl) [ld   (hl),0x00]
	jra	l_0653                             	| [jp   0x0653]




*
* Try to insert into the circular command queue located @ 0x40C0. (CIRC_CMD_QUEUE_START)
* if insert is not possible, exit function immediately.
*
* Expects:
* D is a command number (0..7) 
* E is a parameter to pass to the command. 
*
* 0x40A0 contains the low byte of a pointer to a (hopefully) free entry in the queue.  
*
* REMARKS:
*
* Value in D                Action it invokes 
* ===============================================================
* 0                         Invokes DRAW_ALIEN_COMMAND
* 1                         Invokes DELETE_ALIEN_COMMAND
* 2:                        Invokes DISPLAY_PLAYER_COMMAND
* 3:                        Invokes UPDATE_PLAYER_SCORE_COMMAND
* 4:                        Invokes RESET_SCORE_COMMAND
* 5:                        Invokes DISPLAY_SCORE_COMMAND
* 6:                        Invokes PRINT_TEXT_COMMAND 
* 7:                        Invokes DISPLAY_BOTTOM_OF_SCREEN_COMMAND
* 
* The purpose of the parameter in E depends on the command.
*
* SEE ALSO:
* The code @ 0x200C which processes the entries in the queue.

* ALGORITHM:
* 1. Form a pointer to an entry in the circular queue using #0x40 as the high byte of the pointer
*    and the contents of 0x40A0 (CIRC_CMD_QUEUE_PTR_LO) as the low byte. 
* 2. Read a byte from the queue entry the pointer points to 
* 3. IF bit 7 of the byte is unset, then the queue entry is in use, we can't insert. Exit function.  
* 4. ELSE:
*    4a) store register DE at the pointer
*    4b) bump pointer to next queue entry 
* 5. Exit function

QUEUE_COMMAND:
	move.l	a0,-(a7)
	move.l	CIRC_CMD_QUEUE_PTR,a0
	tst		(a0)	| if bit 7 not set, this entry cannot be used, goto 0x090B and exit
	bpl.b	1f
	* JOTD: data is even aligned so we can write command & args
	* atomicly, in the original there's a slight chance that
	* the command queue is processed between both writes
	move.w	d3,(a0)+
	cmp.l	#CIRC_CMD_QUEUE_END,a0
	bne.b	0f
	move.l	#CIRC_CMD_QUEUE_START,a0
0:
	move.l	a0,CIRC_CMD_QUEUE_PTR		| update CIRC_CMD_QUEUE_PTR_LO to point to next queue entry
1:
	move.l	(a7)+,a0
	rts
	


HANDLE_SIMULATE_PLAYER_IN_ATTRACT_MODE:
	move.b	TIMING_VARIABLE,d0                       	| read TIMING_VARIABLE [ld   a,(0x425F)]
	add.b	#0x09,d0                         	| [add  a,0x09]
	and.b	#0x1F,d0                         	| [and  0x1F]
	beq.b	0f
	rts                                    	| [ret  nz]
0:
	tst.b	IS_GAME_OVER                       	| read IS_GAME_OVER flag [ld   a,(0x4007)]
	bne.b	0f
	rts                                    	| return if its not GAME OVER [ret  nc]
0:
	move.b	HAS_PLAYER_SPAWNED,d0                       	| read HAS_PLAYER_SPAWNED [ld   a,(0x4200)]
	ror.b	#1,d0                            	| move flag into carry [rrca]
	bcs.b	0f
	rts                                    	| return if player has not spawned yet [ret  nc]
0:

	lea	INFLIGHT_ALIENS+inflight_alien_size,a2                      	| pointer to INFLIGHT_ALIENS_START + sizeof(INFLIGHT_ALIEN) [ld   ix,0x42D0]
	clr.b	d1                               	| [ld   b,0x00]
	move.b	#0x07,d1                        	| 7 aliens to process [ld   b,0x07]
l_19ac:
	move.b	(inf_alien_X,a2),d5
	move.b	(inf_alien_Y,a2),d6
	move.b	(0x1a,a2),d2   	                	| ???? [ld   c,(ix+0x1a)]
	jbsr	l_1a12                            	| [call 0x1A12]
	add.w	#inflight_alien_size,a2                              	| bump IX to next INFLIGHT_ALIEN
	subq.b	#1,d1                           	| [...]
	jne	l_19ac                             	| [djnz 0x19AC]


	lea	ENEMY_BULLETS_START,a2                      	| load IX with address of ENEMY_BULLETS_START [ld   ix,0x4260]
	move.b	#0x07,d1                        	| number of enemy bullets [ld   b,0x07]
l_19c7:
	move.b	(1,a2),d5						| H = ENEMY_BULLET.X   [ld   h,(ix+0x01)]
	move.b	(3,a2),d6						| L = ENEMY_BULLET.YH  [ld   l,(ix+0x03)]
                        	                      	
	move.b	(0x04,a2),d2                    	| C = ENEMY_BULLET.YDelta [ld   c,(ix+0x04)]
	jbsr	l_1a12                            	| [call 0x1A12]

	add.w	#5,a2                              	| bump IX to next ENEMY_BULLET
	subq.b	#1,d1                           	| [...]
	jne	l_19c7                             	| [djnz 0x19C7]

	move.b	PLAYER_Y,d0                       	| read PLAYER_Y [ld   a,(0x4202)]
	move.b	d0,d2                           	| [ld   c,a]
	move.b	SWARM_SCROLL_VALUE+1,d0                       	| read SWARM_SCROLL_VALUE [ld   a,(0x420E)]
	add.b	#0x80,d0                         	| [add  a,0x80]
	sub.b	d2,d0                            	| subtract player Y [sub  c]
	asr.b	#5,d0                            	| divide A.... [sra  a]*5 .. by 32, preserving sign bit
	add.b	d1,d0                            	| [add  a,b]
	asr.b	#1,d0                            	| [sra  a]
	move.b	d0,d2                           	| [ld   c,a]
	jbsr	GENERATE_RANDOM_NUMBER                            	| call GENERATE_RANDOM_NUMBER. Now A = pseudorandom number [call 0x003C]
	move.b	d2,d1                           	| [ld   b,c]
	add.b	d0,d0                            	| [add  a,a]
	subx.b	d0,d0                           	| [sbc  a,a]
	jne	l_19fb                             	| [jr   nz,0x19FB]
	addq.b	#1,d0                           	| [inc  a]
l_19fb:
	add.b	d1,d0                            	| [add  a,b]
	addq.b	#0x01,d0                        	| [add  a,0x01]
	jmi	l_1a0e                             	| [jp   m,0x1A0E]
	cmp.b	#0x02,d0                         	| [cp   0x02]
	jcc	l_1a0a                             	| [jr   nc,0x1A0A]
	moveq	#0,d0                            	| [xor  a]
l_1a06:
	move.b	d0,ATTRACT_MODE_FAKE_CONTROLLER                       	| set ATTRACT_MODE_FAKE_CONTROLLER value. Ship will move under AI control [ld   (0x423F),a]
	rts                                    	| [ret]

l_1a0a:
	move.b	#0x04,d0                        	| simulates player moving LEFT (bit maps to !SW0   p1 left) [ld   a,0x04]
	jra	l_1a06                             	| go set ATTRACT_MODE_FAKE_CONTROLLER [jr   0x1A06]

l_1a0e:
	move.b	#0x08,d0                        	| simulates player moving RIGHT (bit maps to !SW0    p1 right) [ld   a,0x08]
	jra	l_1a06                             	| go set ATTRACT_MODE_FAKE_CONTROLLER [jr   0x1A06]




*
* This is used in the attract mode to help the simulated player dodge bullets.
*
* Expects:
* IX = pointer to INFLIGHT_ALIEN or ENEMY_BULLET
* H = X coordinate of alien or bullet
* L = Y coordinate of alien or bullet
* C = YDelta of alien/bullet
*
* Returns:
*
l_1a12:
	btst.b	#0,(IsActive,a2)                    	| test INFLIGHT_ALIEN.IsActive flag [bit  0,(ix+0x00)]
	bne.b	0f
	rts                                    	| exit if alien is not active [ret  z]
0:
	move.b	d5,d0                           	| get X coordinate of alien/bullet [ld   a,h]
	sub.b	#0x80,d0                         	| subtract 128 decimal [sub  0x80]
	bcc.b	0f
	rts                                    	| if there's a carry, the alien's not far enough down the screen to be a threat, return [ret  c]
0:

	moveq	#0,d4
	sub.b	#0x34,d0                         	| subtract 0x34 from X coordinate [sub  0x34]
	jcs	l_1a25                             	| [jr   c,0x1A25]
	addq.b	#1,d4                            	| [inc  e]
	sub.b	#0x34,d0                         	| [sub  0x34]
	bcs.b	0f
	rts                                    	| [ret  nc]
0:

l_1a25:
	move.b	PLAYER_Y,d0                       	| read PLAYER_Y [ld   a,(0x4202)]
	sub.b	d6,d0                             	| subtract Y coordinate of alien/bullet [sub  l]
	sub.b	#0x40,d0                         	| [sub  0x40]
	cmp.b	#0x80,d0                         	| [cp   0x80]
	bcs.b	0f
	rts                                    	| return if A >= 0x80 [ret  nc]
0:

	and.b	#0x60,d0                         	| [and  0x60]
	move.b	d0,d6

	move.b	d2,d0                           	| A = YDelta [ld   a,c]
	and.b	#0x80,d0                         	| [and  0x80]
	or.b	d6,d0                              	| [or   l]
	ror.b	#4,d0                            	| [rrca]*4
	or.b	d4,d0                              	| [or   e]
	move.b	d0,d4

	lea	l_1A45(pc),a0                      	| [ld   hl,0x1A45]
	move.b	(a0,d4.w),d0                         	| [ld   a,(hl)]
	add.b	d1,d0                            	| [add  a,b]
	move.b	d0,d1                           	| [ld   b,a]
	rts                                    	| [ret]

l_1A45: 
	.byte	0x02,0x03,0xFE,0x02,0xFF,0xFE,0x00,0xFF,0x00,0x01,0x01,0x02,0x02,0xFE,0xFE,0x03            



*
* Called from $0004.
* 
*
*
	
INITIALISE_SYSTEM:  | 1A55

* Clear screen 
	move	#0x400-1,d1
	move	#0x10,d0
	move.w	#0x5000,d6
0:
	jbsr		osd_w_bg_videoram
	addq.w	#1,d6
	dbf		d1,0b
	
* clear attributes and reset scroll values
	jbsr		osd_reset_attributes	| write 0 to screen attribute RAM. Will both set colour to 0 and reset column scroll.
	
* (skipped startup checks!)

* When we get here, all the diagnostic tests have succeeded. 
* There are no errors, and the game can start proper.
* original game sets all to 0 except for 0x40C0->0x4100
* I almost could blindly follow that but some of the pointers
* are 1-byte pointer nibbles, had to switch to full 32 bit

	lea		VARIABLES_START,a0		| Start of working RAM
	move.l	#VARIABLES_END,d0
	sub.l	a0,d0
	subq.w	#1,d0
0:
	clr.b	(a0)+
	dbf		d0,0b

	* some important variable sets were lost in diagnostic code
	* without this, the alien swarm appears at startup (which is great to
	* test it immediately, but not great to be accurate :))
	moveq	#1,d0
	move.b	d0,DIAGNOSTIC_MESSAGE_TYPE
	move.b	d0,HAVE_NO_INFLIGHT_ALIENS
	move.b	d0,TIMING_VARIABLE
	move.b	d0,DISABLE_SWARM_ANIMATION
	
	* message queue set to all invalid (negative)
	lea		CIRC_CMD_QUEUE_START,a0
	move.l	#CIRC_CMD_QUEUE_END,d0
	sub.l	a0,d0
	subq	#1,d0
1:
	st.b	(a0)+
	dbf		d0,1b
	
	move.b	#0x20,TEMP_COUNTER_1			| set TEMP_COUNTER_1
	move.b	#3,DIAGNOSTIC_MESSAGE_TYPE
	lea		CIRC_CMD_QUEUE_START,a0
	move.l	a0,CIRC_CMD_QUEUE_PTR			| reset CIRC_CMD_QUEUE_PTR
	move.l	a0,CIRC_CMD_QUEUE_PROC			| reset CIRC_CMD_QUEUE_PROC
	
	jbsr	osd_stars_on					| Set 9Nregen stars on. Starry background now appears 
	jbsr	osd_enable_vblank_interrupt		| Enable 9Nregen NMIon
	
	* part done in diagnostic, we don't want diagnostic but we need those inits
	move.w	#0x5000,TEMP_CHAR_RAM_PTR    | set TEMP_CHAR_RAM_PTR
	move.b	#0x20,TEMP_COUNTER_1
	clr.b	DIAGNOSTIC_MESSAGE_TYPE
	clr.b	SCRIPT_NUMBER

*	bra		jmp_2000
*	nop
	

* reset all player-related state including score, high score
jmp_2000:
	lea		PLAYER_ONE_SCORE,a0
	move.l	#CIRC_CMD_QUEUE_START,d0
	sub.l	a0,d0
	lsr.w	#1,d0
	subq	#1,d0
0:
	clr.w	(a0)+
	dbf		d0,0b
	
	* now would be a good time to read highscore from saved state
	lea		PLAYER_ONE_SCORE,a0
	*bsr		osd_read_hiscores
*
* Process the circular command queue starting @ 0x40C0 (CIRC_CMD_QUEUE_START)
*
* Notes:
* The value in 0x40A1 (I have named it CIRC_CMD_QUEUE_PROC_LO) is the low byte of a pointer to the first entry in 
* the queue to be processed. The high byte of the pointer is always #0x40.
* 
* In a circular queue, the first entry to be processed is not necessarily the head of the queue. 
* The first entry to be processed could be anywhere in the queue. 
*


PROCESS_CIRCULAR_COMMAND_QUEUE:
0:
	move.l	CIRC_CMD_QUEUE_PROC,a0		| now a0 = pointer to a queue entry in the queue to be processed
	moveq	#0,d0
	move.b	(a0),d0							| read command number from queue entry into d0. 
	add.b	d0,d0							| multiply d0 by 2 to form an offset into jump table @0x203D
	bcc.b	1f
	
    jbsr		HANDLE_SWARM_ANIMATION
	bra.b	0b								| process next entry in circular queue
1:
	and  #0x0F,d0                 | mask in lower nibble
	add		d0,d0							| multiply d0 by 4 to form an offset into jump table @0x203D
	lea	jump_table_203D(pc),a1			| pointer to jump table beginning @ 0x203D
	move.l	(a1,d0.w),a1
	
	st	(a0)+                             | write #0xFF (255 decimal) to first byte of byte pair, to mark it as "free"
	move.b	(a0),d4		                  | read parameter value from queue entry into E. 
	st	(a0)+                             | write #0xFF (255 decimal) to second byte of byte pair, to mark it as "free"
	cmp.l	#CIRC_CMD_QUEUE_END,a0		  | is HL == 0x4100? If so, comparing L (which will be 0) to #0xC0 (192 decimal) will set the carry flag. 
	bcs.b	2f							  | if carry is set, then we have not reached the end of the queue (0x4100), goto 0x202C
	lea		CIRC_CMD_QUEUE_START,a0		  | otherwise, we have reached end of queue. 
2:
	move.l	a0,CIRC_CMD_QUEUE_PROC       | Set lo byte of pointer to 0xC0 (0x40C0 = start of circular queue)
	move.b	d4,d0		                 | Now d0 = parameter to command
	pea		0b(pc)						 | push it onto stack, so when we hit a rts it'll return to 0x200A
	jmp		(a1)		                 | jump to proper code from the table below					 

jump_table_203D:
    .long	DRAW_ALIEN_COMMAND
    .long	DELETE_ALIEN_COMMAND
    .long	DISPLAY_PLAYER_COMMAND
    .long	UPDATE_PLAYER_SCORE_COMMAND
    .long	RESET_SCORE_COMMAND
    .long	DISPLAY_SCORE_COMMAND
    .long	PRINT_TEXT_COMMAND
    .long	DISPLAY_BOTTOM_OF_SCREEN_COMMAND

*
* Called when an alien rejoins the swarm.
*

DRAW_ALIEN_COMMAND:
	jbsr	GET_ALIEN_CHAR_RAM_ADDR                            	| call GET_ALIEN_CHAR_RAM_ADDR [call 0x20E1]
	jbsr	CHOOSE_ANIMATION_FRAME_FOR_ALIEN_REJOINING_SWARM                            	| call CHOOSE_ANIMATION_FRAME_FOR_ALIEN_REJOINING_SWARM [call 0x2104]
	jra	DRAW_ALIEN                             	| jump to DRAW_ALIEN [jp   0x2131]



*
* Called to delete an alien because it's either been killed or it's broken off for an attack.
*

DELETE_ALIEN_COMMAND:
	jbsr	GET_ALIEN_CHAR_RAM_ADDR                            	| call GET_ALIEN_CHAR_RAM_ADDR [call 0x20E1]
	tst.b	d7
	jne	l_2583                             	|  [jp   c,0x2583]
	jra	l_25a7                             	| plot two spaces in the same column [jp   0x25A7]


*
* Animates the alien swarm.
*
* Can be disabled by setting 0x4238 (DISABLE_SWARM_ANIMATION) flag to 1.
*
* Note:
* The WE ARE THE GALAXIANS attract mode screen requires the DISABLE_SWARM_ANIMATION flag set
* because the text overlays where the swarm would,0xbe and we don't want it corrupted by the animation routine.
*

HANDLE_SWARM_ANIMATION:
	move.b	TIMING_VARIABLE,d0                       	| read TIMING_VARIABLE [ld   a,(0x425F)]
	move.b	d0,d1                           	| [ld   b,a]
	and.w	#0x0F,d0                         	| mask in lower nibble [and  0x0F]
	jeq	HANDLE_1UP_2UP_BLINKING                             	| if lower nibble is 0, goto HANDLE_1UP_2UP_BLINKING [jr   z,0x209C]

* A = column of aliens to animate (0-15)
	lea	ALIEN_SWARM_FLAGS+0x20,a0                      	| load HL with pointer to bottommost row of aliens in ALIEN_SWARM_FLAGS [ld   hl,0x4120]
	add.w	d0,a0                             	| [add  a,l]
												| Now HL points to bottommost alien in the column
	tst.b	DISABLE_SWARM_ANIMATION                       	| read DISABLE_SWARM_ANIMATION flag [ld   a,(0x4238)]
	beq.b	0f
	rts                                    	| if flag was set, return [ret  c]
0:

* animate each alien in the column
	*move.w	#0x10,d2                        	| sizeof a row of aliens in ALIEN_SWARM_FLAGS [ld   c,0x10]
	move.b	#0x06,d1                        	| number of rows of aliens to process. [ld   b,0x06]
l_207d:
	move.w	d1,-(a7)				| [push bc] we don't care about d2
	move.l	a0,-(a7)		| [push hl]
	move.l	a0,d0
	sub.l	#ALIEN_SWARM_FLAGS,d0         	| [ld   a,l] (adapted, compute alien index in swarm)
	tst.b	(a0)                         	| test flag in ALIEN_SWARM_FLAGS to see if alien is present [bit  0,(hl)]
	jne	l_2089                             	| if alien is present, goto 0x2089 [jr   nz,0x2089]

	jbsr	DELETE_ALIEN_COMMAND                            	| call DELETE_ALIEN_COMMAND to erase the alien from the screen [call 0x205E]
	jra	l_2094                             	| [jr   0x2094]

l_2089:
	jbsr	GET_ALIEN_CHAR_RAM_ADDR                            	| call GET_ALIEN_CHAR_RAM_ADDR [call 0x20E1]
	clr.b	d2                               	| load randomness value (see docs for CALCULATE_ALIEN_ANIMATION_FRAME_INDEX) [ld   c,0x00]
	jbsr	CALCULATE_ALIEN_ANIMATION_FRAME_INDEX                            	| call CALCULATE_ALIEN_ANIMATION_FRAME_INDEX [call 0x211D]
	jbsr	DRAW_ALIEN                            	| call DRAW_ALIEN [call 0x2131]

l_2094:
	move.l	(a7)+,a0		| [pop hl]
	move.w	(a7)+,d1				| [pop bc]
	add.w	#0x10,a0			| HL = HL + 16 decimal. Now HL points to alien above, in same column
	subq.b	#1,d1                           	| [...]
	jne	l_207d                             	| repeat until all rows of aliens done [djnz 0x207D]
	rts                                    	| [ret]


*
* When the game has a human in control, make 1UP or 2UP "blink".
*
* 1UP never blinks during attract mode, presumably because it distracts the viewer's attention.
*

HANDLE_1UP_2UP_BLINKING:
l_209c:
	move.b	IS_GAME_IN_PLAY,d0                       	| read IS_GAME_IN_PLAY flag [ld   a,(0x4006)]
	tst.b	d0                               	| test if zero [and  a]
	jeq	l_20a7                             	| if flag is not set, goto 0x20A7 [jr   z,0x20A7]
	move.b	d0,CAN_BLINK_1UP_2UP                       	| set CAN_BLINK_1UP_2UP flag [ld   (0x40AB),a]
	jra	BLINK_1UP_OR_2UP_TEXT                             	| goto BLINK_1UP_or_2UP_TEXT [jr   0x20AC]


l_20a7:
	tst.b	CAN_BLINK_1UP_2UP                       	| read CAN_BLINK_1UP_2UP [ld   a,(0x40AB)]
	bne.b	0f
	rts                                    	| if flag is not set, return [ret  z]
0:

*
* This code makes the 1UP or 2UP text blink during the game.
*
* Expects:
* B = any number (sourced from TIMING_VARIABLE @ 0x425F).
*

BLINK_1UP_OR_2UP_TEXT:
	move.b	CURRENT_PLAYER,d0                       	| read CURRENT_PLAYER [ld   a,(0x400D)]
	jbsr	l_214e                            	| get character RAM address for where 1UP or 2UP is printed [call 0x214E]
	move.w	#-32,d3                      	| load DE with -32 decimal [ld   de,0xFFE0]
	btst.b	#4,d1                           	| test bit 4 of timing variable value [bit  4,b]
	jeq	l_20cd                             	| if not set, then draw "1UP" or "2UP" [jr   z,0x20CD]

* erase "1UP" or "2UP" for current player
	move.b	#0x10,d0                        	| ordinal for empty space character [ld   a,0x10]
	jbsr	osd_w_bg_videoram                         	| erase first character of "1UP" or "2UP" [ld   (hl),a]
	add  d3,d6                              	| bump HL to point to character directly above
	jbsr	osd_w_bg_videoram                         	| erase second character [ld   (hl),a]
	add  d3,d6                              	| bump HL to point to character directly above
	jbsr	osd_w_bg_videoram                         	| erase third character [ld   (hl),a]

	move.b	IS_TWO_PLAYER_GAME,d0                       	| read IS_TWO_PLAYER_GAME [ld   a,(0x400E)]
	tst.b	d0                               	| test flag [and  a]
	bne.b	0f
	rts                                    	| return if not a two-player game [ret  z]
0:
	move.b	CURRENT_PLAYER,d0                       	| read CURRENT_PLAYER [ld   a,(0x400D)]
	eor.b	#0x01,d0                          	| swap between player one and two (0= Player One, 1=Player 2) [xor  0x01]
	jbsr	l_214e                            	| get character RAM address for where 1UP or 2UP is printed [call 0x214E]

* plot "1UP" or "2UP"
l_20cd:
	addq.b	#1,d0                           	| A now is the ordinal for the "1" or "2" character [inc  a]
	jbsr	osd_w_bg_videoram                         	| write "1" or "2" [ld   (hl),a]
	add  d3,d6                              	| bump HL to point to character directly above
	move.b	#0x25,d0                      	| 'U' [ld   (hl),0x25]
	jbsr	osd_w_bg_videoram
	add  d3,d6                              	| bump HL to point to character directly above
	move.b	#0x20,d0                      	| 'P' [ld   (hl),0x20]
	jbsr	osd_w_bg_videoram
	btst.b	#4,d1                           	| [bit  4,b]
	beq.b	0f
	rts                                    	| [ret  nz]
0:
	tst.b	IS_GAME_IN_PLAY                       	| read IS_GAME_IN_PLAY [ld   a,(0x4006)]
	beq.b	0f
	rts                                    	| if game is in play, return [ret  nz]
0:
	move.b	d0,CAN_BLINK_1UP_2UP                       	| clear CAN_BLINK_1UP_2UP flag. [ld   (0x40AB),a]
	rts                                    	| [ret]

* Get character RAM address of alien in swarm.
*
* Expects:
* A = index of alien in swarm (0-127)
*
* Returns:
* B = A on entry (D1 = D0 on entry)
* HL (D6) = pointer to screen RAM where alien should be plotted
* Carry flag (D7) = set if alien is on an "odd" row
*
* Screen address is calculated as follows:
* Flagship:              0x5004 + (column index * 0x40)
* Red alien:             0x5006 + (column index * 0x40)
* Purple alien:          0x5007 + (column index * 0x40)
* Blue alien top row:    0x5009 + (column index * 0x40)
* Blue alien middle row: 0x500A + (column index * 0x40)
* Blue alien bottom row: 0x500C + (column index * 0x40)
*
* Carry (D7) is set when A identifies a Flagship, Purple, Blue Alien Mid row alien.
*
* I could spend more time figuring out exactly how this code works, but I don't think the benefit outweighs the
* effort. It's one of those algorithms where I look at it and just don't "get it". I figure if you want to patch it,
* you could easily create a lookup table - and the lookup table approach would probably be faster than this method.

GET_ALIEN_CHAR_RAM_ADDR:
	move.b	d0,d1                           	| preserve A in B [ld   b,a]
	and.b	#0x0F,d0                         	| now A is the column index of the alien (0-15). *Clears carry* [and  0x0F]
	ror.b	#2,d0                            	| move bit 0 & bit 1.. [rrca]
												| ..into bits 6 & 7 respectively. [rrca]
	move.b	d0,d2                           	| [ld   c,a]
	and.b	#0x03,d0                         	| [and  0x03]
	move.b	d0,d5			| [ld h,a]

	move.b	d2,d0                           	| [ld   a,c]
	and.b	#0xC0,d0                         	| [and  0xC0]
	move.b	d0,d6		| [ld l,a]

	move.b	d1,d0                           	| restore alien index from B (see @0x20E1) [ld   a,b]
	ror.b	#4,d0                            	| divide A.. [rrca] by 16. Now A is a row index. [rrca]
	and.b	#0x07,d0                         	| Ensure A falls between 0 and 7. >7 is invalid. *also clears carry flag* [and  0x07]
* row 7 = flagship row.  row 2 = blue alien bottom row
	move.b	d0,d2                           	| save row index in C. [ld   c,a]
	* here carry is 0, so roxr is safe (but could also be ror on 68000)
	roxr.b	#1,d0                           	| divide row index by 2. if row index is odd, then set carry flag [rra]

* very important that we preserve the carry flag here (inD7), because DRAW_ALIEN @ 2131 needs it
	scs		d7
	move.w	d0,-(a7)			| [push af]
	addx.b	d2,d0	|	[adc  a,c]
	not.b	d0                               	| [cpl]
	and.b	#0x0F,d0                         	| [and  0x0F]
	add.b	d0,d6                             	| [add  a,l]
											| [ld   l,a]
	lsl.w	#8,d5
	and.w	#0xFF,d6
	add.w	#0x5000,d6           	| add start of character RAM [ld   de,0x5000]
	add.w	d5,d6     |  [add  hl,de]

	move.w	(a7)+,d0		| [pop  af]

	rts                                    	| [ret]


*
* This code is called when an alien returns to the swarm and an animation frame needs to,0xbe chosen.
*
* Expects:
* B = index of alien (0-127)
*

CHOOSE_ANIMATION_FRAME_FOR_ALIEN_REJOINING_SWARM:
	move.w	D0,-(a7)					| [push af]
	move.b	d1,d0                           	| A = index of alien [ld   a,b]
	cmp.b	#0x70,d0                         	| is the index < 0x70 (112 decimal) [cp   0x70]
	jcs	l_210e                             	| yes, index < 0x70, goto 0x210E [jr   c,0x210E]
l_210a:
	move.b	#0x80,d1                        	| this is a flagship row - set bit 7 so code @0x213F knows [ld   b,0x80]
	move.w	(a7)+,d0			| [pop  af]
	rts                                    	| [ret]

l_210e:
	and.b	#0x0F,d0                         	| A = A MODULO 16. Now A = column of alien [and  0x0F]
	move.b	d0,d1                           	| make B = column of alien [ld   b,a]
	move.b	TIMING_VARIABLE,d0                       	| read TIMING_VARIABLE [ld   a,(0x425F)]
	and.b	#0x0F,d0                         	| mask in bits 0..3 [and  0x0F]
	clr.b	d2                               	| [ld   c,0x00]
	cmp.b	d1,d0                            	| [cp   b]
	jcc	l_211c                             	| if A> B goto 0x211C [jr   nc,0x211C]
	subq.b	#1,d2                           	| [dec  c]
l_211c:
	move.w	(a7)+,d0			| [pop  af]


* All aliens, except flagships, have 4 possible animation frames.
*
* This routine calculates an index which is used to look up the correct animation from a table.
*
* Expects:
* B = index of alien (0-127)
* C = value to add to calculated index, to make animation frames vary.
*
* Returns:
* B = animation frame index from 0..3

CALCULATE_ALIEN_ANIMATION_FRAME_INDEX:
	move.w	D0,-(a7)					| [push af]
	move.b	d1,d0                           	| A now = index of alien [ld   a,b]
	cmp.b	#0x70,d0                         	| is the index >= 0x70 (112 decimal) ? [cp   0x70]
	jcc	l_210a                             	| yes, then this is a flagship row, they don't animate, goto 0x210A [jr   nc,0x210A]
	move.b	TIMING_VARIABLE,d0                       	| read TIMING_VARIABLE [ld   a,(0x425F)]
	ror.b	#4,d0                            	| rotate A.. [rrca]*4 4 bits right
	add.b	d1,d0                            	| add in index of alien [add  a,b]
	add.b	d2,d0                            	| add in "randomness" value [add  a,c]
	and.b	#0x03,d0                         	| ensure animation frame index is between 0..3 [and  0x03]
	move.b	d0,d1                           	| set B to animation frame index [ld   b,a]
	move.w	(a7)+,d0			| [pop  af]
	rts                                    	| [ret]



* Draws alien [B] where B is an index into the ALIEN_SWARM_FLAGS array.
*
* For odd rows in the swarm (ie: flagship, purple aliens, blue middle row) the aliens occupy 2 columns x 2 rows of characters.
* For even rows, each alien in the row occupies 1 column and 2rows of characters.
*
*
* Expects:
* B (D1) = animation frame index
* HL (D6) = character RAM address to plot alien
* Carry flag (D7) = if set, draw characters on odd row

DRAW_ALIEN:
	| [ex   de,hl]
	tst.b	d7
	jne	l_213d                             	| if carry is set, we're drawing an odd row [jr   c,0x213D]

	lea	ALIEN_SWARM_CHARACTERS_SET_1x2(pc),a0                      	| load HL with pointer to ALIEN_SWARM_CHARACTERS_SET_1x2 [ld   hl,0x2157]
	moveq	#0,d0
	move.b	d1,d0                           	| load A with animation frame index [ld   a,b]
    move.b	(a0,d0.w),d0                           	| call routine to fetch value @ HL + A [rst  0x20]
	| [ex   de,hl]
	jra	PLOT_TWO_CHARACTERS_IN_SAME_COLUMN                             	| jump to PLOT_TWO_CHARACTERS_IN_SAME_COLUMN [jp   0x25A9]

* if we get here, we're drawing an "odd" row
l_213d:
	moveq	#0,d0
	move.b	d1,d0                           	| load A with animation frame index [ld   a,b]
	tst.b	d0                               	| test if its zero [and  a]
	jpl	l_2146                             	| if bit 7 is not set (see docs @ 0x210A) then its not a flagship we're drawing, goto 0x2146 [jp   p,0x2146]
	move.b	#0xA4,d0                        	| starting character for flagship [ld   a,0xA4]
	jra	l_214a                             	| draw the flagship [jr   0x214A]

l_2146:
	lea	ALIEN_SWARM_CHARACTERS_SET_2x2(pc),a0                      	| load HL with address of ALIEN_SWARM_CHARACTERS_SET_2x2 list [ld   hl,0x215B]
    move.b	(a0,d0.w),d0                           	| call routine to fetch value @ HL + A [rst  0x20]
l_214a:
	| [ex   de,hl]
	jra	PLOT_CHARACTERS_2_BY_2_ASCENDING                             	| jump to  [jp   0x2585]


*
* Expects:
* A = player index
*
* Returns:
* HL = pointer to where first character of 1UP or 2UP will,0xbe plotted
*
l_214e:
	move.w	#0x5340,d6                      	| 1UP [ld   hl,0x5340]
	tst.b	d0                               	| [and  a]
	bne.b	0f
	rts                                    	| [ret  z]
0:
	move.w	#0x50E0,d6                      	| 2UP [ld   hl,0x50E0]
	rts                                    	| [ret]

* start ordinals of characters for 1x2 aliens (see docs @ 0x2131 and 0x25A9)
ALIEN_SWARM_CHARACTERS_SET_1x2:
	.byte	0x41,0x35,0x41,0x31

* star ordinals of characters for 2x2 aliens (see docs @ 0x2131 and 0x2585)
ALIEN_SWARM_CHARACTERS_SET_2x2:
	.byte	0x44,0x38,0x44,0x3C

*
* Value in register A       Action taken
* =================================================================
* 0:                        Draw player ship in normal, alive state
* 1:                        Erase player ship
* Any other:                Render player ship as exploding
*
* NOTE:
* The player ship isn't a sprite. It's comprised of 4x4 characters.
*
*

DISPLAY_PLAYER_COMMAND:
	tst.b	d0                               	| test if A is 0 [and  a]
	jeq	DRAW_PLAYER_SHIP                             	| if A is 0, goto DRAW_PLAYER_SHIP [jr   z,0x219B]
	subq.b	#1,d0                           	| [dec  a]
	jeq	ERASE_PLAYER_SHIP                             	| if A was 1 on entry, goto ERASE_PLAYER_SHIP [jr   z,0x2187]
	subq.b	#1,d0                           	| [dec  a]

DRAW_PLAYER_SHIP_EXPLODING:
	lsl.b	#4,d0                            	| multiply A... [add  a,a]*4 .. by 16 [add  a,a]
	not.b	d0                               	| [cpl]
	and.b	#0x30,d0                         	| [and  0x30]
	add.b	#0xC0,d0                         	| [add  a,0xC0]
	move.w	#0x51DA,d6                      	| character RAM address for top right of explosion [ld   hl,0x51DA]
	jbsr	PLOT_CHARACTERS_2_BY_2_ASCENDING                            	| call PLOT_CHARACTERS_2_BY_2_ASCENDING [call 0x2585]
	move.w	#0x51DC,d6                      	| character RAM address for bottom right of explosion [ld   hl,0x51DC]
	jbsr	PLOT_CHARACTERS_2_BY_2_ASCENDING                            	| call PLOT_CHARACTERS_2_BY_2_ASCENDING [call 0x2585]
	move.w	#0x521A,d6                      	| character RAM address for top left of explosion [ld   hl,0x521A]
	jbsr	PLOT_CHARACTERS_2_BY_2_ASCENDING                            	| call PLOT_CHARACTERS_2_BY_2_ASCENDING [call 0x2585]
	move.w	#0x521C,d6                      	| character RAM address for bottom left of explosion [ld   hl,0x521C]
	jra	PLOT_CHARACTERS_2_BY_2_ASCENDING                             	| call PLOT_CHARACTERS_2_BY_2_ASCENDING [jp   0x2585]

ERASE_PLAYER_SHIP:
	move.w	#0x51DA,d6                      	| [ld   hl,0x51DA]
	move.w	#0x1C,d3                      	| offset to add to HL after drawing characters [ld   de,0x001C]
	move.b	#0x04,d2                        	| row counter: 4 characters high [ld   c,0x04]
	move.b	#0x40,d0
l_218f:
	move.b	#0x04,d1                        	| column counter: 4 characters wide [ld   b,0x04]
l_2191:
	jbsr	osd_w_bg_videoram                   	| ordinal for empty character [ld   (hl),0x40]
	addq.w	#1,a0                           	| bump to next character on same column [inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_2191                             	| do until B==0 [djnz 0x2191]
	add.w	d3,d6                              	| add offset to HL to point to row beneath
	subq.b	#1,d2                           	| decrement row counter [dec  c]
	jne	l_218f                             	| if row counter is not 0, goto 0x218F [jr   nz,0x218F]
	rts                                    	| [ret]

DRAW_PLAYER_SHIP:
	jbsr	ERASE_PLAYER_SHIP          	| erase existing ship or explosion [call 0x2187]
	move.b	#0x60,d0                        	| ordinal of first character to plot [ld   a,0x60]
	move.w	#0x51FC,d6                      	| character RAM address [ld   hl,0x51FC]
	jra	PLOT_CHARACTERS_2_BY_2_ASCENDING                             	| jump to PLOT_CHARACTERS_2_BY_2_ASCENDING [jp   0x2585]


*
*
* Value in register A       Points added to score
* ===============================================
* 0x0,0x30
* 0x1,0x40
* 0x2,0x50
* 0x3,0x60
* 0x4,0x70
* 0x5,0x80
* 0x6,0x90
* 0x7                         100
* 0x8                         150
* 0x9                         200
*,0x10                        300
*,0x11                        800

UPDATE_PLAYER_SCORE_COMMAND:
	moveq	#0,d2
	move.b	d0,d2                           	| save A in C as the rst corrupts A [ld   c,a]
	jbsr	LEA_DE_OF_CURRENT_PLAYER_SCORE    	| call LEA_DE_OF_CURRENT_PLAYER_SCORE. Now DE = pointer to current player's score [call 0x2290]
	move.b	d2,d0                           	| restore A (points value ID) from C [ld   a,c]
	add.b	d2,d0                            	| And then multiply .. [add  a,c]
	add.b	d2,d0                            	| .. A by 3. [add  a,c]
	move.b	d0,d2                           	| [ld   c,a]
												| Extend A into BC. Now BC is an offset into ALIEN_SCORE_TABLE [ld   b,0x00]
	lea	ALIEN_SCORE_TABLE(pc),a0                      	| pointer to ALIEN_SCORE_TABLE [ld   hl,0x22D0]
    add.w	d2,a0                         	 	| now HL points to an entry in the score table [add  hl,bc]
	tst.b	d0                               	| clear carry flag [and  a]
	move.b	#0x03,d1                        	| Players score is 3 bytes in size [ld   b,0x03]
l_21b8:
	move.b	(a1),d0                         	| read byte from players score [ld   a,(de)]
	add.b  (a0),d0                            	| add byte from the score table [adc  a,(hl)]

* When this instruction is executed, the A register is BCD corrected using the contents of the flags. The exact process is the following:
* if the least significant four bits of A contain a non-BCD digit (i. e. it is greater than 9) 
* or the H flag is set, then $06 is added to the register.
* Then the four most significant bits are checked. If this more significant digit also happens to be greater than 9
* or the C flag is set, then $60 is added.
	**TODO daa                                     	| ensure that the result is valid BCD [daa]
	move.b	d0,(a1)+                         	| update player score [ld   (de),a]
												| bump to next BCD digits in players score [inc  de]
	addq.w	#1,a0                           	| bump to next BCD digits in alien score [inc  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_21b8                             	| repeat until all digits in player score have been updated. [djnz 0x21B8]
	subq.w	#1,a1                           	| point to first 2 digits of player score [dec  de]
	move.l	a1,-(a7)
	subq.w	#1,a1                           	| point to 3rd and 4th digits of player score [dec  de]
	* here d5.w simulates hl
	move.b	d0,d5								| load H with first two digits of player score
	lsl.w	#8,d5
												| [ld   a,(de)]
	move.b	(a1),d5								| load L with 3rd and 4th digits of player score [ld   l,a]
	
	lsl.w	#4,d5								| [add  hl,hl] multiply HL * 16, which shifts all bits left 4 places.
	move.w	d5,d0                           	| [ld   a,h]
	lsr.w	#8,d0
	cmp.b	BONUS_GALIXIP_FOR,d0                      	| read BONUS_GALIXIP_FOR value [ld   hl,0x40AC]
	bcs.b	0f
	jbsr	AWARD_EXTRA_LIFE                            	| call AWARD_EXTRA_LIFE if our score is higher [call nc,0x229C]
0:
	addq.w	#1,a1                           	| [inc  de]
	move.b	CURRENT_PLAYER,d0                       	| read CURRENT_PLAYER [ld   a,(0x400D)]
	jbsr	DECIDE_TO_DISPLAY_PLAYER_ONE_OR_PLAYER_TWO_SCORE           	| call DECIDE_TO_DISPLAY_PLAYER_ONE_OR_PLAYER_TWO_SCORE [call 0x2256]
	move.l	(a7)+,a1
	lea	HI_SCORE+2,a0                      	| point to last byte (first 2 digits) of HI_SCORE [ld   hl,0x40AA]
	move.b	#0x03,d1                        	| Players score is 3 bytes in size [ld   b,0x03]
l_21df:
	move.b	(a1),d0                         	| read byte from player score [ld   a,(de)]
	cmp.b	(a0),d0                               	| compare to byte from high score [cp   (hl)]
	bcc.b	0f
	rts                                    	| if byte read is lower than the byte from high score, not new high score, so return [ret  c]
0:
	jne	UPDATE_HIGH_SCORE                             	| if byte is different, we have a new high score, goto 0x21E9 [jr   nz,0x21E9]
	subq.w	#1,a1                           	| otherwise, bump de [dec  de]
	subq.w	#1,a0                           	| and bump hl [dec  hl]
	subq.b	#1,d1                           	| [...]
	jne	l_21df                             	| repeat until b==0 [djnz 0x21DF]
	rts                                    	| [ret]


ALIEN_SCORE_TABLE:
	.byte	0x30,0x00,0x00            | 30 PTS
	.byte	0x40,0x00,0x00            | 40 PTS
	.byte	0x50,0x00,0x00            | 50 PTS
	.byte	0x60,0x00,0x00            | 60 PTS
	.byte	0x70,0x00,0x00            | 70 PTS
	.byte	0x80,0x00,0x00            | 80 PTS
	.byte	0x00,0x01,0x00            | 100 PTS
	.byte	0x50,0x01,0x00            | 150 PTS
	.byte	0x00,0x02,0x00            | 200 PTS
	.byte	0x00,0x03,0x00            | 300 PTS
	.byte	0x00,0x08,0x00            | 800 PTS
	.align	2
*
* Expects:
*
* A is a command.
*
* Value in register A       What it represents
* ==================================================================================================
* 0                         Reset player 1's score to 0 and clear PLAYER_ONE_AWARDED_EXTRA_LIFE flag.
* 1                         Reset player 2's score to 0 and clear PLAYER_TWO_AWARDED_EXTRA_LIFE flag.
* 2                         Reset high score to 0
* 3                         Do all of the above

RESET_SCORE_COMMAND:
	cmp.b	#0x03,d0                         	| [cp   0x03]
	jcc	l_2228                             	| if A>= 3 then goto RESET_ALL_SCORES_AND_EXTRA_LIFE_FLAGS [jr   nc,0x2228]
	move.w	D0,-(a7)			| [push af] we only need to save d0
	lea	PLAYER_ONE_SCORE,a0                      	| address of PLAYER_ONE_SCORE [ld   hl,0x40A2]
	lea	PLAYER_ONE_AWARDED_EXTRA_LIFE,a1                      	| address of PLAYER_ONE_AWARDED_EXTRA_LIFE [ld   de,0x40AD]
	tst.b	d0                               	| test if A is 0 [and  a]
	jeq	l_221a                             	| if A was 0 on entry, goto 0x221A and reset player 1's score [jr   z,0x221A]

	lea	PLAYER_TWO_SCORE,a0                      	| address of PLAYER_TWO_SCORE [ld   hl,0x40A5]
	lea	PLAYER_TWO_AWARDED_EXTRA_LIFE,a1                      	| address of PLAYER_TWO_AWARDED_EXTRA_LIFE [ld   de,0x40AE]
	subq.b	#1,d0                           	| if A was 1 on entry, then zero flag will be set after dec. [dec  a]
	jeq	l_221a                             	| if zero flag is set, then A was 1 on entry, goto 0x221A and reset player 2's score [jr   z,0x221A]
	lea	HI_SCORE,a0                      	| address of HI_SCORE [ld   hl,0x40A8]
    move.l	a0,a1                           	| DE = HL   [ld   e,l] [ld   d,h]
l_221a:
	clr.b	(a0)+                             	| clear first byte [ld   (hl),0x00]	                           	| [inc  hl]
	clr.b	(a0)+                             	| clear second byte [ld   (hl),0x00]
	                           	| [inc  hl]
	clr.b	(a0)                             	| clear third byte [ld   (hl),0x00]
	exg		a0,a1
	clr.b	(a0)                             	| reset the AWARDED_EXTRA_LIFE flag [ld   (hl),0x00]
	move.w	(a7)+,d0
	jra	DISPLAY_SCORE_COMMAND                             	| Goto DISPLAY_SCORE_COMMAND to display reset scores. [jr   0x2231]

RESET_ALL_SCORES_AND_EXTRA_LIFE_FLAGS:
l_2228:
	subq.b	#1,d0                           	| [dec  a]
	move.w	d0,-(a7)
	jbsr	RESET_SCORE_COMMAND                            	| [call 0x21FE]
	move.w	(a7)+,d0
	and.w	#0xFF,d0	| [pop af] pops A as byte
	bne.b	0f
	rts                                    	| [ret  z]
0:
	jra	l_2228                             	| [jr   0x2228]

	
*
* A = index of string to print
*
* Bit 6 set: scroll this text onto screen
* Bit 7 set: clear this text
*
* Value in A (ANDed with 0x3F)       Text printed
* =============================================================
* 0                                 GAME OVER
* 1                                 PUSH START BUTTON  
* 2                                 PLAYER ONE 
* 3                                 PLAYER TWO 
* 4                                 HIGH SCORE
* 5                                 CREDIT
* 6                                 BONUS GALIXIP FOR   000 PTS
* 7                                 CONVOY CHARGER 
* 8                                 - SCORE ADVANCE TABLE -
* 9                                 MISSION: DESTROY ALIENS
* A                                 WE ARE THE GALAXIANS
* B                                 30       60  PTS 
* C                                 40       80  PTS
* D                                 50      100  PTS
* E                                 60      300  PTS
* F                                 NAMCO logo
* 10                                FREE PLAY



PRINT_TEXT_COMMAND:
*	cmp.b	#10,d0
*	bne.b	0f
*	bsr		osd_break
*0:
	lea	TEXTPTRS(pc),a0			    	| HL = address of TEXTPTRS [ld   hl,0x235C]
	and.w	#0xFF,d0
	add.b	d0,d0						| A = A * 2.   This may affect C and PO flags. [add  a,a]
	scs		d7			| keep carry flag memory
	move.w	d0,-(a7)
	add.w	d0,d0
	and.w	#0x7F,d0   | mask in bits 0..6. Now A = a value in range of 0..127
	move.l	(a0,d0.w),a0	| HL now points to an entry in the TEXTPTRS lookup table.
	move.w	(a0)+,d6		| DE = *HL. Now DE holds character RAM address to print text at
							| Now HL = pointer to character RAM, DE = pointer to text to print
	move.w	#-0x20,d5         | offset to add to HL after every character write. (-32 in decimal)
	move.w	(a7)+,d2       | restore unmasked result of d0*2
	tst.b	d7				| get back carry flag from add d0
	bne.b	l_2319
	tst.b	d2			| test sign of d2 (as byte!)
	bmi.b	l_2323		| if minus flag is set, then we want to scroll text onto screen - goto 0x2323
0:
	move.b	(a0)+,d0     | read character to be drawn    [ld   a,(de)]
	sub.b	#0x30,d0     |  [sub  0x30]
	cmp.b	#0xF,d0		| is this the string terminator, #0x3F? [cp   0x0F]
	bne.b	1f
	rts					| yes, so exit routine
1:
	jbsr	osd_w_bg_videoram
	add.w	d5,d6		| Add offset to screen address so that next character is drawn at correct location.   
	bra.b	0b			| and continue

* I'll stick my neck out and guess this code is to erase text that was drawn previously.
l_2319:
	move.b	(a0),d0                         	| [ld   a,(de)]
	cmp.b	#0x3F,d0                         	| [cp   0x3F]
	bne.b	0f
	rts                                    	| [ret  z]
0:
	move.b	#0x40,d0                      	| [ld   (hl),0x40]
	jbsr	osd_w_bg_videoram
	addq.w	#1,a0                           	| [inc  de]
	add.w	d5,d6		| Add offset to screen address so that next character is drawn at correct location.   
	jra	l_2319                             	| [jr   0x2319]


*
* Set text up for scrolling. Invoked by 0x230B within PRINT_TEXT_COMMAND
*
* HL = pointer to character RAM
* DE = pointer to text string to render
*

l_2323:
	move.w	d6,COLUMN_SCROLL_CHAR_RAM_PTR                       	| store pointer to character RAM in COLUMN_SCROLL_CHAR_RAM_PTR [ld   (0x40B5),hl]
												| now HL = pointer to text string, DE = pointer to character RAM
	move.l	a0,COLUMN_SCROLL_NEXT_CHAR_PTR                       	| store pointer to next char to scroll on in COLUMN_SCROLL_NEXT_CHAR_PTR [ld   (0x40B3),hl]
	move.b	d6,d0                           	| get low byte of character RAM address into A [ld   a,e]
	and.b	#0x1F,d0                         	| mask in bits 0..4. Effectively A = A mod #0x20 (32 decimal). A now represents a column index from 0-31. [and  0x1F]
	move.b	d0,d1                           	| save column index in B. [ld   b,a]
* compute offset into OBJRAM_BACK_BUF
	add.b	d0,d0                            	| A=A*2. This is because attribute RAM requires 2 bytes per column. [add  a,a]
	lea		OBJRAM_BACK_BUF,a0
	add.w	d0,a0
								|
								| now HL = a pointer to scroll attribute value in OBJRAM_BACK_BUF
	move.l	a0,COLUMN_SCROLL_ATTR_BACKBUF_PTR                       	| set COLUMN_SCROLL_ATTR_BACKBUF_PTR [ld   (0x40B1),hl]
	**move.l	a0,-(a7)			| save pointer to scroll offset attribute on the stack
	* divide pointer to character ram (lower byte)  [srl  e]*2
	lsr.b	#2,d6
	move.w	d6,d0
	lsr.w	#8,d0		                    	| [ld   a,d]
	and.b	#0x03,d0                         	| [and  0x03] address is 5000-53FF => yields 0-3
	ror.b	#2,d0                            	| [rrca]*2
	or.b	d6,d0                              	| [or   e]
	and.b	#0xF8,d0                         	| [and  0xF8]
	move.b	d0,d2                           	| C = scroll offset to write to OBJRAM_BACK_BUF [ld   c,a]

* we're going to clear this line ready for scrolling text on.
	move.w	#0x5000,d6                      	| HL = start of character RAM [ld   hl,0x5000]
	move.b	d1,d0                           	| restore column index from B (see @0x232D) [ld   a,b]
	add.b	d0,d6                           	| Add column index to L. Now HL = pointer to column to clear [add  a,l]+[ld   l,a]
											| offset to add to HL. 0x20 (32 decimal) characters per row [ld   de,0x0020]
	move.b	#0x20,d1                           	| B = count of how many characters need to be cleared by DJNZ loop [ld   b,e]
l_234f:
	move.b	#0x10,d0
	jbsr	osd_w_bg_videoram				| write empty space character [ld   (hl),0x10]
	add.w	#0x20,d6						| add offset to HL. Now HL points to same column next row down
	subq.b	#1,d1                           	| [...]
	jne	l_234f                             	| [djnz 0x234F]
	* save/restore not needed as a0 is not changed
	**move.l	(a7)+,a0					| restore attribute pointer from the stack
	move.b	d2,(a0)                         	| write initial scroll offset to OBJRAM_BACK_BUF [ld   (hl),c]
	move.b	#0x01,IS_COLUMN_SCROLLING       	| set IS_COLUMN_SCROLLING flag [ld   (0x40B0),a]
	rts                                    	| [ret]



TEXTPTRS:                                     
	dc.l	TXT_GAME_OVER						| 0
	dc.l	TXT_PUSH_START_BUTTON				| 1  
	dc.l	TXT_PLAYER_ONE 						| 2
	dc.l	TXT_PLAYER_TWO						| 3 
	dc.l	TXT_HIGH_SCORE						| 4
	dc.l	TXT_CREDIT							| 5
	dc.l	TXT_BONUS_GALIXIP_FOR___000_PTS     | 6
	dc.l	TXT_CONVOY_CHARGER                  | 7
	dc.l	TXT___SCORE_ADVANCE_TABLE__         | 8
	dc.l	TXT_MISSION__DESTROY_ALIENS         | 9
	dc.l	TXT_WE_ARE_THE_GALAXIANS            | 10
	dc.l	TXT_30_______60__PTS                | 11
	dc.l	TXT_40_______80__PTS                | 12
	dc.l	TXT_50______100__PTS                | 13
	dc.l	TXT_60______300__PTS                | 14
	dc.l	TXT_NAMCO_logo                      | 15
	dc.l	TXT_FREE_PLAY                       | 16


*
* Selects information to be displayed at the bottom of the screen.
*
* On entry:
* A identifies what to be displayed.
*
* Value in d0                Action taken                                                                 See also 
* ===============================================================================================================================================
* 0                         The player advances to the next level and the red level flags are redrawn.   See: 0x2520 (DISPLAY_LEVEL_FLAGS)
* 1                         Display FREE PLAY or CREDIT n at bottom left of screen.                      See: 0x24EB (DISPLAY_AVAILABLE_CREDIT)
* 2                         Display BONUS GALIXIP FOR (nnnnn) PTS on screen.                             See: 0x24C8 (DISPLAY_BONUS_GALIXIP_FOR)
* Any other value           Display player ships remaining at bottom left of screen.                     See: 0x22B3 (DISPLAY_PLAYER_SHIPS_REMAINING)
*
DISPLAY_BOTTOM_OF_SCREEN_COMMAND:
	tst.b	d0
	jeq		DISPLAY_LEVEL_FLAGS		| if parameter is 0
	subq.b	#1,d0
	jeq		DISPLAY_AVAILABLE_CREDIT	| if parameter was 1
	subq.b	#1,d0
	jeq		DISPLAY_BONUS_GALIXIP_FOR	| if parameter was 2
	
	move.b	PLAYER_LIVES,d1
	jra		DISPLAY_PLAYER_SHIPS_REMAINING
	

*
* Displays the text string BONUS GALIXIP FOR (nnnnn) on screen.
*

DISPLAY_BONUS_GALIXIP_FOR:
	move.b	BONUS_GALIXIP_FOR,d0
	cmp.b	#0xFF,d0     | check if there is any bonus. I think this code is redundant.
	bne.b	0f
	rts                   | if no bonus, then return
0:
	moveq	#6,d0               | index of BONUS GALIXIP FOR 0000 PTS text string
    jbsr PRINT_TEXT_COMMAND               | display text on screen
    move.b	BONUS_GALIXIP_FOR,d0           | read BONUS GALIXIP value
    and.b  #0x0F,d0                 | mask in low nibble
	move.w	#0x5138,d6           | write value to character RAM
	jbsr		osd_w_bg_videoram   | and POKE number to screen RAM, displaying single digit in correct place
    move.b	BONUS_GALIXIP_FOR,d0           | read BONUS GALIXIP value
	and.b  #0xF0,d0			| mask in high nibble
    bne.b	1f            | if it's !=0, goto 0x24E3
    addq.b	#1,d0
1:
    lsr.w	#4,d0          | move high nibble...
							| ... into lower nibble, so that A is now a number from 0..9
	move.w	#0x5158,d6
	jbra		osd_w_bg_videoram   | and POKE number to screen RAM, displaying single digit in correct place
    *rts                      | we're out


*
* Displays either FREE PLAY or CREDIT (n) at bottom left of screen
*

DISPLAY_AVAILABLE_CREDIT:
      tst.b	IS_GAME_IN_PLAY
	  beq.b	0f
	  rts						| if the game is in play, return.
0:
      move.b	PORT_STATE_6800,d1           | read PORT_STATE_6800
      and.b   #0xC0,d1                 | mask in dip switch 1 & 2 state
      move.b	#0x10,d0               | index of text string "FREE PLAY"
      cmp.b   #0xC0,d1                 | are both dip switches on?
      beq	PRINT_TEXT_COMMAND

* if we get here, then we're not in FREE PLAY mode. We will display number of credits on screen.
      move.b	#0x05,d0               | index of text string "CREDIT"
      jbsr PRINT_TEXT_COMMAND
	  moveq	#0,d0
      move.b	NUM_CREDITS,d0          | read number of credits
      cmp.b	#0x63,d0                 | compare to 99 decimal
      bcs.b		1f             | if A <99 then goto 0x250A
      move.w	#99,d0               | clamp number of credits to 99
1:
      jbsr CONVERT_A_TO_BCD     |  Now A = BCD equivalent of what it was
      move.b	d0,d1           | save credits as BCD in B
      and.b  #0xF0,d0                 | mask in high nibble, which is first digit of BCD
      beq.b	2f             | if the first digit is 0, goto 0x2519. We don't display it.
      lsr.w	#4,d0                    | shift high nibble...
                                     | to low nibble.. converting first BCD digit to decimal.
      move.w	#0x529F,d6           | Write first digit of credits to character RAM
	  jbsr		osd_w_bg_videoram
2:
      move.b	d1,d0              | get credits as BCD into A again. We preserved it in B @0x250D
      and.b  #0x0F,d0                 | mask in low nibble, which is second digit of BCD. Converts second BCD digit to decimal.
	  move.w	#0x527F,d6
      jbsr		osd_w_bg_videoram           | Write second digit of credits to character RAM 
      rts                      


*
* Called when the player has completed the level.
*
* This routine:
*    Resets the swarm tempo|
*    increments the player level (48 levels maximum)|
*    Draws level flags. 
*

DISPLAY_LEVEL_FLAGS:
      tst.b	HAVE_NO_ALIENS_IN_SWARM   | test if flag is set
      beq.b	0f             | if flag is not set, goto 0x252C
      move.b  #1,RESET_SWARM_SOUND_TEMPO     | set  flag to 1. The swarm tempo will be slow again. 
0:
      move.b	PLAYER_LEVEL,d0           | read .
      addq.b	#1,d0                   | increment it.
      cmp.b	#0x30,d0                 | Compare to #0x30 (48 decimal)
      bcs.b	     1f        | if A < 48, goto 0x2536
      move.b	#0x30,d0               | Level 48 is the limit.
1:
* A = level number (0-48)
      jbsr CONVERT_A_TO_BCD               | convert A to BCD. Now A = BCD equivalent 

* A = level number in BCD
	move.w	d0,-(a7)
    move.w	#0x507E,d6              | address in character RAM to start drawing flags at
    and.b  #0xF0,d0                 | mask in high nibble
    beq.b	3f                      | if the high nibble is zero, then goto 0x2551

* Calculate how many "10" flags we are going to draw
    lsr.w	#4,d0                     | shift bits in high nibble of BCD number....
									  | to lower nibble.
	move.b	d0,d1                 | B now holds the number of red "10" flags to draw at the bottom right of the screen.
	and.w	#0xFF,d1
	subq.w	#1,d1
	move.b	#0x10,d2              | C is a count of how much space, in characters, we have to plot flags. We start with #0x10 (16 decimal) 
2:
	move.b	#0x68,d0               | ordinal of first character of "10" flag to plot
	jbsr	PLOT_CHARACTERS_2_BY_2_ASCENDING               | plot the flag with "10" on it
	subq.b	#2,d2                   | A "10" flag takes up 2 spaces..
									| ..so reduce C by 2.
	dbf		D1,2b               | repeat until B==0
3:
      move.w	(a7)+,d0

* Calculate how many normal red flags we are going to draw
* A=level number in BCD
    and.b  #0x0F,d0                 | mask in lower nibble of BCD number. Now A represents how many flags we are going to draw.
	moveq	#0,d1
	move.w	#0x1F,d3           | offset to add to HL after every flag drawn.
    move.b	d0,d1                 | B = number of flags to draw
	beq.b	5f				             | if we don't have any flags to draw then goto 0x2562
	subq.b	#1,d1
4:
    move.b	#0x6C,d0               | ordinal of first character to plot
    jbsr PLOT_TWO_CHARS_ON_SAME_ROW               | draw the normal flag on character map
    subq.b	#1,d2                   | A normal flag takes up just 1 character space, so reduce C by 1
    dbf		d1,4b               | repeat until B == 0
5:
* if we get here, we want to erase any flags left from the previous level
    subq.b	#1,d2              | decrement "space for characters remaining" count in C
    bpl.b	6f                   | return if c has become a negative value. 
	rts
6:
    jbsr	l_259E               | plot spaces to overwrite any existing flags
    bra.b	5b


AWARD_EXTRA_LIFE:
	move.b	CURRENT_PLAYER,d0                       	| load CURRENT_PLAYER into A [ld   a,(0x400D)]
	lea	PLAYER_ONE_AWARDED_EXTRA_LIFE,a0                      	| load HL with address of PLAYER_ONE_AWARDED_EXTRA_LIFE flag. [ld   hl,0x40AD]
	add.w	d0,a0                   	| Now HL points to either PLAYER_ONE_AWARDED_EXTRA_LIFE or PLAYER_TWO_AWARDED_EXTRA_LIFE
	tst.b	(a0)                         	| Test if current player has already had a bonus live given to them. [bit  0,(hl)]
	beq.b	0f
	rts                                    	| if flag is set, then return. Player gets no more extra lives. [ret  nz]
0:

* player awarded extra life
	move.b	#0x01,(a0)                      	| Set "Player has had his extra life" flag [ld   (hl),0x01]
	move.b	#0x01,d0                        	| [ld   a,0x01]
	move.b	d0,PLAY_EXTRA_LIFE_SOUND                       	| set PLAY_EXTRA_LIFE_SOUND flag. [ld   (0x41C7),a]
	lea	PLAYER_LIVES,a0                      	| pointer to PLAYER_LIVES [ld   hl,0x421D]
	addq.b	#1,(a0)                         	| increment number of lives [inc  (hl)]
	move.b	(a0),d1                         	| read number of player lives into B [ld   b,(hl)]

DISPLAY_PLAYER_SHIPS_REMAINING:
	move.w	#0x539E,d6          | address in character RAM [ld   hl,0x539E]
	move.b	#0x05,d2                        	| [ld   c,0x05]
	tst.b	HAS_PLAYER_SPAWNED                       	| read HAS_PLAYER_SPAWNED [ld   a,(0x4200)]
	                           	| test if flag is set [and  a]
	jeq	l_22c1                             	| [jr   z,0x22C1]
	subq.b	#1,d1                           	| [dec  b]
	jeq	l_22c9                             	| [jr   z,0x22C9]
l_22c1:
	move.b	#0x66,d0                        	| [ld   a,0x66]
	jbsr	l_2593                            	| plot 2X2 characters [call 0x2593]
	subq.b	#1,d2                           	| [dec  c]
	subq.b	#1,d1                           	| [...]
	jne	l_22c1                             	| [djnz 0x22C1]
l_22c9:
	subq.b	#1,d2                           	| [dec  c]
	bpl.b	0f
	rts                                    	| [ret  m]
0:
	jbsr	PLOT_CHARACTERS_2_BY_2_DESCENDING     	| plot spaces to screen [call 0x2591]
	jra	l_22c9                             	| [jr   0x22C9]
	
	

* Called to display "BAD RAM [n]" or "BAD ROM [n]""
* (just to debug our font engine!!)
DISPLAY_BAD_RAM_OR_ROM_MESSAGE:
	lea		bad_rom(pc),a0
	move.w	#0x5233,d6            | character RAM address to print text at
	move.w	#0x20,d2
	move.w	#6,d3               | there's 7 characters in "BAD RAM" (including the space between words)
0:
	move.b	(a0)+,d0
	jbsr	osd_w_bg_videoram
	add.w	d2,d6
	dbf		d3,0b
1:
	bra.b	1b

l_2583:
	move.b	#0x2C,d0               | space character

*
* Draw 4 characters in a 2 x 2 layout. 
*
* register A is the ordinal of the first character to draw. 
* The next 3 characters are derived automatically by incrementing A after each character drawn.
*
* Expects:
* A (D0) = ordinal of first character to poke to character RAM. 
* HL (D6) = pointer to character RAM address
* 
* Resulting layout is:
*
* A   |  A+1
* ----------
* A+2 |  A+3
*

PLOT_CHARACTERS_2_BY_2_ASCENDING:
      move.w	D3,-(a7)
      move.w	#0x001F,d3            | load de with 31 decimal. This is the width of a row, in characters, minus 1.
      jbsr PLOT_TWO_CHARS_ON_SAME_ROW               | plot 2 characters on same row... 
l_258C:
      jbsr PLOT_TWO_CHARS_ON_SAME_ROW               | and 2 characters on the next row 
      move.w	(a7)+,d3
      rts


*
* Draw 4 characters in a 2 x 2 layout. 
*
* register A is the ordinal of the first character to draw. 
*
* Expects:
* A = ordinal of first character to poke to character RAM. 
* HL = pointer to character RAM address
* 
* Resulting layout is:
*
* A-2 |  A-1
* ----------
* A   |  A+1

PLOT_CHARACTERS_2_BY_2_DESCENDING:
	move.b	#0x2E,d0
l_2593:
    move.w	D3,-(a7)
PLOT_2X2_CHARACTERS:
	move.w	#-33,d3		| load de with -33 decimal as signed word
	jbsr	PLOT_TWO_CHARS_ON_SAME_ROW               | plot 2 characters on one row..	
	subq.b	#4,d0		| subtract 4 from A
	bra.b	l_258C		| plot 2 characters on row above


l_259E:
	move.b	#0x2C,d0               | space character
*
* Plots 2 contiguous characters on same row
* register A is the ordinal of the first character to draw. A+1 is drawn in the next column.
*
* Expects:
* A = ordinal of first character to plot
* HL = pointer to character RAM where first character will be plotted
* DE = offset to add to HL after both characters have been plotted
*
* Returns:
* HL = updated pointer to character RAM
*

PLOT_TWO_CHARS_ON_SAME_ROW:
   jbsr		osd_w_bg_videoram              | plot first character
   addq.b  #1,d0                   | increment A
   addq.w	#1,d6                  | bump HL to next address in RAM
   jbsr		osd_w_bg_videoram     | plot second character
   addq.b  #1,d0
   add.w	d3,d6               | add offset in DE to HL
   rts

l_25a7:
	move.b	#0x2C,d0

*
* Plots 2 characters in the same column, one beneath the other.
*
* register A is the ordinal of the first character to draw. A+2 is drawn in the same column of the row beneath.
*
* Expects:
* A (D0) = ordinal of first character to plot
* HL (D6) = pointer to character RAM where first character will be plotted
*

PLOT_TWO_CHARACTERS_IN_SAME_COLUMN:
	move.w	d3,-(a7)
	move.w	#0x20,d3      | each row is comprised of 0x20 (32 decimal) characters...
	jbsr	osd_w_bg_videoram           | plot first character
	addq.b	#2,d0
	add.w	d3,d6                      | bump HL to point to the character at the row beneath
	jbsr	osd_w_bg_videoram              | plot second character
	move.w	(a7)+,d3
	rts

*
* Convert value in register A to BCD equivalent 
* 
* For example, if you pass in 0x63 (99 decimal) in A, this function will return 99 BCD
* 
* Expects:
* d0 = non BCD value, from 0..99
*
* Returns:
* d0 = BCD equivalent
* 
* the Z80 code is pretty convoluted, but I don't understand why. Just create a table: done

CONVERT_A_TO_BCD:
	lea		bcd_table(pc),a0
	and.w	#0x7f,d0		| could read out the table if > 99 but who cares?
	move.b	(a0,d0.w),d0
	rts
	
** those routines were converted semi-automatically with my z80268k tool
** I wish I had written this tool slightly earlier

*
* This routine sets the following flags:
*
* ALIEN_IN_COLUMN_FLAGS
* HAVE_ALIENS_IN_6TH_ROW
* HAVE_ALIENS_IN_5TH_ROW
* HAVE_ALIENS_IN_4TH_ROW
* HAVE_ALIENS_IN_3RD_ROW
* HAVE_ALIENS_IN_2ND_ROW
* HAVE_ALIENS_IN_TOP_ROW
* HAVE_NO_BLUE_OR_PURPLE_ALIENS
* HAVE_NO_ALIENS_IN_SWARM
* HAVE_NO_INFLIGHT_ALIENS
* HAVE_NO_INFLIGHT_OR_DYING_ALIENS
*
* It also sets the values for SWARM_SCROLL_MAX_EXTENTS.

SET_ALIEN_PRESENCE_FLAGS:     | TENTATIVE NAME - If anyone can think of anything better, give me a shout
	moveq	#0,d0                            	| [xor  a]
	lea	NEVER_USED_ROW_1,a1                      	| [ld   de,0x41E8]
	move.b	d0,(a1)+                         	| clear 0x41E8 [ld   (de),a]
	move.b	d0,(a1)+                         	| clear 0x41E9 [ld   (de),a]
												| DE now = 0x41EA (address of HAVE_ALIENS_IN_IN_ROW_FLAGS) [inc  e]

* This part of the code determines if there are any aliens on a given row.
* It will set the corresponding flag in the HAVE_ALIENS_IN_ROW_FLAGS array.
* it works from the bottom row of aliens to the top.
	move.b	#0x06,d2                        	| there are 6 rows of aliens. Used as a row counter. [ld   c,0x06]
	lea	ALIEN_SWARM_FLAGS+0x23,a0           | pointer to bottom right alien in ALIEN_SWARM_FLAGS [ld   hl,0x4123]

l_099b:
	move.b	#0x0A,d1                        	| There's 0x0A (10 decimal) aliens max per row [ld   b,0x0A]
	moveq	#0,d0                            	| clear A. [xor  a]
l_099e:
	or.b	(a0)+,d0                           	| If an alien is present, A will now be set to 1. [or   (hl)]
	subq.b	#1,d1                           	| [...]
	jne	l_099e                             	| repeat tests until B == 0. [djnz 0x099E]

	move.b	d0,(a1)+                         	| store alien presence flag in HAVE_ALIENS_IN_[]_ROW flag [ld   (de),a]
												| bump DE to point to next HAVE_ALIENS_IN_[]_ROW flag [inc  e]
	add.w	#6,a0                           	| Add 6 to HL. Now HL points to flags for row of aliens above previous
	subq.b	#1,d2                           	| decrement row counter [dec  c]
	jne	l_099b                              	| if not all rows of aliens have been processed, goto 0x099B [jp   nz,0x099B]

* when we get here, DE points to 0x41F0, which is the start of the ALIEN_IN_COLUMN_FLAGS array.
	clr.b	(a1)+                         	| clear first entry of ALIEN_IN_COLUMN_FLAGS. [ld   (de),a]
	clr.b	(a1)+                         	| clear second entry of ALIEN_IN_COLUMN_FLAGS. [ld   (de),a]
	clr.b	(a1)+                         	| clear second entry of ALIEN_IN_COLUMN_FLAGS. [ld   (de),a]

	lea	ALIEN_SWARM_FLAGS+0x23,a0                      	| pointer to bottom right alien in ALIEN_SWARM_FLAGS [ld   hl,0x4123]
	move.b	#0x0A,d2                        	| There's 0x0A (10 decimal) columns of aliens [ld   c,0x0A]

* Working from the rightmost column of aliens to the left, check each column for presence of aliens and
* set/clear respective flag in ALIEN_IN_COLUMN_FLAGS array accordingly.
l_09b8:
	move.b	#0x06,d1                        	| 6 rows of aliens. Used as a row counter. [ld   b,0x06]
	moveq	#0,d0 	| [xor  a]
l_09bf:
	or.b	(a0),d0                           	| If an alien is present, A will now be set to 1. [or   (hl)]
	add.w	#0x10,a0							| Point HL to alien in row above, same column.
	subq.b	#1,d1                           	| [...]
	jne	l_09bf                              	| Repeat until all 6 rows of aliens have been scanned [djnz 0x09BF]

	move.b	d0,(a1)+                         	| set/clear flag in ALIEN_IN_COLUMN_FLAGS [ld   (de),a]
												| bump DE to point to next entry in ALIEN_IN_COLUMN_FLAGS [inc  e]

* we've scanned all the aliens in a column.
* We now want to scan the next column of aliens to the immediate *left* of the column we just scanned.
	sub.w	#0x5F,a0                           	| now HL points to bottom alien in next column of aliens to check
	subq.b	#1,d2                           	| decrement counter for number of columns left to process [dec  c]
	jne	l_09b8                             	| if we've not done all the columns, goto 0x09B8 [jp   nz,0x09B8]

* the following code works out how far to the left the swarm can move. Or should I say, how far the swarm can be scrolled down.
* TODO: I'll come back to this code later, but at the moment there's bigger fish to fry with this game, so I'll just leave bare bones here.
	lea	ALIEN_IN_COLUMN_FLAGS+0xc,a0      	| load HL with a pointer to flag for the leftmost column of aliens in ALIEN_IN_COLUMN_FLAGS [ld   hl,0x41FC]
	move.b	#0x0A,d1                        	| There's 0x0A (10 decimal) columns of aliens [ld   b,0x0A]
	move.b	#0x22,d3				| [ld   e,0x22]
l_09d5:
	tst.b	(a0)                         	| Test the flag. Is there an alien in the column? [bit  0,(hl)]
	jne	l_09e2                             	| yes, goto 0x09E2 [jr   nz,0x09E2]
	subq.w	#1,a0                            	| bump HL to point to flag for column to left [dec  l]
	add.b	#0x10,d3                         	| [add  a,0x10]
	subq.b	#1,d1                           	| [...]
	jne	l_09d5                             	| [djnz 0x09D5]

* now work out how far to the right the swarm can move.
	move.b	#0x22,d3				| [ld   e,0x22]
l_09e2:
	lea	ALIEN_IN_COLUMN_FLAGS+3,a0    	 	| load HL with a pointer to flag for the rightmost column of aliens in ALIEN_IN_COLUMN_FLAGS [ld   hl,0x41F3]
	move.b	#0x0A,d1                        	| There's 0x0A (10 decimal) columns of aliens [ld   b,0x0A]
	and.w	#0xFF,d3
	or.w	#0xE000,d3			| [ld   d,0xE0]
l_09e9:
	tst.b	(a0)                         	| Test the flag. Is there an alien in the column? [bit  0,(hl)]
	jne	l_09f6                             	| yes, goto 0x09F6 [jr   nz,0x09F6]
	addq.w	#1,a0                            	| [inc  l]
	sub.w	#0x1000,d3                         	| [sub  0x10]
	subq.b	#1,d1                           	| [...]
	jne	l_09e9                             	| [djnz 0x09E9]
	* not found? reload to max
	and.w	#0xFF,d3
	or.w	#0xE000,d3				| 	[ld   d,0xE0]
l_09f6:
	move.w	d3,SWARM_SCROLL_MAX_EXTENTS                       	| set SWARM_SCROLL_MAX_EXTENTS [ld   (0x4210),de]

* Check if any of the bottom 4 rows of aliens (blue & purple) have any aliens in them. *Aliens from those rows that are in flight don't count*
	lea	HAVE_ALIENS_IN_6TH_ROW,a0                      	| load HL with pointer to HAVE_ALIENS_IN_6TH_ROW [ld   hl,0x41EA]
	move.b	#0x01,d2                        	| [ld   c,0x01]
	move.b	#0x04,d1                        	| we want to do 4 rows of aliens [ld   b,0x04]
	moveq	#0,d0                            	| [xor  a]
l_0a02:
	or.b	(a0)+,d0                           	| test if there's an alien present on the row [or   (hl)]
												| bump HL to point to flag for row above [inc  l]
	subq.b	#1,d1                           	| [...]
	jne	l_0a02                             	| repeat until b==0 [djnz 0x0A02]
	eor.b	d2,d0                            	| [xor  c]
	move.b	d0,HAVE_NO_BLUE_OR_PURPLE_ALIENS                       	| set HAVE_NO_BLUE_OR_PURPLE_ALIENS flag [ld   (0x4221),a]

* HL = pointer to HAVE_ALIENS_IN_2ND_ROW
	eor.b	d2,d0                            	| if A was 1, set it to 0, and vice versa [xor  c]
	or.b	(a0)+,d0                           	| if any aliens in red row set A to 1  *Red aliens in flight don't count* [or   (hl)]
											| bump HL to point to HAVE_ALIENS_IN_TOP_ROW [inc  l]
	or.b	(a0),d0                           	| if any aliens in flagship row set A to 1   *Flagships that are in flight don't count* [or   (hl)]
	eor.b	d2,d0                            	| if A was 1, set it to 0, and vice versa [xor  c]
	move.b	d0,HAVE_NO_ALIENS_IN_SWARM         	| set/reset HAVE_NO_ALIENS_IN_SWARM flag. [ld   (0x4220),a]

* Check if we have any aliens "in-flight" attacking the player.
* We skip the first entry in the INFLIGHT_ALIENS array because the first entry is reserved for misc use (see docs above INFLIGHT_ALIEN struct)
* and should not be treated as a "real" flying alien.
	lea	INFLIGHT_ALIENS+inflight_alien_size,a0    | pointer to INFLIGHT_ALIENS_START+sizeof(INFLIGHT_ALIEN). Effectively skipping first INFLIGHT_ALIEN. [ld   hl,0x42D0]
	move.w	#inflight_alien_size,d3                      	| sizeof(INFLIGHT_ALIEN) [ld   de,0x0020]
	move.b	#0x07,d1                        	| 7 aliens to process in the list [ld   b,0x07]
	moveq	#0,d0                            	| clear A [xor  a]
l_0a1b:
	or.b	(a0),d0                           	| Set A to 1 if alien is active [or   (hl)]
	add.w	d3,a0								| bump HL to point to next INFLIGHT_ALIEN structure in the array
	subq.b	#1,d1                           	| [...]
	jne	l_0a1b                             	| repeat until B==0 [djnz 0x0A1B]
	eor.b	d2,d0                            	| if no aliens are in flight, A will be set to 1.  Else A is set 0. [xor  c]
	move.b	d0,HAVE_NO_INFLIGHT_ALIENS                       	| set/reset HAVE_NO_INFLIGHT_ALIENS flag [ld   (0x4226),a]

* Check if we have any aliens "in-flight" or dying
	eor.b	d2,d0                            	| [xor  c]
	lea	INFLIGHT_ALIENS+1,a0                      	| pointer to first IsDying flag of INFLIGHT_ALIENS array. [ld   hl,0x42B1]
	move.b	#0x08,d1                        	| test all 8 slots [ld   b,0x08]
l_0a29:
	or.b	(a0),d0                           	| if INFLIGHT_ALIEN.IsDying is set to 1, set A to 1. [or   (hl)]
	add.w	d3,a0								| bump HL to point to next INFLIGHT_ALIEN structure in the array
	subq.b	#1,d1                           	| [...]
	jne	l_0a29                             	| repeat until B==0 [djnz 0x0A29]
	eor.b	d2,d0                            	| [xor  c]
	move.b	d0,HAVE_NO_INFLIGHT_OR_DYING_ALIENS                       	| set/reset HAVE_NO_INFLIGHT_OR_DYING_ALIENS [ld   (0x4225),a]
	rts



HANDLE_PLAYER_SHOOT:
	tst.b	HAS_PLAYER_SPAWNED                       	| read HAS_PLAYER_SPAWNED flag [ld   a,(0x4200)]
	bne.b	0f
	rts                                    	| if player has not spawned, return [ret  nc]
0:
	tst.b	HAS_PLAYER_BULLET_BEEN_FIRED                       	| read HAS_PLAYER_BULLET_BEEN_FIRED flag [ld   a,(0x4208)]
	beq.b	0f
	rts                                    	| if carry is set, missile has already been fired, can't shoot again. [ret  c]
0:
	tst.b	IS_GAME_IN_PLAY                       	| read IS_GAME_IN_PLAY flag [ld   a,(0x4006)]
	jeq	l_0a68                             	| if no carry, game is not in play, so this is demo mode, goto 0x0A68 [jr   nc,0x0A68]

	move.b	PREV_PORT_STATE_6000,d0                       	| read PREV_PORT_STATE_6000 [ld   a,(0x4013)]
	not.b	d0                               	| [cpl]
	move.b	d0,d1                           	| [ld   b,a]
	move.b	PORT_STATE_6000,d0                       	| read PORT_STATE_6000 [ld   a,(0x4010)]
l_0a50:
	and.b	d1,d0                            	| [and  b] (first time shot)
	and.b	#0x10,d0                         	| test state of SHOOT button [and  0x10]
	bne.b	0f
	rts                                    	| return if not held down [ret  z]
0:
	move.b	#0x01,d0                        	| [ld   a,0x01]
	move.b	d0,HAS_PLAYER_BULLET_BEEN_FIRED                       	| set HAS_PLAYER_BULLET_BEEN_FIRED flag [ld   (0x4208),a]
	move.b	d0,PLAY_PLAYER_SHOOT_SOUND                       	| set PLAY_PLAYER_SHOOT_SOUND flag [ld   (0x41CC),a]
	rts                                    	| [ret]

* We come here if it's player 2's turn and the game is in cocktail mode.
l_0a5d:
	move.b	PREV_PORT_STATE_6800,d0                       	| read PREV_PORT_STATE_6800 [ld   a,(0x4014)]
	not.b	d0                               	| [cpl]
	move.b	d0,d1                           	| [ld   b,a]
	move.b	PORT_STATE_6800,d0                       	| read PORT_STATE_6800 [ld   a,(0x4011)]
	jra	l_0a50                             	| go check if shoot button for player 2's controls is held down. [jp   0x0A50]


* We're in demo mode. We need to simulate the player firing at the aliens.
l_0a68:
	move.b	TIMING_VARIABLE,d0                       	| read TIMING_VARIABLE [ld   a,(0x425F)]
	and.b	#0x1F,d0                         	| mask in bits 0..5 [and  0x1F]
	beq.b	0f
	rts                                    	| if result is not zero, then return [ret  nz]
0:
	move.b	#0x01,d0                        	| [ld   a,0x01]
	move.b	d0,HAS_PLAYER_BULLET_BEEN_FIRED                       	| set HAS_PLAYER_BULLET_BEEN_FIRED flag [ld   (0x4208),a]
	rts                                    	| [ret]


*
* Move enemy bullets and position enemy bullet sprites
*
*
*

HANDLE_ENEMY_BULLETS:
	lea	ENEMY_BULLETS_START,a2                      	| load IX with address of ENEMY_BULLETS_START [ld   ix,0x4260]
	move.b	TIMING_VARIABLE,d0                       	| read TIMING_VARIABLE [ld   a,(0x425F)]
	ror.b	#1,d0                           	| move bit 0 into carry [rrca]
	jcs	l_0a89                             	| if TIMING_VARIABLE is an odd number, goto 0x0A89 [jr   c,0x0A89]
	addq.b	#2,(0x01,a2)                    	| Increment ENEMY_BULLET.X by 2.. [inc  (ix+0x01) * 2]

	move.w	#5,d3                      	| sizeof(ENEMY_BULLET) [ld   de,0x0005]
	add.w	d3,a2
l_0a89:
	lea	OBJRAM_BACK_BUF_BULLETS,a3                      	| pointer to OBJRAM_BACK_BUF_BULLETS [ld   iy,0x4081]
	move.b	#0x07,d1                        	| number of bullets [ld   b,0x07]

* main bullet loop
l_0a8f:
	tst.b	(0x00,a2)                    	| test ENEMY_BULLET.IsActive flag [bit  0,(ix+0x00)]
	jeq	l_0abc                             	| if enemy bullet is not active, goto 0x0ABC [jr   z,0x0ABC]
	move.b	(0x01,a2),d0                      	| read ENEMY_BULLET.X [ld   a,(ix+0x01)]
	addq.b	#0x02,d0                        	| bullet will move 2 pixels [add  a,0x02]
	move.b	d0,(0x01,a2)                    	| update ENEMY_BULLET.X [ld   (ix+0x01),a]
	addq.b	#0x04,d0                        	| tentatively add 4 to the X coordinate. If a carry occurs, enemy bullet is at bottom of screen [add  a,0x04]
	jcs	l_0abc                             	| enemy bullet is at bottom of screen so needs to be deactivated, goto 0x0ABC [jr   c,0x0ABC]

* split ENEMY_BULLET.YDelta into its sign and delta, then add to YH and YL respectively.
	move.b	(YH,a2),d6       	| read ENEMY_BULLET.YH
	lsl.w	#8,d6				| put in MSB
	move.b	(YL,a2),d6			| read ENEMY_BULLET.YL
	move.b	(YDelta,a2),d4		    | read ENEMY_BULLET.YDelta
	roxl.b	#1,d4      	| move bit 7 of E (sign bit) into carry. Shift YDelta bits left into bits 1..7. [rl e]
	subx.b  d0,d0                                	| A = 0 - carry
	move.b	d0,d3                                	| if bit 7 of E was set, D will be 0xFF, else 0.
	lsl.w	#8,d3
	move.b	d4,d3
	add.w	d3,d6
	move.b	d6,(YL,a2)                     	| set ENEMY_BULLET.YL [ld   (ix+0x02),l]
	lsr.w	#8,d6
	move.b	d6,(YH,a2)                     	| set ENEMY_BULLET.YH [ld   (ix+0x03),h]
	move.b	d6,d0                           	| get ENEMY_BULLET.YH coordinate into A [ld   a,h]
	add.b	#0x10,d0                         	| add #0x10 (16 decimal) . [add  a,0x10]
	cmp.b	#0x20,d0                         	| compare to 0x20 (32 decimal) [cp   0x20]
	jcc	l_0ac6                             	| if >= 32 decimal, bullet is still onscrene, goto 0x0AC6 [jr   nc,0x0AC6]

* bullet is offscreen, deactivate it
l_0abc:
	clr.b	(0x00,a2)                    	| set ENEMY_BULLET.IsActive flag (disables bullet) [ld   (ix+0x00),a]
	clr.b	(0x01,a2)                    	| set ENEMY_BULLET.X to 0 [ld   (ix+0x01),a]
	clr.b	(YH,a2)                    	| set ENEMY_BULLET.YH to 0 [ld   (ix+0x03),a]

* we now need to position the actual enemy bullet sprites.
l_0ac6:
	move.b	(1,a2),d0                      	| read ENEMY_BULLET.X [ld   a,(ix+0x01)]
    not.b   d0                                     	| A = (255 - A)
	subq.b	#1,d0                           	| A = A-1 [dec  a]
	move.b	d0,(0x02,a3)                    	| write to OBJRAM_BACK_BUF_BULLETS sprite state [ld   (iy+0x02),a]

* looks to me like there's a hardware "feature" where the Y coordinate of alien bullets 5-7 needs adjusted by 1 so the sprite is positioned correctly.
* if anyone can tell me why, drop me a line. Thanks!
	move.b	(YH,a2),d0                      	| read ENEMY_BULLET.YH [ld   a,(ix+0x03)]
    not.b   d0                                     	| A = (255 - A)
	move.b	d0,d2                           	| [ld   c,a]
	move.b	d1,d0                           	| get index of enemy bullet we are processing into A [ld   a,b]
	cmp.b	#0x05,d0                         	| are we processing bullet #5 or more? [cp   0x05]
	jcs	l_0adf                             	| no, goto 0x0ADF [jr   c,0x0ADF]
	addq.b	#1,d2                           	| adjust Y coordinate [inc  c]
l_0adf:
	move.b	d2,(0x00,a3)                    	| write to OBJRAM_BACK_BUF_BULLETS sprite Y coordinate [ld   (iy+0x00),c]

	move.w	#5,d3                      	| sizeof(ENEMY_BULLET) [ld   de,0x0005]
	add.w  d3,a2                              	| bump IX to point to next ENEMY_BULLET in ENEMY_BULLETS array
	addq.b	#2,(0x01,a2)                    	| increment ENEMY_BULLET.X [inc  (ix+0x01)]
											| twice, to make it move 2 pixels [inc  (ix+0x01)]

	add.w  d3,a2                            	| bump IX to point to next ENEMY_BULLET in ENEMY_BULLETS array
	subq.b	#1,d3                            	| DE is now 4 [dec  e]
	add.w  d3,a3                              	| bump IY to point to state of next sprite in OBJRAM_BACK_BUF_BULLETS
	subq.b	#1,d1                           	| [...]
	jne	l_0a8f                             	| repeat until B ==0 [djnz 0x0A8F]
	rts



*
* Check if the player's bullet has hit any aliens in the swarm.
* If so, delete the shot alien from the swarm, kick off a dying animation, and update player score with relevant points value.
*

HANDLE_SWARM_ALIEN_TO_PLAYER_BULLET_COLLISION_DETECTION:
	                     	| pointer to HAS_PLAYER_BULLET_BEEN_FIRED [ld   hl,0x4208]
	tst.b	HAS_PLAYER_BULLET_BEEN_FIRED       	| test bit 0. If it's set, player is shooting. [bit  0,(hl)]
	bne.b	0f
	rts                          		| if zero flag is set, that means player is not shooting. Return.
0:
	                           	| bump HL to point to PLAYER_BULLET_X [inc  hl] (done above with (a0)+)
	move.b	PLAYER_BULLET_X,d0                         	| read value of PLAYER_BULLET_X [ld   a,(hl)]
	cmp.b	#0x68,d0                         	| [cp   0x68]
	bcs.b	0f
	rts                                 	| if X coordinate >= #0x68 (104 decimal) then bullet is not near swarm yet, so exit
0:
	sub.b	#0x1E,d0                         	| if X coordinate < #0x1E (30 decimal) then bullet has passed the swarm, this subtraction will cause a carry.. [sub  0x1E]
	bcc.b	0f
	rts									|		| .. so exit.
0:

* OK, we have to check if an alien has been hit
	move.b	#0x06,d1                        	| number of rows of aliens [ld   b,0x06]
l_0b1b:
	subq.b	#0x07,d0                        	| [sub  0x07]
	bcc.b	0f
	rts
0:
	subq.b	#0x05,d0                        	| [sub  0x05]
	jcs	l_0b25                             	| [jr   c,0x0B25]
	subq.b	#1,d1                           	| [...]
	jne	l_0b1b                             	| [djnz 0x0B1B]
	rts

* B =  row index from 1 to 6. Identifies which row of aliens to check for player bullet collisions.
* 1 = blue row of aliens closest to player	| 6 = flagship row
* enters here when bullet reaches the swarm Y-zone
l_0b25:

	                           	| bump HL to point to PLAYER_BULLET_Y [inc  hl]
	move.b	SWARM_SCROLL_VALUE+1,d0                       	| read SWARM_SCROLL_VALUE [ld   a,(0x420E)]
	sub.b	PLAYER_BULLET_Y,d0                          	| [sub  (hl)]
	neg.b   d0
	move.b	d0,d2                           	| [ld   c,a]
	and.b	#0x0F,d0                         	| mask in low nibble [and  0x0F]
	subq.b	#0x02,d0                        	| [sub  0x02]
	cmp.b	#0x0B,d0                         	| [cp   0x0B]
	bcs.b	0f
	rts											| [ret  nc]
0:
	addq.b	#1,d1                           	| [inc  b]
	move.b	d2,d0                           	| [ld   a,c]
	and.b	#0xF0,d0                         	| mask in high nibble [and  0xF0]
	add.b	d1,d0                            	| [add  a,b]
	* JOTD: this isn't really a division by 16 but an actual bit rotation
	* to get proper offset in alien swarm table. How it works? I don't know and Scott
	* doesn't seem to have commented that part either :)
	* transcoding with equivalent instructions makes the bullet/swarm collision work, yay!
	ror.b	#4,d0                           	| [rrca]*4 rotate 4 bits to the right
	moveq	#0,d5
	move.b	d0,d5
											| DE is now an offset into the ALIEN_SWARM_FLAGS table
	lea	ALIEN_SWARM_FLAGS,a0            | load HL with address of ALIEN_SWARM_FLAGS [ld   hl,0x4100]
	add.w	d5,a0                              	| add offset to HL. Now HL points to a flag which determines if an alien is present
	tst.b	(a0)                         	| test flag. If bit 0 is set, our bullet has hit an alien. [bit  0,(hl)]
	bne.b	0f
	rts		                                  	| bit 0 is not set, we haven't shot an alien, so exit
0:
	clr.b	(a0)                          	| We've hit an alien! Clear flag to indicate alien is dead. [ld   (hl),d]
	move.w	#0x100,d3					    | command id for DELETE_ALIEN_COMMAND
	move.b	d5,d3                       	| parameter: index of alien to delete from swarm
	jbsr	QUEUE_COMMAND                            	| call QUEUE_COMMAND [call 0x08F2]
	move.b	#1,IS_PLAYER_BULLET_DONE                       	| set IS_PLAYER_BULLET_DONE flag to 1, so player can shoot again [ld   (0x420B),a]

* we'll use the misc entry in the INFLIGHT_ALIENS array to display our explosion as a sprite
	move.b	#1,INFLIGHT_ALIENS+IsDying                       	| set INFLIGHT_ALIEN.IsDying to 1 [ld   (0x42B1),a]
	clr.b	INFLIGHT_ALIENS+StageOfLife                       	| set INFLIGHT_ALIEN.StageOfLife to 0 [ld   (0x42B2),a]
	move.b	PLAYER_BULLET_X,INFLIGHT_ALIENS+inf_alien_X                       	| set INFLIGHT_ALIEN.X and INFLIGHT_ALIEN.Y  to bullet coordinates [ld   (0x42B3),hl]
	move.b	PLAYER_BULLET_Y,INFLIGHT_ALIENS+inf_alien_Y                       	| set INFLIGHT_ALIEN.X and INFLIGHT_ALIEN.Y  to bullet coordinates [ld   (0x42B3),hl]
	move.w	#0x300,d3					| command id for UPDATE_PLAYER_SCORE_COMMAND (see 0x08f2)
	move.b	d5,d3                           	| read index of alien that was just killed [ld   a,e]
	cmp.b	#0x50,d0                         	| was the alien killed in the bottom 3 ranks? (Blue aliens, most common type) [cp   0x50]
	jcs	l_0b72                             	| if index is < 0x50 (128 decimal) then yes, its a blue alien, goto 0x0B72 [jr   c,0x0B72]

* only get here if you've shot a higher-ranking alien
	and.b	#0x70,d0                         	| Mask out the column number of the killed alien from the index. [and  0x70]
* Now A is 0x50 (purple alien row),0x60 (red row),0x70 (flagship row)
	lsr.b	#4,d0                           	| Divide A by 16 decimal. [rrca]*4
	subq.b	#0x04,d0                        	| Subtract 4 to compute parameter for UPDATE_PLAYER_SCORE_COMMAND [sub  0x04]
	move.b	d0,d3								| set parameter for UPDATE_PLAYER_SCORE_COMMAND
	jra	QUEUE_COMMAND                             	| jump to QUEUE COMMAND. Player score will be updated. [jp   0x08F2]

* You've just shot a lowly blue alien.
l_0b72:
	clr.b	d3								| parameter for UPDATE_PLAYER_SCORE_COMMAND - adds 30 points to player score
	jra	QUEUE_COMMAND                       | jump to QUEUE COMMAND. Player score will be updated. [jp   0x08F2]


*
* Iterate through list of active enemy bullets and test if they have hit the player.
*

HANDLE_PLAYER_TO_ENEMY_BULLET_COLLISION_DETECTION:
	tst.b	HAS_PLAYER_SPAWNED                       	| read HAS_PLAYER_SPAWNED flag [ld   a,(0x4200)]
	bne.b	0f
	rts						| if carry is not set, then player has not spawned. Return.
0:
                   	
	lea	ENEMY_BULLETS_START,a2                      	| point IX to ENEMY_BULLETS_START [ld   ix,0x4260]
	move.w	#5,d3                      	| sizeof(ENEMY_BULLET) struct [ld   de,0x0005]
	move.b	#0x0E,d1                        	| length of ENEMY_BULLETS array [ld   b,0x0E]
l_0b85:
	jbsr	TEST_IF_ENEMY_BULLET_HIT_PLAYER                            	| call TEST_IF_ENEMY_BULLET_HIT_PLAYER [call 0x0B8D]
	add  d3,a2
	subq.b	#1,d1                           	| [...]
	jne	l_0b85                             	| [djnz 0x0B85]
	rts


*
* Check if an enemy bullet hit the player's ship.
*
* Expects:
* E = 5
* IX  = pointer to ENEMY_BULLET structure
*

TEST_IF_ENEMY_BULLET_HIT_PLAYER:
	tst.b	(0x00,a2)                    	| read ENEMY_BULLET.IsActive [bit  0,(ix+0x00)]
	bne.b	0f								| return if bullet is not active
	rts
0:
	move.b	(1,a2),d0                      	| read ENEMY_BULLET.X coordinate [ld   a,(ix+0x01)]
	add.b	#0x1F,d0                         	| player ship is 32 pixels high.. [add  a,0x1F]
	sub.b	d3,d0                             	| subtract 5 [sub  e]
	jcs	l_0baa                             	| [jr   c,0x0BAA]
	sub.b	#0x09,d0                         	| [sub  0x09]
	bcs.b	0f
	rts      | [ret nc]
0:
	move.b	PLAYER_Y,d0                       	| read PLAYER_Y [ld   a,(0x4202)]
	sub.b	(0x03,a2),d0                     	| subtract ENEMY_BULLET.Y coordinate [sub  (ix+0x03)]
	add.b	d3,d0                             	| add 5 [add  a,e]
	cmp.b	#0x0B,d0                         	| [cp   0x0B]
	bcs.b	0f
	rts			| [ret nc]
0:
	jra	l_0bb4                             	| bullet has hit player [jp   0x0BB4]
l_0baa:
	move.b	PLAYER_Y,d0                       	| read PLAYER_Y [ld   a,(0x4202)]
	sub.b	(0x03,a2),d0                     	| subtract ENEMY_BULLET.Y coordinate [sub  (ix+0x03)]
	addq.b	#0x02,d0                        	| [add  a,0x02]
	cmp.b	d3,d0
	bcs.b	0f
	rts  		| [ret nc]
0:
* Player's been hit.. deactivate enemy bullet and set hit flag.
l_0bb4:
	clr.b	(0x00,a2)                 	| clear ENEMY_BULLET.IsActive flag. [ld   (ix+0x00),0x00]
	move.b	#0x01,IS_PLAYER_HIT          		| set IS_PLAYER_HIT flag. Player will explode. [ld   (0x4204),a]
	rts


*
* Calculate the animation frame that makes an attacking alien "look" directly at the player.
*
* Expects:
* IX = pointer to INFLIGHT_ALIEN structure with valid X and Y fields.
*
* Returns:
*  INFLIGHT_ALIEN.AnimationFrame is updated
*

CALCULATE_INFLIGHT_ALIEN_LOOKAT_ANIM_FRAME:
	move.b	#0xF0,d0                        	| [ld   a,0xF0]
	sub.b	(0x03,a2),d0                     	| subtract from INFLIGHT_ALIEN.X [sub  (ix+0x03)]
	move.b	d0,d3			| CALCULATE_TANGENT parameter
	move.b	PLAYER_Y,d0                       	| read PLAYER_Y [ld   a,(0x4202)]
	sub.b	(inf_alien_Y,a2),d0                     	| subtract from INFLIGHT_ALIEN.Y [sub  (ix+0x04)]
	jcs	l_11c5                             	| [jr   c,0x11C5]
	jbsr	l_11d0                            	| [call 0x11D0]
	move.b	d0,(AnimationFrame,a2)                    	| set INFLIGHT_ALIEN.AnimationFrame [ld   (ix+0x05),a]
	rts                                    	| [ret]

l_11c5:
	neg.b	d0                               	| [neg]
	jbsr	l_11d0                            	| [call 0x11D0]
	neg.b	d0                               	| [neg]
	move.b	d0,(AnimationFrame,a2)                    	| set INFLIGHT_ALIEN.AnimationFrame [ld   (ix+0x05),a]
	rts                                    	| [ret]

l_11d0:
	jbsr	CALCULATE_TANGENT                            	| call CALCULATE_TANGENT [call 0x0048]
	move.b	d2,d0                          	| [ld   a,c]
	tst.b	d0                               	| [and  a]
	jpl	l_11da                             	| [jp   p,0x11DA]
	move.b	#0x80,d0                        	| [ld   a,0x80]
l_11da:
	rol.b	#3,d0                           	| [rlca]
	and.b	#0x07,d0                         	| [and  0x07]
	rts                                    	| [ret]


*
* Try to spawn an enemy bullet.
*
* Expects:
* IX = pointer to INFLIGHT_ALIEN struct
*
* Cheat:
* If you want to stop the aliens from firing, type the following into the MAME debugger:
* maincpu.mb@11E0 =,0xC9

TRY_SPAWN_ENEMY_BULLET:
	move.w	#5,d3                      	| sizeof(ENEMY_BULLET) [ld   de,0x0005]
	lea	ENEMY_BULLETS_START,a0                      	| load HL with address of ENEMY_BULLETS_START [ld   hl,0x4260]
	move.b	#0x0E,d1                        	| there are 14 elements in the ENEMY_BULLETS_START array [ld   b,0x0E]
l_11e8:
	tst.b	(a0)                         	| test if bullet is active [bit  0,(hl)]
	jeq	SPAWN_ENEMY_BULLET                             	| if its not active, then we can use this slot to spawn an enemy bullet, goto 0x11F0 [jr   z,0x11F0]
	add  d3,a0                              	| otherwise bump HL to point to next enemy bullet in the array
	subq.b	#1,d1                           	| [...]
	jne	l_11e8                             	| repeat until B==0 [djnz 0x11E8]
	rts                                    	| [ret]


*
* Spawn an enemy bullet.
*
* Expects:
* IX/A2 = pointer to INFLIGHT_ALIEN structure. Identifies the alien firing the bullet.
* HL/A0 = pointer to ENEMY_BULLET structure. Contains info about the spawned bullet.
*

SPAWN_ENEMY_BULLET:
	move.b	#0x01,(a0)+                      	| set ENEMY_BULLET.IsActive to 1 (true) [ld   (hl),0x01]
												| bump HL to point to ENEMY_BULLET.X [inc  hl]
	move.b	(inf_alien_X,a2),d0       	| read INFLIGHT_ALIEN.X coordinate [ld   a,(ix+0x03)]
	move.b	d0,(a0)                         	| set X coordinate of bullet to be same as alien [ld   (hl),a]
	move.b	#0xF0,d0                        	| load A with -16 (decimal) [ld   a,0xF0]
	sub.b	(a0),d0                          	| A = X coordinate of bullet + 16 [sub  (hl)]
	move.b	d0,d3								| parameter for CALCULATE_TANGENT  [ld   d,a]
	addq.w	#2,a0								| bump HL to point to ENEMY_BULLET.YH [inc  hl]
	move.b	(inf_alien_Y,a2),d0                      	| read INFLIGHT_ALIEN.Y  coordinate [ld   a,(ix+0x04)]
	move.b	d0,(a0)+                         	| set Y coordinate of bullet to be same as alien [ld   (hl),a]
												| bump HL to point to ENEMY_BULLET.YDelta [inc  hl]
	move.b	PLAYER_Y,d0                 	| read PLAYER_Y [ld   a,(0x4202)]
	sub.b	(inf_alien_Y,a2),d0             | subtract from INFLIGHT_ALIEN.Y  coordinate [sub  (ix+0x04)]
	jcs	l_120f                             	| [jr   c,0x120F]
	jbsr	COMPUTE_ENEMY_BULLET_DELTA                            	| call COMPUTE_ENEMY_BULLET_DELTA [call 0x1218]
	move.b	d0,(a0)                         	| set ENEMY_BULLET.YDelta [ld   (hl),a]
	rts                                    	| [ret]


l_120f:
	neg.b	d0                               	| A = Math.Abs(A) [neg]
	jbsr	COMPUTE_ENEMY_BULLET_DELTA                            	| call COMPUTE_ENEMY_BULLET_DELTA [call 0x1218]
	neg.b	d0                               	| make bullet fly to right [neg]
	move.b	d0,(a0)                         	| set ENEMY_BULLET.YDelta [ld   (hl),a]
	rts                                    	| [ret]


*
* Unlike the player's bullet, enemy bullets don't always fly in a straight line.
*
* expects D (D3) and A (D0) for CALCULATE_TANGENT
*
COMPUTE_ENEMY_BULLET_DELTA:
	jbsr	CALCULATE_TANGENT                            	| call CALCULATE_TANGENT [call 0x0048]
	jbsr	GENERATE_RANDOM_NUMBER                            	| call GENERATE_RANDOM_NUMBER [call 0x003C]
	and.b	#0x1F,d0                         	| clamp number to 0..31 decimal [and  0x1F]
	add.b	d2,d0                            	| [add  a,c]
	addq.b	#0x06,d0                        	| [add  a,0x06]
	bmi.b	0f
	rts                                    	| [ret  p]
0:
	move.b	#0x7F,d0                        	| [ld   a,0x7F]
	rts                                    	| [ret]




HANDLE_INFLIGHT_ALIEN_TO_PLAYER_BULLET_COLLISION_DETECTION:
	tst.b	HAS_PLAYER_BULLET_BEEN_FIRED                           	| move flag into carry [rrca]
	bne.b	0f
	rts                                    	| return if player is not shooting [ret  nc]
0:
	lea	INFLIGHT_ALIENS+inflight_alien_size,a2                      	| pointer to second inflight alien [ld   ix,0x42D0]
	move.w	#6,d1                        	| length of INFLIGHT_ALIENS array minus one [ld   b,0x07]
l_1235:
	jbsr	TEST_IF_PLAYER_BULLET_HIT_INFLIGHT_ALIEN                  	| call TEST_IF_PLAYER_BULLET_HIT_INFLIGHT_ALIEN [call 0x123F]
	add.w	#inflight_alien_size,a2                              	| bump IX to point to next INFLIGHT_ALIEN
	dbf		d1,l_1235                             	| [djnz 0x1235]
	rts                                    	| [ret]


*
* Player bullet to attacking alien collision detection.
*
* IX = pointer to INFLIGHT_ALIEN structure
*

TEST_IF_PLAYER_BULLET_HIT_INFLIGHT_ALIEN:
	tst.b	(IsActive,a2)                    	| Test INFLIGHT_ALIEN.IsActive flag [bit  0,(ix+0x00)]
	bne.b	0f
	rts                                    	| return if not set [ret  z]
0:
	move.b	(inf_alien_X,a2),d0                      	| read INFLIGHT_ALIEN.X [ld   a,(ix+0x03)]
	sub.b	PLAYER_BULLET_X,d0                             	| subtract from value of PLAYER_BULLET_X [sub  l]
	addq.b	#0x02,d0                        	| [add  a,0x02]
	cmp.b	#0x06,d0                         	| [cp   0x06]
	bcs.b	0f
	rts                                    	| [ret  nc]
0:
	move.b	(inf_alien_Y,a2),d0                      	| read INFLIGHT_ALIEN.Y [ld   a,(ix+0x04)]
	sub.b	PLAYER_BULLET_Y,d0                             	| subtract from value of PLAYER_BULLET_Y [sub  h]
	addq.b	#0x05,d0                        	| [add  a,0x05]
	cmp.b	#0x0C,d0                         	| [cp   0x0C]
	bcs.b	0f
	rts                                    	| [ret  nc]
0:

* if we get here, the player bullet has hit an alien inflight.
	move.b	#0x01,IS_PLAYER_BULLET_DONE   	| set IS_PLAYER_BULLET_DONE to 1. [ld   (0x420B),a]
l_125e:
	move.b	#0x00,(IsActive,a2)                 	| set INFLIGHT_ALIEN.IsActive to 0. [ld   (ix+0x00),0x00]
	move.b	#0x01,(IsDying,a2)                 	| set INFLIGHT_ALIEN.IsDying to 1. [ld   (ix+0x01),0x01]
	move.b	#0x00,(StageOfLife,a2)                 	| set INFLIGHT_ALIEN.StageOfLife to 0. [ld   (ix+0x02),0x00]
	move.w	#0x0304,d3                      	| command ID: UPDATE_PLAYER_SCORE_COMMAND, parameter: 4 [ld   de,0x0304]

* We now need to identify what rank this alien is so we can add its points value to the player score.
	move.b	#3,d1
	move.b	#0x50,d2			        	| B= count, C = index into ALIEN_SWARM_FLAGS array to compare against
	move.b	(IndexInSwarm,a2),d0             | load a with INFLIGHT_ALIEN.IndexInSwarm to find out what rank this alien is. [ld   a,(ix+0x07)]
l_1273:
	cmp.b	d2,d0                            	| compare A with 0x50 (80 decimal) [cp   c]
	jcs		QUEUE_COMMAND                             	| if A<0x50 jump to QUEUE_COMMAND with command ID: UPDATE_PLAYER_SCORE_COMMAND [jp   c,0x08F2]
	addq.b	#1,d3                            	| increment parameter passed to command - giving a higher score value [inc  e]
	sub.b	#0x10,d0                         	| subtract 10 (16 decimal) to "go down" a rank [sub  0x10]
	subq.b	#1,d1                           	| [...]
	jne	l_1273                             	| repeat until B==0. Only flagships will go to B==0. [djnz 0x1273]

* If we get here, we've shot an attacking flagship.
* First we activate a timer that prevents aliens from leaving the swarm for a while. This simulates the swarm being "stunned".
* We then calculate how many of the flagships escorts have been killed so we can update the player score accordingly.
* For max points, a flagship must have 2 escorts and the escorts must be killed before the flagship.
	move.b	#1,IS_FLAGSHIP_HIT
	move.b	#0xF0,ALIENS_IN_SHOCK_COUNTER    	| set IS_FLAGSHIP_HIT to 1, and ALIENS_IN_SHOCK_COUNTER to 0xF0 (240 decimal) [ld   (0x422B),hl]
	move.b	FLAGSHIP_ESCORT_COUNT,d0                       	| read FLAGSHIP_ESCORT_COUNT [ld   a,(0x422A)]
	cmp.b	#0x02,d0                         	| do we have 2 aliens escorting the flagship? [cp   0x02]
	bne.b	0f
	jbsr	ASSERT_BOTH_FLAGSHIP_ESCORTS_ARE_ALIVE                                 	| yes, call ASSERT_BOTH_FLAGSHIP_ESCORTS_ARE_ALIVE [call z,0x1292]
0:
	move.b	d0,FLAGSHIP_SCORE_FACTOR            | set FLAGSHIP_SCORE_FACTOR. If 3, then you get full points for killing the flagship + escort. [ld   (0x422D),a]
	add.b	d3,d0                             	| [add  a,e]
	move.b	d0,d3							| set command parameter
	jra	QUEUE_COMMAND                    	| QUEUE_COMMAND with command ID: UPDATE_PLAYER_SCORE_COMMAND [jp   0x08F2]

* We need to test if both the flagship's escorts are alive.
* If both are dead, then when this function returns, A will be set to 3.
ASSERT_BOTH_FLAGSHIP_ESCORTS_ARE_ALIVE:
	tst.b	(0x20,a2)                    	| test if first escort is alive [bit  0,(ix+0x20)]
	beq.b	0f
	rts                                    	| return if alive [ret  nz]
0:
	tst.b	(0x40,a2)                    	| test if second escort is alive [bit  0,(ix+0x40)]
	beq.b	0f
	rts                                    	| return if alive [ret  nz]
0:

* both escorts have been killed (or the flagship didn't have 2 escorts to start with)
	addq.b	#1,d0                           	| both [inc  a]
	rts                                    	| [ret]


*
* Iterate through list of inflight aliens and test if they have hit the player.
*

HANDLE_PLAYER_TO_INFLIGHT_ALIEN_COLLISION_DETECTION:
	move.b	HAS_PLAYER_SPAWNED,d0                       	| read HAS_PLAYER_SPAWNED [ld   a,(0x4200)]
	ror.b	#1,d0                           	| move flag into carry [rrca]
	bcs.b	0f
	rts                                    	| return if carry not set [ret  nc]
0:
	lea	INFLIGHT_ALIENS,a2                      	| pointer to INFLIGHT_ALIENS[1] [ld   ix,0x42D0]
	move.b	#0x07,d1                        	| 7 aliens to test collision with [ld   b,0x07]
l_12ac:	
	move.w	d1,-(a7)
	jbsr	TEST_IF_INFLIGHT_ALIEN_HIT_PLAYER                            	| call TEST_IF_INFLIGHT_ALIEN_HIT_PLAYER [call 0x12B6]
	move.w	(a7)+,d1
	add.w	#inflight_alien_size,a2                              	| bump IX to point to next INFLIGHT_ALIEN in array
	subq.b	#1,d1                           	| [...]
	jne	l_12ac                             	| repeat until B==0 [djnz 0x12AC]
	rts                                    	| [ret]



*
* Check if a flying alien has hit the player's ship.
*
* If so:
* IS_PLAYER_HIT will be set to 1.
*
* Expects:
* IX = pointer to INFLIGHT_ALIEN structure
*

TEST_IF_INFLIGHT_ALIEN_HIT_PLAYER:
	btst.b	#0,(0x00,a2)                    	| read INFLIGHT_ALIEN.IsActive flag [bit  0,(ix+0x00)]
	bne.b	0f
	rts                                    	| exit if alien isn't active [ret  z]
0:

	move.b	(inf_alien_X,a2),d0                      	| read INFLIGHT_ALIEN.X [ld   a,(ix+0x03)]
	add.b	#0x21,d0                         	| [add  a,0x21]
	subq.b	#0x05,d0                        	| [sub  0x05]
	jcs	l_12da                             	| [jr   c,0x12DA]
	sub.b	#0x0C,d0                         	| [sub  0x0C]
	bcs.b	0f
	rts                                    	| return if >=0x0C [ret  nc]
0:

	move.b	PLAYER_Y,d0                       	| read PLAYER_Y [ld   a,(0x4202)]
	sub.b	(inf_alien_Y,a2),d0                     	| subtract INFLIGHT_ALIEN.Y [sub  (ix+0x04)]
	add.b	#0x0A,d0                         	| [add  a,0x0A]
	cmp.b	#0x15,d0                         	| [cp   0x15]
	bcs.b	0f
	rts                                    	| return if >=0x15 [ret  nc]
0:

* kill player and alien
	move.b	#0x01,IS_PLAYER_HIT 		| set IS_PLAYER_HIT flag. [ld   (0x4204),a]
	jra	l_125e                             	| and we need to kill the alien as well [jp   0x125E]

l_12da:
	move.b	PLAYER_Y,d0                       	| read PLAYER_Y [ld   a,(0x4202)]
	sub.b	(inf_alien_Y,a2),d0                     	| subtract INFLIGHT_ALIEN.Y [sub  (ix+0x04)]
	addq.b	#0x07,d0                        	| [add  a,0x07]
	cmp.b	#0x0F,d0                         	| [cp   0x0F]
	bcs.b	0f
	rts                                    	| return if >=0x0f [ret  nc]
0:

* kill player and alien
	move.b	#0x01,IS_PLAYER_HIT   	| set IS_PLAYER_HIT flag. [ld   (0x4204),a]
	jra	l_125e                             	| and we need to kill the alien as well [jp   0x125E]



*
*  Handles the player being hit by an INFLIGHT_ALIEN (see 0x12B6) or ENEMY_BULLET (see 0x0B8D).
*

HANDLE_PLAYER_HIT:
	lea	IS_PLAYER_HIT,a0                      	| pointer to IS_PLAYER_HIT flag [ld   hl,0x4204]
	btst.b	#0,(a0)                         	| test flag to see if player has been hit. [bit  0,(hl)]
	bne.b	0f
	rts                                    	| bit is not set so player not hit, return [ret  z]
0:

* OK, player's hit.
	move.b	#0x00,(a0)                      	| clear IS_PLAYER_HIT flag [ld   (hl),0x00]
	clr.b	HAS_PLAYER_SPAWNED                  	| [ld   hl,0x0100]
	move.b	#1,IS_PLAYER_DYING                      	| Clear HAS_PLAYER_SPAWNED and set IS_PLAYER_DYING flags [ld   (0x4200),hl]

* Draw first frame of player exploding
	move.b	#10,PLAYER_EXPLOSION_COUNTER	| [ld   hl,0x040A]
	move.b	#4,PLAYER_EXPLOSION_ANIM_FRAME 	| set PLAYER_EXPLOSION_COUNTER and PLAYER_EXPLOSION_ANIM_FRAME [ld   (0x4205),hl]
	                       
	move.w	#0x0205,d3                      	| command: DISPLAY_PLAYER_COMMAND, parameter: 5 (invokes DRAW_PLAYER_SHIP_EXPLODING) [ld   de,0x0205]
	jbsr	QUEUE_COMMAND                            	| call QUEUE_COMMAND [call 0x08F2]

* reduce level of difficulty
	move.b	DIFFICULTY_EXTRA_VALUE,d0                       	| read DIFFICULTY_EXTRA_VALUE [ld   a,(0x421A)]
	jeq	l_130e                             	| if zero, then - wait a second, why is it updating an already zero field? Should be: jr z, 0x1311 [jr   z,0x130E]
	subq.b	#1,d0                           	| reduce game difficulty slightly [dec  a]
l_130e:
	move.b	d0,DIFFICULTY_EXTRA_VALUE                       	| update DIFFICULTY_EXTRA_VALUE [ld   (0x421A),a]

* decrement number of player lives
	lea	PLAYER_LIVES,a0                      	| pointer to address of PLAYER_LIVES [ld   hl,0x421D]
	subq.b	#1,(a0)                         	| reduce number of lives [dec  (hl)]
	move.b	(a0),d0                         	| read number of lives [ld   a,(hl)]
	cmp.b	#0x06,d0                         	| compare to 6 [cp   0x06]
	jcs	l_131c                             	| if < 6 then goto 0x131C [jr   c,0x131C]
	move.b	#0x05,(a0)                      	| otherwise, clamp number of lives max to 5 (is this anti-hack code?) [ld   (hl),0x05]
l_131c:
	move.b	IS_GAME_IN_PLAY,d0                       	| read IS_GAME_IN_PLAY [ld   a,(0x4006)]
	ror.b	#1,d0                           	| move flag into carry [rrca]
	bcs.b	0f
	rts                                    	| return if game is not in play [ret  nc]
0:

* Make player BOOM! sound
	move.b	#0x01,d0                        	| [ld   a,0x01]
	*SOUND  move.b	d0,l_6803                       	| make PLAYER HIT noise [ld   (0x6803),a]
	rts                                    	| [ret]




* Draws player explosion, stops player hit sound when done.

HANDLE_PLAYER_DYING:
	tst.b	IS_PLAYER_DYING                       	| read IS_PLAYER_DYING flag [ld   a,(0x4201)]
	bne.b	0f
	rts                                    	| return if player is not dying. [ret  nc]
0:
* wait for explosion delay to count to zero
	lea	PLAYER_EXPLOSION_COUNTER,a0                      	| point HL to PLAYER_EXPLOSION_COUNTER [ld   hl,0x4205]
	subq.b	#1,(a0)                         	| decrement value [dec  (hl)]
	beq.b	0f
	rts                                    	| if counter hasn't hit 0, then explosion animation can continue, return. [ret  nz]
0:
	move.b	#0x0A,(a0)                      	| otherwise reset PLAYER_EXPLOSION_COUNTER value to its default #0x0A (10 decimal) [ld   (hl),0x0A]

* draw explosion animation
	lea		PLAYER_EXPLOSION_ANIM_FRAME,a0                           	| bump HL to point to PLAYER_EXPLOSION_ANIM_FRAME [inc  hl]
	move.w	#0x200,d3						| command 2: DISPLAY_PLAYER_COMMAND
	move.b	(a0),d3							| read the animation frame value
	jbsr	QUEUE_COMMAND                            	| call QUEUE_COMMAND [call 0x08F2]
	subq.b	#1,(a0)                         	| decrement the animation frame value [dec  (hl)]
	beq.b	0f
	rts                                    	| if its not zero, the player dying animation hasn't finished, so return [ret  nz]
0:
	moveq	#0,d0                            	| Otherwise, the player explosion animation has reached its end, so.... [xor  a]

* clear IS_PLAYER_DYING flag when animation done and stop player explosion sound
	move.b	d0,IS_PLAYER_DYING                       	| clear IS_PLAYER_DYING flag [ld   (0x4201),a]
	*SOUND move.b	d0,l_6803                       	| clear !SOUND  player hit [ld   (0x6803),a]
	rts                                    	| [ret]



*
* Try to send a single alien to attack the player.
*
* If we have flagships in the swarm, then only purple and blue aliens can be sent to attack by this routine.
* If we have no flagships in the swarm, then red aliens can also be sent to attack. (See 0x13BD)
*
* Flagships and escorts are handled by HANDLE_FLAGSHIP_ATTACK.
*
*
* Cheat (of a sort):
* if you want to make this game very difficult, type the following into the MAME debugger:
* maincpu.mb@1359 = 8
* maincpu.pb@421A = 7
* maincpu.pb@421B = 7
*

HANDLE_SINGLE_ALIEN_ATTACK:
	tst.b	CAN_ALIEN_ATTACK                       	| read CAN_ALIEN_ATTACK flag [ld   a,(0x4228)]
	bne.b	0f
	rts                                    	| return if flag is not set [ret  nc]
0:
	moveq	#0,d0                            	| [xor  a]
	move.b	d0,CAN_ALIEN_ATTACK                       	| reset CAN_ALIEN_ATTACK flag [ld   (0x4228),a]
	move.b	HAVE_NO_ALIENS_IN_SWARM,d0                       	| read HAVE_NO_ALIENS_IN_SWARM flag. [ld   a,(0x4220)]
	ror.b	#1,d0                           	| move flag into carry [rrca]
	bcc.b	0f
	rts                                    	| return if no aliens are in the swarm. [ret  c]
0:

* The difficulty level specifies how many aliens can be attacking the player at one time.
	move.b	DIFFICULTY_BASE_VALUE,d5
	move.b	DIFFICULTY_EXTRA_VALUE,d6 	| load H with DIFFICULTY_BASE_VALUE and L with DIFFICULTY_EXTRA_VALUE [ld   hl,(0x421A)]
	move.b	d5,d0                           	| [ld   a,h]
	add.b	d6,d0                             	| add DIFFICULTY_EXTRA_VALUE to DIFFICULTY_BASE_VALUE [add  a,l]
	lsr.b	#1,d0                            	| divide by 2. [rra]
	cmp.b	#0x04,d0                         	| is result < 4? [cp   0x04]
	jcs	l_135e                             	| yes, goto 0x135E. [jr   c,0x135E]
	move.b	#0x03,d0                        	| Clamp maximum number of INFLIGHT_ALIEN slots to scan to 3. [ld   a,0x03]
l_135e:
	addq.b	#1,d0                           	| ensure that slots to scan is in range of 1..4 [inc  a]

* Scan a specified number of slots (up to 4) in the INFLIGHT_ALIENS array, starting from the *last* slot and working back.
* Take the first slot that has clear IsActive and IsDying flags.
* A = number of slots to scan
	move.b	d0,d1                          	| save number of slots to scan in B [ld   b,a]
	lea	INFLIGHT_ALIENS+0x391-0x2B0,a0    | point HL to last INFLIGHT_ALIEN.IsDying flag in INFLIGHT_ALIENS array [ld   hl,0x4391]
	move.w	#0xFFE1,d3                      	| load DE with -31, which is sizeof(INFLIGHT_ALIEN)-1 [ld   de,0xFFE1]
l_1366:	
	move.b	(a0),d0                         	| read INFLIGHT_ALIEN.IsDying flag [ld   a,(hl)]
	subq.w	#1,a0                           	| bump HL to point to INFLIGHT_ALIEN.IsActive flag [dec  hl]
	or.b	(a0),d0                           	| combine flags. We want A to be 0, to indicate INFLIGHT_ALIEN slot is not in use. [or   (hl)]
	jeq	l_136f                             	| OK, we have an unused slot, goto 0x136F [jr   z,0x136F]
	add.w	d3,a0
	subq.b	#1,d1                           	| [...]
	jne	l_1366                             	| repeat until we've scanned all the slots we're allowed to [djnz 0x1366]
	rts                                    	| [ret]

* If we get here, HL points to an unused INFLIGHT_ALIEN record that will be repurposed for our soon-to-be attacking alien.
* HL = pointer to unused INFLIGHT_ALIEN structure
l_136f:
	move.l	a0,a2								| IX = HL
	move.b	ALIENS_ATTACK_FROM_RIGHT_FLANK,d0                       	| read ALIENS_ATTACK_FROM_RIGHT_FLANK flag [ld   a,(0x4215)]
	move.b	d0,(0x06,a2)                    	| update INFLIGHT_ALIEN.ArcClockwise flag [ld   (ix+0x06),a]
	tst.b	d0                               	| test if flag is set [and  a]
	jne	FIND_FIRST_OCCUPIED_SWARM_COLUMN_START_FROM_RIGHT      	| if flag is set, goto FIND_FIRST_OCCUPIED_SWARM_COLUMN_START_FROM_RIGHT [jr   nz,0x13AB]

* If we get here, we want an alien to break off from the left flank of the swarm.
* We now need to find an alien in the swarm able to attack the player.
* Find first occupied column of aliens starting from the leftmost column.
FIND_FIRST_OCCUPIED_SWARM_COLUMN_START_FROM_LEFT:
	lea	ALIEN_IN_COLUMN_FLAGS+0xC,a0                      	| address of flag for leftmost alien in ALIEN_IN_COLUMN_FLAGS [ld   hl,0x41FC]
	move.w	#10-1,d1							| 10 aliens maximum on a row
	move.b	#0x01,d0                        | we are scanning for a value of 1, meaning "column occupied" [ld   a,0x01]
1:
	cmp.b	(a0),d0
	beq.b	0f
	subq.w	#1,a0							| scan 0x41FC down to 0x41F3 for value #0x01 [cpdr]
	dbf		d1,1b
	rts                                    	| if we have no aliens in the swarm (all flags are 0) - return [ret  nz]
0:
	move.b	#0x3F,d4
	* compute d6 (l) as the word offset from A0
	lea	ALIEN_IN_COLUMN_FLAGS,a1
	sub.l	a1,a0
	move.l	a0,d6		| word is okay
	
* HL now points to an entry in ALIEN_IN_COLUMN_FLAGS where we have an alien present.
* If we have flagships in the swarm, then only purple and blue aliens can be sent to attack by this routine.
* If we have no flagships in the swarm, then any remaining red aliens are also considered. (See 0x13BD)
TRY_FIND_ALIEN_TO_ATTACK:
	move.b	HAVE_ALIENS_IN_TOP_ROW,d0                       	| load a with HAVE_ALIENS_IN_TOP_ROW flag [ld   a,(0x41EF)]
	ror.b	#1,d0                           	| move flag into carry [rrca]
	jcc	INIT_SCAN_FROM_RED_ALIEN_ROW                             	| if no flagships in swarm, goto INIT_SCAN_FROM_RED_ALIEN_ROW [jr   nc,0x13BD]

* we have flagships, so send a purple or blue alien.
INIT_SCAN_FROM_PURPLE_ALIEN_ROW:
	move.b	#4,d3                             	| number of rows to scan (1 purple + 3 blue)
	* JOTD: z80 memory is aligned to avoid conflicts between l and h
	* on 68000 we don't need that msb/lsb crap + alignment
	* "just" use data indexed register in d6
	lea		ALIEN_SWARM_FLAGS,a0			| MSB of ALIEN_SWARM_FLAGS address
	                           	| [ld   a,l]
	and.w	#0x0F,d6                         	| A = index of column containing alien [and  0x0F]
	add.w	#0x50,d6                         	| effectively: HL = 0x4150 + (L & 0x0f) [add  a,0x50]
    add.w	d6,a0                            	| HL now points to slot for purple alien in ALIEN_SWARM_FLAGS  [ld l,a]
	
* HL/A0 now points to a slot in ALIEN_SWARM_FLAGS. D is a row counter.
* If the slot is occupied, the occupying alien will be sent to attack the player.
* If the slot is unoccupied, we'll scan the same column in the rows beneath until we find an occupied slot or we've done D rows.
* If we find an alien, we'll send it to attack the player.
SCAN_SPECIFIC_COLUMN_FOR_D_ROWS:
	move.b	d3,d1                           	| set B to number of rows to scan [ld   b,d]
l_139b:
	tst.b	(a0)                         	| test for presence of alien in ALIEN_SWARM_FLAGS [bit  0,(hl)]
	jne	l_13ce                             	| if there's an alien present, its "volunteered" to attack, goto 0x13CE [jr   nz,0x13CE]
											| [ld   a,l]
	sub.w	#0x10,a0                         	| sizeof(row in ALIEN_SWARM_FLAGS) [sub  0x10]
											| bump HL to point to alien in row beneath [ld   l,a]
	subq.b	#1,d1                           	| [...]
	jne	l_139b                             	| repeat until B==0 [djnz 0x139B]

* OK, We've scanned the entire column and not found an alien. This means that ALIEN_IN_COLUMN_FLAGS isn't truthful,
* and we need to resort to desperate measures.
*
* ** I've not seen this block of code called, and I think it might be legacy or debug **
*
* Bump HL to point to the purple alien in the column to the right of the one we just scanned. We'll scan that column.
	and.w	#0xFF,d0
	add.b	d4,d0                             	| add 0X3F (or more) to A. [add  a,e]
	add.w	d0,a0                               	| Now HL points to purple alien slot
	subq.b	#1,d2                           	| decrement count of columns remaining that we *can* scan [dec  c]
	jne	SCAN_SPECIFIC_COLUMN_FOR_D_ROWS                             	| if non-zero, repeat the column scan [jr   nz,0x139A]
	rts                                    	| [ret]


* If we get here, we want an alien to break off from the right flank of the swarm.
* We now need to find an alien in the swarm willing to attack the player.
* Find first occupied column of aliens starting from the rightmost column.
FIND_FIRST_OCCUPIED_SWARM_COLUMN_START_FROM_RIGHT:
	lea	ALIEN_IN_COLUMN_FLAGS+3,a0         | address of flag for rightmost column of aliens [ld   hl,0x41F3]
	move.w	#10-1,d1							| 10 aliens maximum on a row
	move.b	#0x01,d0                        	| we are scanning for a value of 1, meaning "column occupied" [ld   a,0x01]
1:
	cmp.b	(a0),d0
	beq.b	0f
	addq.w	#1,a0							| scan 0x41FC down to 0x41F3 for value #0x01 [cpir]
	dbf		d1,1b
	rts                                    	| if we have no aliens in the swarm - return [ret  nz]
0:

* we've found an occupied column
	move.b	#0x41,d4		| probably not useful, only for legacy/debug code
	* compute d6 (l) as the word offset from A0
	lea	ALIEN_IN_COLUMN_FLAGS,a1
	sub.l	a1,a0
	move.l	a0,d6		| word is okay
	
	jra	TRY_FIND_ALIEN_TO_ATTACK                             	| jump to TRY_FIND_ALIEN_TO_ATTACK: [jp   0x138A]


* Called when no flagships present in flagship row. This means we can send any alien, including red, into the attack.
INIT_SCAN_FROM_RED_ALIEN_ROW:
	move.b	#5,d3                           	| number of rows of aliens to scan
	lea		ALIEN_SWARM_FLAGS,a0                             	| MSB of ALIEN_SWARM_FLAGS address
			                  	| [ld   a,l]
	and.w	#0x0F,d6                         	| A = index of column [and  0x0F]
	add.w	#0x60,d6                         	| effectively: HL = 0x4150 + (L & 0x0f) [add  a,0x60]
	add.w	d6,a0                                	| HL now points to slot for red alien in ALIEN_SWARM_FLAGS
	                           	| [ld   a,e]
	add.b	#0x10,d4          | [add  a,0x10]
								| [ld   e,a]
	jra	SCAN_SPECIFIC_COLUMN_FOR_D_ROWS  | [jp   0x139A]


*
* Expects:
* HL = pointer to occupied entry in ALIEN_SWARM_FLAGS
* IX = pointer to vacant INFLIGHT_ALIEN structure
*

l_13ce:
	clr.b	(a0)                      	| [ld   (hl),0x00]
	move.b	d6,(IndexInSwarm,a2)                     	| set INFLIGHT_ALIEN.IndexInSwarm [ld   (ix+0x07),l]
	move.b	#0x01,(IsActive,a2)                 	| set INFLIGHT_ALIEN.IsActive [ld   (ix+0x00),0x01]
	clr.b	(StageOfLife,a2)                 	| set INFLIGHT_ALIEN.StageOfLife [ld   (ix+0x02),0x00]
	move.w	#0x100,d3						| command: DELETE_ALIEN_COMMAND
	move.b	d6,d3						  | parameter: index of alien in swarm
	jra	QUEUE_COMMAND                             	| jump to QUEUE COMMAND [jp   0x08F2]



*
* Sets the flank that aliens, including flagships, will attack from.
*
* If you replace 0x13F3-13F5, 0x13FF-1401, 0x1408-140A with zero (NOP), you can then tinker with the flag in 0x4215 and control
* what side the aliens attack from.
*

SET_ALIEN_ATTACK_FLANK:
	move.w	SWARM_SCROLL_VALUE,d5                      	| read SWARM_SCROLL_VALUE [ld   hl,(0x420E)]
	move.w	SWARM_SCROLL_MAX_EXTENTS,d3                      	| read SWARM_SCROLL_MAX_EXTENTS [ld   de,(0x4210)]
	btst	#15,d5                            	| [bit  7,h]
	jeq	l_13f7                             	| [jr   z,0x13F7]

	move.b	d5,d0                           	| [ld   a,l]
	sub.b	d3,d0                             	| [sub  d]
	cmp.b	#0x1C,d0                         	| [cp   0x1C]
	jcc	l_1403                             	| if A>0x1C, attack from a random flank [jr   nc,0x1403]
	clr.b	ALIENS_ATTACK_FROM_RIGHT_FLANK                       	| reset ALIENS_ATTACK_FROM_RIGHT_FLANK flag. Aliens will now attack from left side of swarm. [ld   (0x4215),a]
	rts                                    	| [ret]

l_13f7:
	move.w	d3,d0                           	
	lsr.w	#8,d0								| [ld   a,e]
	sub.b	d5,d0                             	| [sub  l]
	cmp.b	#0x1C,d0                         	| [cp   0x1C]
	jcc	l_1403                             	| if A>0x1C, attack from a random flank [jr   nc,0x1403]
	move.b	#1,ALIENS_ATTACK_FROM_RIGHT_FLANK                       	| set ALIENS_ATTACK_FROM_RIGHT_FLANK flag. Aliens will now attack from right side of swarm. [ld   (0x4215),a]
	rts                                    	| [ret]

* Attack from left or right flank, chosen at random
l_1403:
	jbsr	GENERATE_RANDOM_NUMBER                            	| call GENERATE_RANDOM_NUMBER [call 0x003C]
	and.b	#0x01,d0                         	| mask in bit 0, so A is either 0 or 1 [and  0x01]
	move.b	d0,ALIENS_ATTACK_FROM_RIGHT_FLANK                       	| set/reset ALIENS_ATTACK_FROM_RIGHT_FLANK flag. [ld   (0x4215),a]
	rts                                    	| [ret]




*
* This routine checks if a flagship and escort can break from a given flank to attack the player.
*
* The flank is determined by the ALIENS_ATTACK_FROM_RIGHT_FLANK flag (0x4215).
*
* If a flagship exists on the specified flank, send the flagship to attack.
* If there's red aliens in *close proximity* to the flagship, send a maximum of 2 as an escort.
*
* If there are no flagships on the specified flank, try to send a single red alien from the flank instead.
*
* Notes:
* A flagship can attack when:
*     HAVE_NO_ALIENS_IN_SWARM is set to 0 AND
*     HAS_PLAYER_SPAWNED is set to 1 AND
*     The CAN_FLAGSHIP_OR_RED_ALIENS_ATTACK is set to 1 AND
*     INFLIGHT_ALIENS[1] is available for use
*
*
* Cheat:
* If you type into the MAME debugger:
* maincpu.mb@140C=C9
*
* The flagships stop attacking you completely.
*

HANDLE_FLAGSHIP_ATTACK:
	move.b	HAVE_NO_ALIENS_IN_SWARM,d0                       	| read HAVE_NO_ALIENS_IN_SWARM flag [ld   a,(0x4220)]
	ror.b	#1,d0                           	| move flag into carry [rrca]
	bcc.b	0f
	rts                                    	| return if no aliens in the swarm. [ret  c]
0:
	move.b	HAS_PLAYER_SPAWNED,d0                       	| read HAS_PLAYER_SPAWNED [ld   a,(0x4200)]
	ror.b	#1,d0                           	| move flag into carry [rrca]
	bcs.b	0f
	rts                                    	| return if player has not spawned. [ret  nc]
0:
	move.b	CAN_FLAGSHIP_OR_RED_ALIENS_ATTACK,d0                       	| read CAN_FLAGSHIP_OR_RED_ALIENS_ATTACK [ld   a,(0x4229)]
	ror.b	#1,d0                           	| move flag into carry [rrca]
	bcs.b	0f
	rts                                    	| return if flag is not set [ret  nc]
0:
	clr.b	CAN_FLAGSHIP_OR_RED_ALIENS_ATTACK                       	| reset CAN_FLAGSHIP_OR_RED_ALIENS_ATTACK flag [ld   (0x4229),a]

* Test if the slot in INFLIGHT_ALIENS reserved for the flagship is in use. If so - do nothing.
	lea		INFLIGHT_ALIENS+inflight_alien_size,a0
	tst.b	(IsActive,a0)                      	| read from INFLIGHT_ALIENS[1] which is the 2nd array element [ld   hl,(0x42D0)]
	beq.b	0f
	tst.b	(IsDying,a0)                      	| read from INFLIGHT_ALIENS[1] which is the 2nd array element [ld   hl,(0x42D0)]
	bne.b	1f
0:	
	rts                                    	| return if alien is active or dying - the slot for the flagship is in use. [ret  c]
1:

* from what side should the flagship/red aliens attack from?
	move.b	ALIENS_ATTACK_FROM_RIGHT_FLANK,d0                       	| read ALIENS_ATTACK_FROM_RIGHT_FLANK flag [ld   a,(0x4215)]
	move.b	d0,d2                          	| C is used to set INFLIGHT_ALIEN.ArcClockwise flag @ 0x1466 [ld   c,a]
	ror.b	#1,d0                           	| move flag into carry [rrca]
	jcs	TRY_FIND_FLAGSHIP_OR_RED_ALIEN_TO_ATTACK_FROM_RIGHT_FLANK                             	| if attacking from right flank, jump to TRY_FIND_FLAGSHIP_OR_RED_ALIEN_TO_ATTACK_FROM_RIGHT_FLANK [jp   c,0x14BE]


TRY_FIND_FLAGSHIP_OR_RED_ALIEN_TO_ATTACK_FROM_LEFT_FLANK:
	lea	ALIEN_SWARM_FLAGS+0x79,a0                      	| load HL with pointer to leftmost flagship in ALIEN_SWARM_FLAGS [ld   hl,0x4179]
	move.b	#0x04,d1                        	| scan 4 slots max in the ALIEN_SWARM_FLAGS array to find a flagship [ld   b,0x04]
l_1433:
	tst.b	(a0)                         	| test if a flagship is present [bit  0,(hl)]
	jne	INIT_FLAGSHIP_ATTACK_FROM_LEFT_FLANK                             	| if we have found a flagship, goto INIT_FLAGSHIP_ATTACK_FROM_LEFT_FLANK [jr   nz,0x1472]
	subq.w	#1,a0                            	| move to next potential flagship [dec  l]
	subq.b	#1,d1                           	| [...]
	jne	l_1433                             	| repeat until B==0 [djnz 0x1433]

* If we can't get a flagship, then we scan the red alien row from left to right to find a red alien to attack.
	lea		ALIEN_SWARM_FLAGS+0x6A,a0          	| load HL with pointer to leftmost red alien in ALIEN_SWARM_FLAGS
	move.b	#0x04,d1                        	| scan first 4 red aliens [ld   b,0x04]
l_143e:
	tst.b	(a0)                         	| test if an alien is present [bit  0,(hl)]
	jne	TRY_INIT_INFLIGHT_ALIEN                             	| if we have found a red alien, goto TRY_INIT_INFLIGHT_ALIEN [jr   nz,0x1446]
	subq.w	#1,a0                           	| bump HL to point to slot of sibling alien [dec  l]
	subq.b	#1,d1                           	| [...]
	jne	l_143e                             	| repeat until B==0 [djnz 0x143E]
	rts                                    	| [ret]

*
* Scan the last 4 entries in the INFLIGHT_ALIENS array for an unused slot.
* If all 4 slots at the end of the array are already in use, exit.
* Otherwise re-use the lastmost free slot for an attacking alien.
*
* Expects:
* HL = pointer to a bit flag in ALIEN_IN_SWARM_FLAGS
*

TRY_INIT_INFLIGHT_ALIEN:
	lea	INFLIGHT_ALIENS+0x390-0x2B0,a2                      	| address of very last INFLIGHT_ALIEN record in INFLIGHT_ALIENS array [ld   ix,0x4390]
	move.w	#inflight_alien_size,d3                      	| -32 decimal, which is -sizeof(INFLIGHT_ALIEN) [ld   de,0xFFE0]
	move.b	#0x04,d1                        	| [ld   b,0x04]
l_144f:
	move.b	(IsActive,a2),d0                      	| load A with INFLIGHT_ALIEN.IsActive flag [ld   a,(ix+0x00)]
	or.b	(IsDying,a2),d0                      	| OR A with INFLIGHT_ALIEN.IsDying flag [or   (ix+0x01)]
	jeq	INIT_INFLIGHT_ALIEN                             	| if the slot is not used for an active or dying alien, goto INIT_INFLIGHT_ALIEN [jr   z,0x145C]
	sub.w	d3,a2                              	| subtract sizeof(INFLIGHT_ALIEN) from IX, to bump IX to previous INFLIGHT_ALIEN record
	subq.b	#1,d1                           	| [...]
	jne	l_144f                             	| [djnz 0x144F]
	rts                                    	| [ret]

*
* Remove an alien from the swarm, and create an inflight alien in its place.
*
* Expects:
* C = direction alien will break away from swarm. 0 = left, 1 = right
* HL = pointer to entry in ALIEN_SWARM_FLAGS
* IX = pointer to INFLIGHT_ALIEN struct of alien
*

INIT_INFLIGHT_ALIEN:
	clr.b	(a0)                      	| clear flag in ALIEN_SWARM_FLAGS - effectively removing it from swarm [ld   (hl),0x00]
	move.l	a0,d6
	sub.l	#ALIEN_SWARM_FLAGS,d6		| compute index from address
	move.b	#0x01,(IsActive,a2)                 	| set INFLIGHT_ALIEN.IsActive [ld   (ix+0x00),0x01]
	clr.b	(StageOfLife,a2)                 	| reset INFLIGHT_ALIEN.StageOfLife [ld   (ix+0x02),0x00]
	move.b	d2,(ArcClockwise,a2)                    	| set INFLIGHT_ALIEN.ArcClockwise [ld   (ix+0x06),c]
	move.b	d6,(IndexInSwarm,a2)                     	| set INFLIGHT_ALIEN.IndexInSwarm [ld   (ix+0x07),l]
	move.w	#0x0100,d3                             	| command: DELETE_ALIEN_COMMAND
	move.b	d6,d3								| parameter: index of alien to delete from the swarm
	jra	QUEUE_COMMAND                             	| jump to QUEUE_COMMAND [jp   0x08F2]


*
* Given a pointer to a flagship entry in the ALIEN_SWARM_FLAGS array,
* scan for red aliens in close proximity to the flagship that can be used as an escort.
* Initialise INFLIGHT_ALIEN records for the flagship and any escort as well.
*
* Expects:
* HL = pointer to entry in flagship row of ALIEN_SWARM_FLAGS
*

INIT_FLAGSHIP_ATTACK_FROM_LEFT_FLANK:
	lea	INFLIGHT_ALIENS+inflight_alien_size,a2            	| pointer to INFLIGHT_ALIENS_START+sizeof(INFLIGHT_ALIEN) [ld   ix,0x42D0]
	jbsr	INIT_INFLIGHT_ALIEN                            	| call INIT_INFLIGHT_ALIEN to make flagship take flight and leave the swarm [call 0x145C]
										| [ld   a,l]
	sub.w	#0x0F,a0                         	| [sub  0x0F]
										| bump HL to point at red alien directly below and to right of flagship
	lea	INFLIGHT_ALIENS+inflight_alien_size*2,a3                      	| pointer to INFLIGHT_ALIENS_START+(sizeof(INFLIGHT_ALIEN) * 2) [ld   iy,0x42F0]
	move.b	#0x03,d1                        	| we're scanning 3 entries in red aliens row max [ld   b,0x03]
	move.b	#0x02,d2                        	| But we only want 2 red aliens as an escort. [ld   c,0x02]
l_1485:
	btst.b	#0,(a0)                         	| test for presence of red alien [bit  0,(hl)]
	beq.b	0f
	jbsr	l_148E                                	| if we have a red alien, try to create an inflight alien [call nz,0x148E]
	subq.w	#1,a0                            	| bump HL to point to slot of sibling alien [dec  l]
0:	
	subq.b	#1,d1                           	| [...]
	jne	l_1485                             	| repeat until B==0 [djnz 0x1485]
	rts                                    	| [ret]

* HL = pointer to entry in ALIEN_SWARM_FLAGS
	jbsr	TRY_INIT_ESCORT_INFLIGHT_ALIEN                            	| call TRY_INIT_ESCORT_INFLIGHT_ALIEN [call 0x149B]
	add.w	#inflight_alien_size,a3       		| bump IY to point to next member of INFLIGHT_ALIENS array
	subq.b	#1,d2                           	| reduce count of red aliens left to check for use as escort [dec  c]
	beq.b	0f
	rts                                    	| return if we have all the escort we need [ret  nz]
0:
	move.b	#0x01,d1                        	| [ld   b,0x01]
	rts                                    	| [ret]


*
* Try to create an escort for a flagship.
*
* Expects:
* HL = pointer to red alien in ALIEN_SWARM_FLAGS that could be escort
* IX = pointer to INFLIGHT_ALIEN structure (used for flagship)
* IY = pointer to INFLIGHT_ALIEN structure (will be used for escort)
*
* If the INFLIGHT_ALIEN pointed to by IY is not occupied by an active or dying alien, then
* the record is re-used and marked as active.
* Otherwise this routine exits.

TRY_INIT_ESCORT_INFLIGHT_ALIEN:
	btst.b	#0,(IsActive,a3)                    	| test INFLIGHT_ALIEN.IsActive [bit  0,(iy+0x00)]
	beq.b	0f
	rts                                    	| return if flag is set [ret  nz]
0:
	btst.b	#0,(IsDying,a3)                    	| test INFLIGHT_ALIEN.IsDying [bit  0,(iy+0x01)]
	beq.b	0f
	rts                                    	| return if flag is set [ret  nz]
0:

* OK, we can use the INFLIGHT_ALIEN slot at IY. Let's remove the alien from the swarm
* and create
	clr.b	(a0)                      	| clear flag in ALIEN_SWARM_FLAGS [ld   (hl),0x00]
	move.b	#0x01,(IsActive,a3)                 	| set INFLIGHT_ALIEN.IsActive [ld   (iy+0x00),0x01]
	move.b	#0x00,(StageOfLife,a3)                 	| reset INFLIGHT_ALIEN.StageOfLife [ld   (iy+0x02),0x00]
	move.l	a0,d6
	sub.l	#ALIEN_SWARM_FLAGS,d6		| compute index from address
	move.b	(ArcClockwise,a2),d0                      	| read flagship's INFLIGHT_ALIEN.ArcClockwise [ld   a,(ix+0x06)]
	move.b	d0,(ArcClockwise,a3)                    	| set escort INFLIGHT_ALIEN.ArcClockwise so it breaks away in formation. [ld   (iy+0x06),a]
	move.b	d6,(IndexInSwarm,a3)                     	| set escort INFLIGHT_ALIEN.IndexInSwarm [ld   (iy+0x07),l]
	move.w	#0x100,d3						| command: DELETE_ALIEN_COMMAND
	move.w	D6,d3							| parameter: index of alien to delete from the swarm
	jra	QUEUE_COMMAND                             	| jump to QUEUE_COMMAND [jp   0x08F2]


TRY_FIND_FLAGSHIP_OR_RED_ALIEN_TO_ATTACK_FROM_RIGHT_FLANK:
	lea	ALIEN_SWARM_FLAGS+0x76,a0           	| load HL with pointer to rightmost flagship in ALIEN_SWARM_FLAGS [ld   hl,0x4176]
	move.b	#0x04,d1                        	| scan max of 4 flagships in array [ld   b,0x04]
l_14c3:
	tst.b	(a0)                         	| test if a flagship is present [bit  0,(hl)]
	jne	INIT_FLAGSHIP_ATTACK_FROM_RIGHT_FLANK                        	| if we have found a flagship, goto INIT_FLAGSHIP_ATTACK_FROM_RIGHT_FLANK [jr   nz,0x14D7]
	addq.w	#1,a0                            	| otherwise try looking for a flagship to immediate left [inc  l]
	subq.b	#1,d1                           	| [...]
	jne	l_14c3                             	| repeat until B==0 [djnz 0x14C3]

* If we can't find a single flagship, then we try the red alien row.
	lea		ALIEN_SWARM_FLAGS+0x65,a0       	| load HL with pointer to rightmost red alien in ALIEN_SWARM_FLAGS array [ld   l,0x65]
	move.b	#0x04,d1                        	| scan max of 4 slots in array [ld   b,0x04]
l_14ce:
	tst.b	(a0)                         	| test if red alien is present [bit  0,(hl)]
	jne	TRY_INIT_INFLIGHT_ALIEN    | if we have found a red alien, goto 0x1446 [jp   nz,0x1446]
	addq.w	#1,a0                            	| bump HL to point to slot of sibling alien [inc  l]
	subq.b	#1,d1                           	| [...]
	jne	l_14ce                             	| repeat until B==0 [djnz 0x14CE]
	rts                                    	| [ret]


* Near duplicate of INIT_FLAGSHIP_ATTACK_FROM_LEFT_FLANK @0x1472, except for the right flank.
*
* Given a pointer to a flagship entry in the ALIEN_SWARM_FLAGS array,
* scan for red aliens in close proximity to the flagship that can be used as an escort.
* Initialise INFLIGHT_ALIEN records for the flagship and any escort as well.
*
* Expects:
* HL = pointer to flag in ALIEN_SWARM_FLAGS representing flagship
*

INIT_FLAGSHIP_ATTACK_FROM_RIGHT_FLANK:
	lea	INFLIGHT_ALIENS+inflight_alien_size,a2          	| pointer to INFLIGHT_ALIENS_START+sizeof(INFLIGHT_ALIEN) [ld   ix,0x42D0]
	jbsr	INIT_INFLIGHT_ALIEN                            	| Remove an alien from the swarm, and create an inflight alien in its place. [call 0x145C]
	sub.w	#0x11,a0                         	| bump HL to point at red alien directly below and to right of flagship [sub  0x11]

	lea	INFLIGHT_ALIENS+inflight_alien_size*2,a3         	| pointer to INFLIGHT_ALIENS_START+(sizeof(INFLIGHT_ALIEN) * 2) [ld   iy,0x42F0]
	moveq	#0x03,d1                        	| [ld   b,0x03]
	moveq	#0x02,d2                        	| [ld   c,0x02]
l_14ea:
	tst.b	(a0)                         	| do we have a red alien? [bit  0,(hl)]
	beq.b	0f
	jbsr	l_148E                                	| [call nz,0x148E]
0:
	addq.w	#1,a0                            	| [inc  l]
	subq.b	#1,d1                           	| [...]
	jne	l_14ea                             	| [djnz 0x14EA]
	rts                                    	| [ret]

l_148E:
* HL = pointer to entry in ALIEN_SWARM_FLAGS
	jbsr	TRY_INIT_ESCORT_INFLIGHT_ALIEN                            	| call TRY_INIT_ESCORT_INFLIGHT_ALIEN [call 0x149B]
	
	add.w	#inflight_alien_size,a2                           	| bump IY to point to next member of INFLIGHT_ALIENS array [add  iy,de]
	subq.b	#1,d2                           	| reduce count of red aliens left to check for use as escort [dec  c]
	beq.b	0f
	rts                                    	| return if we have all the escort we need [ret  nz]
0:
	moveq	#0x01,d1                        	| [ld   b,0x01]
	rts                                    	| [ret]


*
* Increase game difficulty as the level goes on.
*

HANDLE_LEVEL_DIFFICULTY:
	move.b	HAS_PLAYER_SPAWNED,d0                       	| read HAS_PLAYER_SPAWNED [ld   a,(0x4200)]
	bne.b	0f
	rts                                    	| return if player has not spawned [ret  nc]
0:
	move.b	IS_FLAGSHIP_HIT,d0                       	| read IS_FLAGSHIP_HIT [ld   a,(0x422B)]
	ror.b	#1,d0                           	| move flag into carry [rrca]
	bcc.b	0f
	rts                                    	| return if flagship has been hit [ret  c]
0:

* wait until DIFFICULTY_COUNTER_1 counts down to zero.
	lea	DIFFICULTY_COUNTER_1,a0                      	| load HL with address of DIFFICULTY_COUNTER_1 [ld   hl,0x4218]
	subq.b	#1,(a0)                         	| decrement counter [dec  (hl)]
	beq.b	0f
	rts                                    	| [ret  nz]
0:
	move.b	#0x3C,(a0)                      	| reset counter [ld   (hl),0x3C]

* DIFFICULTY_COUNTER_1 has reached zero and reset. Decrement DIFFICULTY_COUNTER_2.
	lea		DIFFICULTY_COUNTER_2,a0                           	| bump HL to DIFFICULTY_COUNTER_2 [inc  hl]
	subq.b	#1,(a0)                         	| decrement counter [dec  (hl)]
	beq.b	0f
	rts                                    	| [ret  nz]
0:
	move.b	#0x14,(a0)                      	| reset counter [ld   (hl),0x14]

* DIFFICULTY_COUNTER_2 has reached zero. Now up the difficulty level, if we can.
	lea	DIFFICULTY_EXTRA_VALUE,a0                           	| bump HL to 0x421A (DIFFICULTY_EXTRA_VALUE) [inc  hl]
	move.b	(a0),d0                         	| read DIFFICULTY_EXTRA_VALUE [ld   a,(hl)]
	cmp.b	#0x07,d0                         	| has it reached its maximum value of 7? [cp   0x07]
	bne.b	0f
	rts                                    	| return if so [ret  z]
0:
	jcc	l_1512                             	| if A >= 7 , goto 0x1512 [jr   nc,0x1512]

	addq.b	#1,(a0)                         	| increment DIFFICULTY_EXTRA_VALUE [inc  (hl)]
	rts                                    	| [ret]

l_1512:
	move.b	#0x07,(a0)                      	| clamp DIFFICULTY_EXTRA_VALUE to 7 [ld   (hl),0x07]
	rts                                    	| [ret]


*
* Check if an alien can attack the player.
* For flagships, see 0x15C3
*

CHECK_IF_ALIEN_CAN_ATTACK:
	move.b	HAS_PLAYER_SPAWNED,d0                       	| read HAS_PLAYER_SPAWNED [ld   a,(0x4200)]
	ror.b	#1,d0                           	| move flag into carry [rrca]
	bcs.b	0f
	rts                                    	| return if player has not spawned [ret  nc]
0:
	move.b	HAVE_NO_ALIENS_IN_SWARM,d0                       	| read HAVE_NO_ALIENS_IN_SWARM flag [ld   a,(0x4220)]
	ror.b	#1,d0                           	| move flag into carry [rrca]
	bcc.b	0f
	rts                                    	| return if we don't have any aliens in the swarm [ret  c]
0:
	move.b	IS_FLAGSHIP_HIT,d0                       	| read IS_FLAGSHIP_HIT [ld   a,(0x422B)]
	ror.b	#1,d0                           	| move flag into carry [rrca]
	bcc.b	0f
	rts                                    	| return if the flagship has been hit [ret  c]
0:

* Use DIFFICULTY_EXTRA_VALUE and DIFFICULTY_BASE_VALUE to calculate how many secondary counters in the ALIEN_ATTACK_COUNTERS array
* we can decrement. The more counters = the higher probability one of them will count down to zero = higher probability an alien attacks.
	move.b	DIFFICULTY_BASE_VALUE,d5
	move.b	DIFFICULTY_EXTRA_VALUE,d6   	| load H with DIFFICULTY_BASE_VALUE and L with DIFFICULTY_EXTRA_VALUE [ld   hl,(0x421A)]
	move.b	d5,d0                           	| A = DIFFICULTY_BASE_VALUE value [ld   a,h]
	cmp.b	#0x02,d0                         	| [cp   0x02]
	jcc	l_152d                             	| if DIFFICULTY_BASE_VALUE >=2, goto 0x152D [jr   nc,0x152D]
	moveq	#0,d0                            	| [xor  a]
l_152d:
	add.b	d6,d0                             	| Add DIFFICULTY_EXTRA_VALUE to DIFFICULTY_BASE_VALUE [add  a,l]
	and.b	#0x0F,d0                         	| Ensure value is between 0 and 15 [and  0x0F]
	addq.b	#1,d0                           	| Add 1 to ensure it's between 1..16 [inc  a]
	move.b	d0,d1                          	| B now contains number of counters to decrement [ld   b,a]

* Decrement ALIEN_ATTACK_MASTER_COUNTER. When it hits zero, we can decrement secondary counters in the ALIEN_ATTACK_MASTER_COUNTERS array.
	lea	ALIEN_ATTACK_MASTER_COUNTER,a0                      	| load HL with address of ALIEN_ATTACK_MASTER_COUNTER [ld   hl,0x424A]
	lea	ALIEN_ATTACK_COUNTER_DEFAULT_VALUES,a1                      	| load DE with address of ALIEN_ATTACK_COUNTER_DEFAULT_VALUES [ld   de,0x15E3]
	subq.b	#1,(a0)                         	| decrement ALIEN_ATTACK_MASTER_COUNTER [dec  (hl)]
	jeq	l_1540                             	| if its hit zero, goto 0x1540 to decrement [B] counters [jr   z,0x1540]
	clr.b	CAN_ALIEN_ATTACK                       	| reset CAN_ALIEN_ATTACK flag. No alien will attack. [ld   (0x4228),a]
	rts                                    	| [ret]

* When we get here, ALIEN_ATTACK_MASTER_COUNTER is zero.
* B specifies how many secondary counters in the ALIEN_ATTACK_COUNTERS array we can decrement. (Max value of,0x16)
*,0xDE points to a default value to reset the ALIEN_ATTACK_MASTER_COUNTER back to.
l_1540:
	move.b	#0x00,d2                        	| [ld   c,0x00]
	move.b	(a1),d0                         	| read default value from table @ 0x15E3 [ld   a,(de)]
	move.b	d0,(a0)                         	| Reset ALIEN_ATTACK_MASTER_COUNTER to its default value [ld   (hl),a]

* Decrement B counters in the ALIEN_ATTACK_COUNTERS array.
* If any of the counters hit zero, reset the counter to its default value and set the CAN_ALIEN_ATTACK flag to 1.
l_1544:
	addq.w	#1,a0                           	| bump HL to next secondary counter [inc  hl]
	addq.w	#1,a1                           	| bump DE to address containing default value to reset secondary counter to when zero [inc  de]
	subq.b	#1,(a0)                         	| decrement secondary counter [dec  (hl)]
	bne.b	0f
	jbsr	l_15df                                 	| if the secondary counter reaches zero, reset the counter and increment C. Alien will attack! [call z,0x15DF]
0:
	subq.b	#1,d1                           	| [...]
	jne	l_1544                             	| repeat until B==0 [djnz 0x1544]

* if C is set to a nonzero value then that means that a secondary counter has reached zero. Its time for an alien to attack.
	move.b	d2,d0                          	| [ld   a,c]
	tst.b	d0                               	| test if A is zero [and  a]
	bne.b	0f
	rts                                    	| exit if so [ret  z]
0:
	move.b	#1,CAN_ALIEN_ATTACK            	| set CAN_ALIEN_ATTACK flag. Alien will break off from the swarm [ld   (0x4228),a]
	rts                                    	| [ret]



*
* This routine is responsible for determining when flagships can attack.
*
*

UPDATE_ATTACK_COUNTERS:
	move.b	HAS_PLAYER_SPAWNED,d0                       	| read HAS_PLAYER_SPAWNED [ld   a,(0x4200)]
	ror.b	#1,d0                           	| move flag into carry [rrca]
	bcs.b	0f
	rts                                    	| return if player has not spawned [ret  nc]
0:
	move.b	HAVE_ALIENS_IN_TOP_ROW,d0                       	| read HAVE_ALIENS_IN_TOP_ROW [ld   a,(0x41EF)]
	ror.b	#1,d0                           	| move flag into carry [rrca]
	bcs.b	0f
	rts                                    	| return if we have no flagships [ret  nc]
0:
	move.b	IS_FLAGSHIP_HIT,d0                       	| read IS_FLAGSHIP_HIT [ld   a,(0x422B)]
	ror.b	#1,d0                           	| move flag into carry [rrca]
	bcc.b	0f
	rts                                    	| return if a flagship has been hit [ret  c]
0:
	move.b	IS_GAME_IN_PLAY,d0                       	| read IS_GAME_IN_PLAY [ld   a,(0x4006)]
	ror.b	#1,d0                           	| move flag into carry [rrca]
	jcc	l_15a7                             	| if game is not in play, goto 0x15A7 [jr   nc,0x15A7]

* wait until FLAGSHIP_ATTACK_MASTER_COUNTER_1 counts down to zero.
	lea	FLAGSHIP_ATTACK_MASTER_COUNTER_1,a0                      	| load HL with address of FLAGSHIP_ATTACK_MASTER_COUNTER_1 [ld   hl,0x4245]
	subq.b	#1,(a0)                         	| decrement counter [dec  (hl)]
	beq.b	0f
	rts                                    	| exit if counter is not zero [ret  nz]
0:
	move.b	#0x3C,(a0)                      	| reset counter [ld   (hl),0x3C]

* if we have no blue or purple aliens, we don't need to bother with the FLAGSHIP_ATTACK_MASTER_COUNTER_2 countdown.
	move.b	HAVE_NO_BLUE_OR_PURPLE_ALIENS,d0                       	| read HAVE_NO_BLUE_OR_PURPLE_ALIENS [ld   a,(0x4221)]
	ror.b	#1,d0                           	| move flag into carry [rrca]
	jcs	l_15a3                             	| if there's no blue or purple aliens left, goto 0x15A3 [jr   c,0x15A3]

* otherwise, wait until FLAGSHIP_ATTACK_MASTER_COUNTER_2 counts down to 0.
	lea		FLAGSHIP_ATTACK_MASTER_COUNTER_2,a0                           	| bump HL to FLAGSHIP_ATTACK_MASTER_COUNTER_2 [inc  hl]
	subq.b	#1,(a0)                         	| decrement counter [dec  (hl)]
	beq.b	0f
	rts                                    	| return if its not counteed down to zero. [ret  nz]
0:
	addq.b	#1,(a0)                         	| set FLAGSHIP_ATTACK_MASTER_COUNTER_2 to 1 [inc  (hl)]

* count how many "extra" flagships we have carried over from previous waves (maximum of 2)
	lea	ALIEN_SWARM_FLAGS+0x77,a0       	| point to usually empty flagship entry in ALIEN_SWARM_FLAGS. [ld   hl,(0x4177)]
	move.b	(1,a0),d0                           	| [ld   a,h]
	add.b	(a0),d0                             	| A now = number of *extra* flagships we have [add  a,l]
	and.b	#0x03,d0                         	| ensure that number is between 0..3. (it should be between 0..2 anyway) [and  0x03]
	move.b	d0,d2                          	| save count of extra flagships in C [ld   c,a]

* use difficulty settings and count of extra flagships to compute countdown before flagship attack
	move.b	DIFFICULTY_BASE_VALUE,d5
	move.b	DIFFICULTY_EXTRA_VALUE,d6 	| load H with DIFFICULTY_BASE_VALUE and L with DIFFICULTY_EXTRA_VALUE [ld   hl,(0x421A)]
	move.b	d6,d0                           	| [ld   a,h]
	add.b	d5,d0                             	| Add DIFFICULTY_BASE_VALUE to DIFFICULTY_EXTRA_VALUE [add  a,l]
	bne.b	0f
	rts                                    	| exit if both DIFFICULTY_BASE_VALUE and DIFFICULTY_EXTRA_VALUE are 0 [ret  z]
0:

	lsr.b	#2,d0                           	| divide A.. [rrca]
												| by 4 [rrca]
	and.b	#0x03,d0                         	| clamp A to 3 maximum. [and  0x03]
    not.b   d0                                     	| A = 255-A.
	add.b	#0x0A,d0                         	| ensure that A is between 0x06 and 0x09 [add  a,0x0A]
	sub.b	d2,d0                            	| subtract count of extra flagships [sub  c]
	move.b	d0,FLAGSHIP_ATTACK_MASTER_COUNTER_2        	| set FLAGSHIP_ATTACK_MASTER_COUNTER_2 [ld   (0x4246),a]

* set timer for when flagship will definitely attack.
l_1594:
	rol.b	#2,d0                           	| [rlca]*2
	move.b	d0,FLAGSHIP_ATTACK_SECONDARY_COUNTER                       	| set FLAGSHIP_ATTACK_SECONDARY_COUNTER [ld   (0x422F),a]

	rol.b	#1,d0                           	| [rlca]
	move.b	d0,ALIEN_ATTACK_MASTER_COUNTER                       	| set ALIEN_ATTACK_MASTER_COUNTER [ld   (0x424A),a]

* enable timer for flagship to attack.
	move.b	#0x01,ENABLE_FLAGSHIP_ATTACK_SECONDARY_COUNTER                       	| set ENABLE_FLAGSHIP_ATTACK_SECONDARY_COUNTER [ld   (0x422E),a]
	rts                                    	| [ret]

l_15a3:
	move.b	#0x02,d0                        	| [ld   a,0x02]
	jra	l_1594                             	| [jr   0x1594]


* Called when game is not in play
l_15a7:
	lea	FLAGSHIP_ATTACK_MASTER_COUNTER_1,a0        	| load HL with address of FLAGSHIP_ATTACK_MASTER_COUNTER_1 [ld   hl,0x4245]
	subq.b	#1,(a0)                         	| [dec  (hl)]
	beq.b	0f
	rts                                    	| [ret  nz]
0:
	move.b	#0x3C,(a0)                      	| [ld   (hl),0x3C]
	lea		FLAGSHIP_ATTACK_MASTER_COUNTER_2,a0                           	| load HL with address of FLAGSHIP_ATTACK_MASTER_COUNTER_2 [inc  hl]
	subq.b	#1,(a0)                         	| [dec  (hl)]
	beq.b	0f
	rts                                    	| [ret  nz]
0:
	move.b	#0x05,(a0)                      	| [ld   (hl),0x05]

	move.b	#0x5A,FLAGSHIP_ATTACK_SECONDARY_COUNTER                       	| set FLAGSHIP_ATTACK_SECONDARY_COUNTER [ld   (0x422F),a]

	move.b	#0x2D,ALIEN_ATTACK_MASTER_COUNTER                       	| set ALIEN_ATTACK_MASTER_COUNTER [ld   (0x424A),a]

	move.b	#0x01,ENABLE_FLAGSHIP_ATTACK_SECONDARY_COUNTER                       	| set ENABLE_FLAGSHIP_ATTACK_SECONDARY_COUNTER [ld   (0x422E),a]
	rts                                    	| [ret]


*
* Determines if a flagship can be permitted to attack.
*
* If so, CAN_FLAGSHIP_OR_RED_ALIENS_ATTACK is set to 1.
*


CHECK_IF_FLAGSHIP_CAN_ATTACK:
	tst.b	ENABLE_FLAGSHIP_ATTACK_SECONDARY_COUNTER                         	| test flag [bit  0,(hl)]
	bne.b	0f
	rts                                    	| return if not allowed to count down [ret  z]
0:

* wait until FLAGSHIP_ATTACK_SECONDARY_COUNTER counts down to zero.
	subq.b	#1,FLAGSHIP_ATTACK_SECONDARY_COUNTER                         	| decrement counter [dec  (hl)]
	beq.b	0f
	rts                                    	| return if counter hasn't reached zero [ret  nz]
0:
	clr.b	ENABLE_FLAGSHIP_ATTACK_SECONDARY_COUNTER                      	| reset flag [ld   (hl),0x00]
	tst.b	HAS_PLAYER_SPAWNED                  	| read HAS_PLAYER_SPAWNED [ld   a,(0x4200)]
	bne.b	0f
	rts                                    	| return if player has not spawned [ret  nc]
0:

* check if we have any flagship
	move.b	HAVE_ALIENS_IN_TOP_ROW,d0                       	| read HAVE_ALIENS_IN_TOP_ROW flag [ld   a,(0x41EF)]
	ror.b	#1,d0                           	| move flag bit into carry [rrca]
	bcs.b	0f
	rts                                    	| return if no flagships [ret  nc]
0:

* yes, we have flagships, set CAN_FLAGSHIP_OR_RED_ALIENS_ATTACK flag
	move.b	#0x01,CAN_FLAGSHIP_OR_RED_ALIENS_ATTACK	| set CAN_FLAGSHIP_OR_RED_ALIENS_ATTACK [ld   (0x4229),a]
	rts                                    	| [ret]


* A= *DE                                	|
* *HL = A                               	|
* C++
l_15df:
	move.b	(a1),d0                         	| [ld   a,(de)]
	move.b	d0,(a0)                         	| [ld   (hl),a]
	addq.b	#1,d2                           	| [inc  c]
	rts                                    	| [ret]


* Default values for the corresponding entries in the ALIEN_ATTACK_COUNTERS array.
* e.g. 0x424A's default value is 5, 0x424B's default value is 0x2F, 0x424C's default is 0x43...
* When any counter hits zero, it is reset to its default value.
ALIEN_ATTACK_COUNTER_DEFAULT_VALUES:
	.byte	0x05,0x2F,0x43,0x77,0x71,0x6D,0x67,0x65,0x4F,0x49,0x43,0x3D,0x3B,0x35,0x2B,0x29


*
* This routine calculates how far away from the player inflight aliens can be before they can start shooting at you.
*
* The minimum shooting distance increases as more aliens are killed, making the aliens shoot more often.
*
* See also: 0x0E54

HANDLE_CALC_INFLIGHT_ALIEN_SHOOTING_DISTANCE:
	lea	HAVE_ALIENS_IN_ROW_FLAGS,a0                      	| load HL with address of HAVE_ALIENS_IN_ROW_FLAGS [ld   hl,0x41E8]
	move.b	#0x04,d1                        	| we're testing potentially 4 pairs of rows. [ld   b,0x04]
	move.b	DIFFICULTY_BASE_VALUE,d0                       	| read DIFFICULTY_BASE_VALUE [ld   a,(0x421B)]
	tst.b	d0                               	| test if zero [and  a]
	jne	l_1615                             	| if non-zero, which it always is, goto 0x1615 [jr   nz,0x1615]

* These two lines of code appear never to be called. This must be for an EASY difficulty level we've not seen.
	move.b	#1,d4		| ld   e,0x01                             	| multiplier = 1
	move.b	#0x84,d3	| ld   d,0x84                             	| exact X coordinate

l_1603:
	tst.b	(a0)                         	| test for alien presence [bit  0,(hl)]
	jne	l_1610                             	| if alien is present, goto 0x1610 [jr   nz,0x1610]

	addq.w	#1,a0                           	| bump HL to flag for next row [inc  hl]
	tst.b	(a0)                         	| test flag [bit  0,(hl)]
	jne	l_1610                             	| if flag is set, goto 0x1610 [jr   nz,0x1610]

	addq.w	#1,a0                           	| bump to next entry in HAVE_ALIENS_IN_ROW_FLAGS [inc  hl]
	addq.b	#1,d4                            	| increment multiplier (see 0x0E54 for clarification on how its used) [inc  e]
	subq.b	#1,d1                           	| [...]
	jne	l_1603                             	| [djnz 0x1603]

l_1610:
	move.b	d3,INFLIGHT_ALIEN_SHOOT_EXACT_X
	move.b	d4,INFLIGHT_ALIEN_SHOOT_RANGE_MUL                   	| set INFLIGHT_ALIEN_SHOOT_EXACT_X to D, INFLIGHT_ALIEN_SHOOT_RANGE_MUL to E [ld   (0x4213),de]
	rts                                    	| [ret]

l_1615:
	move.b	#2,d4			| [ld   e,0x02]                             	| multiplier = 2
	move.b	#0x9D,d3		| [ld   d,0x9D]                             	| exact X coordinate
	jra	l_1603                             	| [jr   0x1603]

* TODO: I can't find anything calling this. Is this debug code left over?
*ld   e,0x03
*ld   d,0xB6
*	jra	l_1603                             	| [jr   0x1603]


*
* LEVEL_COMPLETE is set to 1 by this function when:
* HAVE_NO_ALIENS_IN_SWARM is set to 1 AND
* HAVE_NO_INFLIGHT_OR_DYING_ALIENS is set to 1 AND
* LEVEL_COMPLETE is clear
*

CHECK_IF_LEVEL_IS_COMPLETE:
	move.b	HAVE_NO_ALIENS_IN_SWARM,d0                       	| read HAVE_NO_ALIENS_IN_SWARM [ld   a,(0x4220)]
	ror.b	#1,d0                           	| move flag bit into carry [rrca]
	bcs.b	0f
	rts                                    	| return if flag is not set, meaning that there are aliens left in the swarm [ret  nc]
0:
	move.b	HAVE_NO_INFLIGHT_OR_DYING_ALIENS,d0                       	| read HAVE_NO_INFLIGHT_OR_DYING_ALIENS [ld   a,(0x4225)]
	ror.b	#1,d0                           	| move flag bit into carry [rrca]
	bcs.b	0f
	rts                                    	| return if flag is not set, meaning that there are aliens attacking, or dying [ret  nc]
0:
	move.b	LEVEL_COMPLETE,d0                       	| read LEVEL_COMPLETE [ld   a,(0x4222)]
	ror.b	#1,d0                           	| move flag bit into carry [rrca]
	bcc.b	0f
	rts                                    	| return if flag is not set [ret  c]
0:
	move.b	#1,LEVEL_COMPLETE
	clr.b	NEXT_LEVEL_DELAY_COUNTER	| set LEVEL_COMPLETE to 1 and NEXT_LEVEL_DELAY_COUNTER to 0. [ld   (0x4222),hl]
	rts                                    	| [ret]



HANDLE_LEVEL_COMPLETE:
	tst.b	LEVEL_COMPLETE                      	| load HL with address of LEVEL_COMPLETE [ld   hl,0x4222]
	bne.b	0f
	rts                                    	| return if level is not complete [ret  z]
0:

* OK, level is complete. Wait until NEXT_LEVEL_DELAY_COUNTER to reach 0.                   	
	subq.b	#1,NEXT_LEVEL_DELAY_COUNTER                         	| decrement count [dec  (hl)]
	beq.b	0f
	rts                                    	| return if count is !=0 [ret  nz]
0:

	                      	| bump HL to point to LEVEL_COMPLETE again. [dec  hl]
	clr.b	LEVEL_COMPLETE                      	| clear LEVEL_COMPLETE flag. [ld   (hl),0x00]

	lea	PACKED_DEFAULT_SWARM_DEFINITION,a1                      	| load DE with address of PACKED_DEFAULT_SWARM_DEFINITION [ld   de,0x051B]
	jbsr	UNPACK_ALIEN_SWARM                            	| call UNPACK_ALIEN_SWARM [call 0x0646]
	clr.b	DIFFICULTY_EXTRA_VALUE                       	| reset DIFFICULTY_EXTRA_VALUE [ld   (0x421A),a]
	clr.b	TIMING_VARIABLE                       	| reset TIMING_VARIABLE [ld   (0x425F),a]
	                      	| [ld   hl,0x0001]
	move.w	#1,SWARM_SCROLL_VALUE                       	| set SWARM_SCROLL_VALUE [ld   (0x420E),hl]

* increase game difficulty level, if we can.
	move.b	PLAYER_LEVEL,d5
	move.b	DIFFICULTY_BASE_VALUE,d6	| load H with PLAYER_LEVEL and L with DIFFICULTY_BASE_VALUE [ld   hl,(0x421B)]
	addq.b	#1,d5                            	| increment player level [inc  h]
	move.b	d6,d0                           	| load A with DIFFICULTY_BASE_VALUE [ld   a,l]
	cmp.b	#0x07,d0                         	| are we at max difficulty? [cp   0x07]
	jeq	l_1662                             	| yes, goto 0x1662 [jr   z,0x1662]
	jcc	CLAMP_DIFFICULTY_LEVEL                             	| edge case: we're above max difficulty! So clamp difficulty level to 7. [jr   nc,0x1683]
	addq.b	#1,d0                           	| otherwise, increment DIFFICULTY_BASE_VALUE [inc  a]
l_1662:
	move.b	d5,PLAYER_LEVEL
	move.b	d6,DIFFICULTY_BASE_VALUE 	| update PLAYER_LEVEL and DIFFICULTY_BASE_VALUE [ld   (0x421B),hl]

	move.l	#0x700,d3                      	| command: DISPLAY_BOTTOM_OF_SCREEN_COMMAND, parameter: 0 (DISPLAY_LEVEL_FLAGS) [ld   de,0x0700]
	jbsr	QUEUE_COMMAND                            	| call QUEUE_COMMAND. [call 0x08F2]

* How many flagships survived from the last round? If so, they need to be added into the swarm before the level starts.
	move.b	FLAGSHIP_SURVIVOR_COUNT,d0                       	| get value of FLAGSHIP_SURVIVOR_COUNT into A [ld   a,(0x421E)]
	tst.b	d0                               	| Did any flagships survive from the last round? [and  a]
	bne.b	0f
	rts                                    	| Return if no flagships survived. [ret  z]
0:
	lea	ALIEN_SWARM_FLAGS+0x77,a0      	| load HL with address of free slot in flagship row of ALIEN_SWARM_FLAGS [ld   hl,0x4177]
	move.b	#0x01,(a0)                      	| create a flagship! [ld   (hl),0x01]
	subq.b	#1,d0                           	| [dec  a]
	move.b	d0,FLAGSHIP_SURVIVOR_COUNT                       	| set value of FLAGSHIP_SURVIVOR_COUNT [ld   (0x421E),a]
	bne.b	0f
	rts                                    	| return if zero. [ret  z]
0:
	addq.w	#1,a0                           	| bump HL to address of next free slot in flagship row [inc  hl]
	move.b	#0x01,(a0)                      	| create a flagship! [ld   (hl),0x01]
	moveq	#0,d0                            	| [xor  a]
	move.b	d0,FLAGSHIP_SURVIVOR_COUNT                       	| clear value of FLAGSHIP_SURVIVOR_COUNT [ld   (0x421E),a]
	rts                                    	| [ret]



CLAMP_DIFFICULTY_LEVEL:
	move.b	#0x07,d0                        	| maximum value for DIFFICULTY_BASE_VALUE [ld   a,0x07]
	jra	l_1662                             	| set DIFFICULTY_BASE_VALUE [jp   0x1662]


*
* When you shoot a flagship, the swarm goes into shock for a short period of time. No aliens will break off to attack you.
*

HANDLE_SHOCKED_SWARM:
	lea	IS_FLAGSHIP_HIT,a0                      	| load HL with address of IS_FLAGSHIP_HIT flag [ld   hl,0x422B]
	btst.b	#0,(a0)                         	| test flag [bit  0,(hl)]
	bne.b	0f
	rts                                    	| return if flagship has not been hit [ret  z]
0:
	move.b	HAVE_AGGRESSIVE_ALIENS,d0                       	| read HAVE_AGGRESSIVE_ALIENS flag [ld   a,(0x4224)]
	tst.b	d0                               	| test flag [and  a]
	jne	l_169f                             	| if flag is set, goto 0x169F [jr   nz,0x169F]
	move.b	HAVE_NO_BLUE_OR_PURPLE_ALIENS,d0                       	| read HAVE_NO_BLUE_OR_PURPLE_ALIENS [ld   a,(0x4221)]
	tst.b	d0                               	| test flag [and  a]
	jne	l_169f                             	| if flag is set, goto 0x169F [jr   nz,0x169F]
	move.b	HAVE_NO_INFLIGHT_ALIENS,d0                       	| read HAVE_NO_INFLIGHT_ALIENS [ld   a,(0x4226)]
	ror.b	#1,d0                           	| move flag into carry [rrca]
	bcs.b	0f
	rts                                    	| return if some aliens are inflight [ret  nc]
0:
l_169f:
	                           	| bump HL to address of ALIENS_IN_SHOCK_COUNTER [inc  hl]
	subq.b	#1,ALIENS_IN_SHOCK_COUNTER                         	| decrement counter. When it hits zero, aliens will snap out of it! [dec  (hl)]
	beq.b	0f
	rts                                    	| exit routine if counter non-zero [ret  nz]
0:
	                         	| bump HL to address of IS_FLAGSHIP_HIT [dec  hl]
	clr.b	IS_FLAGSHIP_HIT                      	| clear flag. Aliens can break off from the swarm to attack again. [ld   (hl),0x00]
	rts                                    	| [ret]

*
* Looks like this might be legacy code imported from an older game	| it writes to a port that does nothing
*

*	move.b	l_4007,d0                       	| read IS_GAME_OVER flag [ld   a,(0x4007)]
*	ror.b	#1,d0                           	| move bit 0 into carry [rrca]
*	bcc.b	0f
*	rts                                    	| if carry set, return [ret  c]
*0:
*	lea	ALIEN_DEATH_SOUND,a0                      	| [ld   hl,0x41DF]
*	move.b	(a0),d0                         	| [ld   a,(hl)]
*	tst.b	d0                               	| [and  a]
*	bne.b	0f
*	rts                                    	| [ret  z]
*0:
*	ror.b	#1,d0                           	| [rrca]
*	ror.b	#1,d0                           	| [rrca]
*	move.b	d0,l_6804                       	| Does nothing - this port is not connected [ld   (0x6804),a]
*	subq.b	#1,(a0)                         	| [dec  (hl)]
*	rts                                    	| [ret]
*

*
* You may have noticed that when you're close to obliterating the swarm, that the background swarm noises
* get fewer and fewer, until there's no background noise, just the sound of attacking aliens and your bullets.
* This is the routine that handles the background noises. But this isn't the most important thing the routine does.
*
* Tucked away here is more important code, which affects the aliens aggressiveness. If you have 3 aliens or less
* in the swarm (inflight aliens don't count), the aliens are enraged and will be far more aggressive.
* Any aliens that take flight to attack you (inflight aliens) will never return to the swarm and keep attacking
* until either you or they are dead.
*
* If you wish to artificially enforce aggressiveness, pause the game and input the following into the MAME debugger:
*
* maincpu.mb@16e3=c9
* maincpu.mb@16e7=c9
* maincpu.pb@4224=1       // note the .pb, not .mb
*
* This will make the aliens attack you constantly - even when you start a new level.

HANDLE_ALIEN_AGGRESSIVENESS:
	tst.b	IS_GAME_OVER                       	| read IS_GAME_OVER flag [ld   a,(0x4007)]
	beq.b	0f
	rts                                    	| return if GAME OVER [ret  c]
0:
	lea	ALIEN_SWARM_FLAGS+0x23,a0                      	| load HL with address of very first alien in ALIEN_SWARM_FLAGS [ld   hl,0x4123]
											| DE is an offset to add to HL after processing a row of aliens [ld   de,0x0006]
	move.b	#6,d2                           	| Conveniently, E is also number of rows of aliens in swarm! (6) [ld   c,e]
	move.b	#0x01,d0                        	| A is going to be used to total the number of aliens in the swarm [ld   a,0x01]
l_16c6:
	move.b	#0x0A,d1                        	| 10 aliens maximum per row [ld   b,0x0A]
l_16c8:
	add.b	(a0)+,d0                          	| [add  a,(hl)]
											| bump HL to point to next alien in ALIEN_SWARM_FLAGS [inc  l]
	subq.b	#1,d1                           	| [...]
	jne	l_16c8                             	| repeat until all aliens in the row have been done [djnz 0x16C8]
	addq.w	#6,a0                              	| make HL point to first alien in row above  [add  hl,de]
	subq.b	#1,d2                           	| do rows until C==0 [dec  c]
	jne	l_16c6                             	| [jp   nz,0x16C6]

* When we get here, A = total number of aliens left alive in the swarm + 1
	**lea	l_6800,a0                      	| load HL with address of !SOUND  reset background F1 port [ld   hl,0x6800]
	move.b	#0x03,d1                        	| number of ports to write to maximum [ld   b,0x03]
l_16d6:
	subq.b	#1,d0                           	| decrement total by 1 [dec  a]
	jeq	l_16ed                             	| if total is zero, goto 0x16ED [jr   z,0x16ED]

* This piece of code writes 1 to !SOUND  reset background,0xF1 to,0xF3
	**move.b	#0x01,(a0)                      	| [ld   (hl),0x01]
	addq.w	#1,a0                            	| [inc  l]
	subq.b	#1,d1                           	| [...]
	jne	l_16d6                             	| [djnz 0x16D6]

l_16de:
	cmp.b	#0x02,d0                         	| [cp   0x02]
	jcs	l_16e7                             	| [jr   c,0x16E7]
	clr.b	HAVE_AGGRESSIVE_ALIENS                       	| clear HAVE_AGGRESSIVE_ALIENS flag [ld   (0x4224),a]
	rts                                    	| [ret]

* This piece of code is only called when there are 3 aliens or less in the swarm.
* It makes the aliens extremely aggressive!
l_16e7:
	move.b	#0x01,HAVE_AGGRESSIVE_ALIENS                       	| set HAVE_AGGRESSIVE_ALIENS flag [ld   (0x4224),a]
	rts                                    	| [ret]

* This piece of code writes 0 to !SOUND  reset background,0xF1 to,0xF3
l_16ed:
	*TODO change background aggressive sound
	jra	l_16de                             	| [jp   0x16DE]


** I try to put data in the end

bad_rom:
	dc.b	0x1D,0x1F,0x22,0x10,0x14,0x11,0x12 



DEFAULT_SWARM_DEFINITION_AND_PLAYER_STATE:    | EQU 0x051B
PACKED_DEFAULT_SWARM_DEFINITION:
    | The first 16 bytes defining the default alien swarm. 
    | For information on how the bytes are unpacked, please see docs @ 0x0646
    .byte	0x00,0x00,0x00,0x00,0xF8,0x1F,0xF8,0x1F,0xF8,0x1F,0xF0,0x0F,0xE0,0x07,0x40,0x02

    | When starting a new game, these are the default values 
DEFAULT_PLAYER_STATE:
	.byte	0x3C                                 | Default value for DIFFICULTY_COUNTER_1 
    .byte	0x14                                 | Default value for DIFFICULTY_COUNTER_2
    .byte	0x00,0x02,0x00,0x02,0x00,0x0F,0x00,0x00,0x00     

* Referenced by code @ 0x0595
COLOUR_ATTRIBUTE_TABLE_1:
	.byte	0x00,0x05,0x00,0x00,0x01,0x01,0x02,0x03,0x03,0x04,0x04,0x04,0x04,0x00,0x00,0x00
	.byte	0x00,0x00,0x00,0x05,0x05,0x05,0x05,0x05,0x00,0x00,0x06,0x06,0x06,0x06,0x06,0x06
	
* Referenced by code @ 0x0408
COLOUR_ATTRIBUTE_TABLE_2:
	.byte	0x00,0x05,0x00,0x00,0x01,0x01,0x02,0x03,0x03,0x04,0x04,0x04,0x04,0x00,0x00,0x00
	.byte	0x06,0x06,0x06,0x06,0x06,0x06,0x05,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06

* Referenced by code @ 0x0212
COLOUR_ATTRIBUTE_TABLE_3:
	.byte	0x00,0x05,0x00,0x00,0x01,0x01,0x02,0x03,0x05,0x04,0x05,0x04,0x04,0x00,0x00,0x00
	.byte	0x00,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x06,0x00,0x00,0x07,0x07,0x06,0x06
* ",".join("0x{}".format(x) for x in s.split())

* Referenced by code @ 0x0D1D
l_1DD1:
	.byte	0x00,0x00,0x00,0x00,0x04,0x01,0x04,0x02,0x04,0x01,0x03,0x03,0x02,0x02,0x01,0x02

* address to print followed by text
	.align	2
TXT_GAME_OVER:
	.word	0x5296
	.ascii	"GAME@@OVER?"
	.align	2
TXT_PUSH_START_BUTTON:
	.word	0x52f1
	.ascii	"PUSH@START@BUTTON?"
	.align	2
TXT_PLAYER_ONE:
	.word	0x5294
	.ascii	"PLAYER@ONE?"
	.align	2
TXT_PLAYER_TWO:
	.word	0x5294
	.ascii	"PLAYER@TWO?"
	.align	2
TXT_HIGH_SCORE:
	.word	0x5280
	.ascii	"HIGH@SCORE?"
	.align	2
TXT_CREDIT:
	.word	0x537F
	.ascii	"CREDIT?"
	.align	2
TXT_BONUS_GALIXIP_FOR___000_PTS:
	.word	0x5398
	.ascii	"BONUS@GALIXIP@FOR@@@000@"
	.byte	0xD0,0xD1,0xD2,0x3F
	.align	2
TXT_CONVOY_CHARGER:
	.word	0x52D1
	.ascii	"CONVOY@@CHARGER?"
	.align	2
TXT___SCORE_ADVANCE_TABLE__:
	.word	0x534F
	.ascii	"[@SCORE@ADVANCE@TABLE@[?"
	.align	2
TXT_MISSION__DESTROY_ALIENS:
	.word	0x5369
	.ascii	"MISSION"
	.byte	0xd3
	.ascii	"@DESTROY@ALIENS?"
	.align	2
TXT_WE_ARE_THE_GALAXIANS:
	.word	0x5327
	.ascii	"WE@ARE@THE@GALAXIANS?"
	.align	2
TXT_30_______60__PTS:
	.word	0x52D9
	.ascii	"@@30@@@@@@@60@@"
	.byte	0xD0,0xD1,0xD2,0x3F	| pts
	.align	2
TXT_40_______80__PTS:
	.word	0x52D7
	.ascii	"@@40@@@@@@@80@@"
	.byte	0xD0,0xD1,0xD2,0x3F
	.align	2
TXT_50______100__PTS:
	.word	0x52D5
	.ascii	"@@50@@@@@@100@@"
	.byte	0xD0,0xD1,0xD2,0x3F
	.align	2
TXT_60______300__PTS:
	.word	0X52D3
	.ascii	"@@60@@@@@@300@@"
	.byte	0xD0,0xD1,0xD2,0x3F
	.align	2
TXT_NAMCO_logo:
	.word	0x527C
	.byte	0xCA,0xCB,0xCC,0xCD,0xCE,0xCF,0x9E,0x9F,0x3F
	.align	2
TXT_FREE_PLAY:
	.word	0x537F
	.ascii	"FREE@PLAY?"

* The tables @0x039A and 0x03A6 represent the points values displayed beneath the SCORE ADVANCE TABLE.
* These values are NOT BCD! They are ordinals for characters to be POKEd directly to character RAM.

* This table is for the Flagship
flagship_table_039A: 
	.byte	0x01,0x05,0x00            | 150 
	.byte	0x02,0x00,0x00            | 200
	.byte	0x03,0x00,0x00            | 300
	.byte	0x08,0x00,0x00            | 800

* This table is for the normal aliens
* Note: 10 is a space (empty) character
alien_table_03A6: 
	.byte	0x01,0x00,0x00            | 100   
	.byte	0x10,0x08,0x00            |  80   
	.byte	0x10,0x06,0x00            |  60    
	.align	2

bcd_table:
	.byte	0x0
	.byte	0x1
	.byte	0x2
	.byte	0x3
	.byte	0x4
	.byte	0x5
	.byte	0x6
	.byte	0x7
	.byte	0x8
	.byte	0x9
	.byte	0x10
	.byte	0x11
	.byte	0x12
	.byte	0x13
	.byte	0x14
	.byte	0x15
	.byte	0x16
	.byte	0x17
	.byte	0x18
	.byte	0x19
	.byte	0x20
	.byte	0x21
	.byte	0x22
	.byte	0x23
	.byte	0x24
	.byte	0x25
	.byte	0x26
	.byte	0x27
	.byte	0x28
	.byte	0x29
	.byte	0x30
	.byte	0x31
	.byte	0x32
	.byte	0x33
	.byte	0x34
	.byte	0x35
	.byte	0x36
	.byte	0x37
	.byte	0x38
	.byte	0x39
	.byte	0x40
	.byte	0x41
	.byte	0x42
	.byte	0x43
	.byte	0x44
	.byte	0x45
	.byte	0x46
	.byte	0x47
	.byte	0x48
	.byte	0x49
	.byte	0x50
	.byte	0x51
	.byte	0x52
	.byte	0x53
	.byte	0x54
	.byte	0x55
	.byte	0x56
	.byte	0x57
	.byte	0x58
	.byte	0x59
	.byte	0x60
	.byte	0x61
	.byte	0x62
	.byte	0x63
	.byte	0x64
	.byte	0x65
	.byte	0x66
	.byte	0x67
	.byte	0x68
	.byte	0x69
	.byte	0x70
	.byte	0x71
	.byte	0x72
	.byte	0x73
	.byte	0x74
	.byte	0x75
	.byte	0x76
	.byte	0x77
	.byte	0x78
	.byte	0x79
	.byte	0x80
	.byte	0x81
	.byte	0x82
	.byte	0x83
	.byte	0x84
	.byte	0x85
	.byte	0x86
	.byte	0x87
	.byte	0x88
	.byte	0x89
	.byte	0x90
	.byte	0x91
	.byte	0x92
	.byte	0x93
	.byte	0x94
	.byte	0x95
	.byte	0x96
	.byte	0x97
	.byte	0x98
	.byte	0x99
	
*
* Defines the arc to perform a loop the loop maneuvre. 
* Referenced by code @0x0D71 and 0x101F.
*
* The table comprises byte pairs:
*   byte 0: signed offset to add to INFLIGHT_ALIEN.X
*   byte 1: unsigned offset to add to *or* subtract from (depends on which way alien is facing when it breaks off from swarm) INFLIGHT_ALIEN.Y 
*
INFLIGHT_ALIEN_ARC_TABLE:
	.byte	0xFF,0x00,0xFF,0x00,0xFF,0x00,0xFF,0x01,0xFF,0x00,0xFF,0x00,0xFF,0x01,0xFF,0x00  
	.byte	0xFF,0x01,0xFF,0x00,0x00,0x01,0xFF,0x00,0xFF,0x01,0x00,0x01,0xFF,0x00,0x00,0x01  
	.byte	0xFF,0x01,0x00,0x01,0xFF,0x01,0x00,0x01,0x00,0x01,0xFF,0x01,0x00,0x01,0x00,0x01  
	.byte	0x00,0x01,0x00,0x01,0x00,0x01,0x00,0x01,0x01,0x01,0x00,0x01,0x00,0x01,0x01,0x01  
	.byte	0x00,0x01,0x01,0x01,0x00,0x01,0x01,0x00,0x00,0x01,0x01,0x01,0x01,0x00,0x00,0x01  
	.byte	0x01,0x00,0x01,0x01,0x01,0x00,0x01,0x01,0x01,0x00,0x01,0x00,0x01,0x01,0x01,0x00  
	.byte	0x01,0x00,0x01,0x00,0x01,0x00,0x01

