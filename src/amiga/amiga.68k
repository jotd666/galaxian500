*
*	Amiga-specific portions of Galaxian
*
* (c) JOTD 2023
*

.include "../src/galaxian.inc"
.include "custom.i"
.include "exec_lvos.i"
.include "dos_lvos.i"
.include "graphics_lvos.i"

AttnFlags = 0x128
AFB_68010 = 0
AFB_68020 = 1
NO68020 = 1

SCREEN_ADDRESS = 0x5000

STAR_SPRITE_INDEX = 7
STAR_SPRITE_COLOR_REG = color+(STAR_SPRITE_INDEX/2)*8+34

SPRITE_X_OFFSET = 8
SPRITE_Y_OFFSET = 1

SCORE_FILE_SIZE = 3
BOB_16X16_PLANE_SIZE = 4*16


copper_stars_offset = 12
copper_row_size = 32
copper_8x8_row_size = copper_stars_offset+copper_row_size*8


	.ifdef	RELEASE
OPT_ENABLE_PROFILING = 0
OPT_ENABLE_LOGGING = 0
ONE_TICK = 1
	* check most used options in release mode
	* to avoid creating a version with cheats on!
	.ifne	OPT_DISABLE_BG_LAYER
	.error	"debug option OPT_DISABLE_BG_LAYER in release mode"
	.endif
	.ifne	OPT_DISABLE_SPRITES
	.error	"debug option OPT_DISABLE_SPRITES in release mode"
	.endif
	.ifne	OPT_ALIENS_DONT_SHOOT
	.error	"cheat option OPT_ALIENS_DONT_SHOOT in release mode"
	.endif
	.ifne	OPT_SMALL_SWARM
	.error	"cheat option OPT_SMALL_SWARM in release mode"
	.endif
	.ifne	OPT_START_SCORE
	.error	"nonzero score option in release mode"
	.endif
	.else
OPT_ENABLE_LOGGING = 1
OPT_ENABLE_PROFILING = 0
* set to higher values than 1 to speed game up
ONE_TICK = 1
* galaxian still has some strange sprite/clut combinations
* we choose to ignore them as they're completely bogus
* (ex: 95,12: yellow part of andor genesis, makes no sense,
* Mark says that it happens when starting at level > 1 as
* game isn't designed to do this)

	.endif
	
* double-buffering is really needed here, else blits fail
* to race the beam and flicker is very frequent
* but we can save memory: setting both FG and BG layers mean
* that the chipmem requirements are upped to 1MB...
OPT_ENABLE_DOUBLE_BUFFERING_BG = 0
OPT_ENABLE_DOUBLE_BUFFERING_FG = 1

_custom = 0xDFF000


NB_PLAYFIELD_PLANES = 3
TOTAL_NB_COLORS = 16   | 8+8+16
NB_BYTES_PER_ROW = 40
NB_LINES = 256
Y_MAX = NB_LINES
* big margin to avoid issues!
NB_PLAYFIELD_LINES = NB_LINES+32

BG_SCREEN_PLANE_SIZE = NB_BYTES_PER_ROW*NB_PLAYFIELD_LINES
BG_SCREEN_SIZE =  BG_SCREEN_PLANE_SIZE*NB_PLAYFIELD_PLANES
FG_SCREEN_PLANE_SIZE = BG_SCREEN_PLANE_SIZE
FG_SCREEN_SIZE =  FG_SCREEN_PLANE_SIZE*NB_PLAYFIELD_PLANES

NB_SPRITES_TO_UPDATE = 8
NB_SPRITES_TOTAL = 8
NB_BULLETS_TOTAL = 7
SPRITE_MEM_SIZE = 4
BULLET_MEM_SIZE = 4
SPRITE_SAVE_BUFFER_SIZE = SPRITE_MEM_SIZE*NB_SPRITES_TOTAL+BULLET_MEM_SIZE*NB_BULLETS_TOTAL



	move.l	a7,old_stack
	bra	_user

| write current PC value to some address
.macro LOGPC	address
	.ifndef	RELEASE
     bsr    .next_\@
.next_\@:
      addq.l    #6,(a7) | skip this & next instruction
      move.l    (a7)+,0x\address
	.endif
.endm

.macro	WAIT_BLIT
	move.w	#0x8400,(dmacon,a5)		| blitter high priority
wait\@:
	BTST	#6,(dmaconr,a5)
	BNE.S	wait\@
	move.w	#0x0400,(dmacon,a5)		| blitter normal priority
.endm

.macro MUL_TABLE value,len
mul\value\()_table:
	.set    mulv,0
	.rept	\len
	dc.w	mulv
	.set	mulv,mulv+\value
	.endr
.endm


* debug macro that colors the screen until LMB pressed
.macro 	blitz_bypass
	move.w	d0,-(a7)
	clr.w	d0
loop\@:
	move.w	d0,_custom+color
	btst	#6,0xbfe001
	beq.b	out\@
	addq.w	#1,d0
	bra.b	loop\@
out\@:
	move.w	(a7)+,d0
	nop
.endm

* same thing but if LMB is pressed when entering, macro waits for release)
.macro blitz
w\@:
	btst	#6,0xbfe001
	beq.b	w\@
	blitz_bypass
.endm

    
	
* < D0 as native game offset
* > D0,D1 as amiga X,Y
.macro GET_XY_FROM_OFFSET
	move.w	d0,d1
	subq.w	#2,d1
	and.w	#0x3F,d1	| Y is computed
	lsr.w	#6,d0
	neg.w	d0
	add.w	#32,d0	| mirror: X is computed
.endm

* < D0,D1 as amiga X,Y
* > D0 as plane offset
* > D1 recieves original D1*240 (can be tested against the limit
* for post-processing)
.macro	GET_PLANE_OFFSET_FROM_XY
	* now multiply D1 by 240
	lea		mulNB_BYTES_PER_ROW_table(pc),a1
	.ifdef	NO68020
	add.w	d1,d1
	move.w	(a1,d1.w),d1
	.else
	move.w	(a1,d1.w*2),d1		| times 40
	.endif
	lsl.w	#3,d1		| times 8
	* add y offset to screen data	
	add.w	d1,d0	
	.endm
.macro GET_XY_ADDRESS  base_address
	GET_XY_FROM_OFFSET
	GET_PLANE_OFFSET_FROM_XY	
	* add x offset to screen data
	lea		(\base_address,d0.w),a1
.endm



* exports

	  .global _user
		.global _player_start
		.global _demo_end

* osd layer		
		.global osd_enable_vblank_interrupt
		.global osd_ack_vblank_interrupt
		.global osd_disable_vblank_interrupt
		.global osd_break		| for debug	
		.global osd_calibrate_display		| for debug
		.global osd_w_bg_videoram
		.global osd_reset_attributes
		.global osd_update_graphics
		.global osd_read_dipswitches
		.global osd_read_p1_inputs
		.global osd_read_p2_inputs
		.global osd_read_high_scores
		.global osd_write_high_scores
		.global osd_read_coin
		.global osd_read_start
		.global osd_sound_start
		.global osd_sound_stop
		.global osd_play_alien_attack_loop
		.global osd_stop_alien_attack_loop
		.global	osd_stop_swarm_loop
		.global	osd_play_swarm_loop

	
	.include	"ReadJoypad.i"
	.include	"whdload_funcs.i"
		.text


.list

	.ifne	OPT_ENABLE_PROFILING
	* init profiling if enabled
	.include	"profiler.68k"
	.endif

	    
_user:
    * if D0 contains "WHDL"
    * A0 contains resload
        
    cmp.l   #0x05748444c,D0	| WHDL
    bne.b   .standard
    move.l a0,_resload

	move.l	a0,a2
	lea	(_tag,pc),a0
	jsr	(resload_Control,a2)
	
    bra		.no_forbid
.standard:
	
    * open dos library, graphics library
    move.l  0x4.W,a6
    lea dosname,a1
    moveq.l #0,d0
    jsr _LVOOpenLibrary(a6)
    move.l  d0,_dosbase

	bra		3f
	* todo readargs if kick > 1.3
	*move.l	$4,A6
	*move.w	LIB_VERSION(A6),D1	; exec library version
	*cmp.w	D0,D1
	*bcc.s	knewer
	*moveq.l	#-1,D0
	
	move.l	#read_args_string,d1
	move.l	#program_args,d2
	moveq.l	#0,d3
	move.l	_dosbase,A6
	jsr	_LVOReadArgs(a6)

	move.l	d0,rdargs_struct		| NULL is OK
	bne	0f
	jmp		_LVOExit(a6)
0:	
	lea		program_args,a0
	move.l	(A0)+,D0	| INVINCIBLE/S
	beq.b	1f
	or.l	#1,cheat_flags
1:
	move.l	(A0)+,D0	| INFLIVES/S
	beq.b	2f
	or.l	#2,cheat_flags
2:




	move.l	rdargs_struct,d1
	jsr		_LVOFreeArgs(a6)
3:
	bsr		store_system
	
	lea		_custom,a5
	lea		debug_copperlist,a0
	move.l	a0,cop1lc(a5)

	move.l	4.W,A6
	lea graphicsname,a1
    moveq.l #0,d0
    jsr _LVOOpenLibrary(a6)
    move.l  d0,_gfxbase
    move.l	d0,a6
	move.l	38(a6),old_syscoplist
	move.l	34(A6),old_actiview		| gb_ActiView

	sub.l	a1,a1
	jsr	_LVOLoadView(a6)
	jsr	_LVOWaitTOF(a6)
	jsr	_LVOWaitTOF(a6)

	bsr		load_highscores

    * check if "floppy" file is here
    
    move.l  _dosbase(pc),a6
    move.l   #floppy_file,d1
    move.l  #1005,d2   | MODE_OLDFILE
    jsr     _LVOOpen(a6)
    move.l  d0,d1
    beq.b   .no_floppy
    
    * "floppy" file found
    jsr     _LVOClose(a6)
    * wait 2 seconds for floppy drive to switch off
    move.l  #100,d1
    jsr     _LVODelay(a6)
.no_floppy:

.startup:

* no multitask
    tst.l   _resload
    bne.b   .no_forbid
    *move.l  _gfxbase(pc),a4
    *move.l StartList(a4),gfxbase_copperlist

    move.l  4,a6
    jsr _LVOForbid(a6)

    
	sub.l	A1,A1
	jsr	_LVOFindTask(a6)		| find ourselves
	move.l	D0,A0
	move.l	#-1,184(A0)	| pr_WindowPtr: no more system requesters (insert volume, write protected...)

.no_forbid:
	move.l	dip_switches(pc),d2
	btst	#0,d2
	beq.b	0f
	move.w	#0,start_lives_and_free_ship_dsw
0:
	btst	#1,d2
	beq.b	0f
	move.w	#0xC0,free_play_dsw
0:
	move.l	dip_switch_bonus_ship(pc),d2
	or.w	d2,start_lives_and_free_ship_dsw
	
	* we don't need extra joypad buttons, and that will save a few cycles
	* because reading CD32 joypad is (relatively) costly. Usually it doesn't
	* matter but I've seen issues (Shadow of the beast 3 for instance)
	*
	*jsr	 _detect_controller_types 
	clr.b	controller_joypad_0
	clr.b	controller_joypad_1


		moveq			#2,d0
		*move.b		(BIOS_USER_REQUEST),d0
		lsl.w			#2,d0
    movea.l   1f(pc,d0.w),a0
    jmp       (a0)
    .align 4
1:	.long			startup_init
		.long			eye_catcher
		.long			demo_game
		.long			title_display

startup_init:
		rts

eye_catcher:
* we're not doing things the NeoGeo way
		rts

get_hiscore_name:
    lea normal_hiscorename,a0
	rts
	
load_highscores:
	bsr.b		get_hiscore_name
    move.l  _resload(pc),d0
    bne.b   1f

    move.l  _dosbase(pc),a6
    move.l  a0,d1
    move.l  #1005,d2
    jsr     (_LVOOpen,a6)
    move.l  d0,d1
    beq.b   1f
    move.l  d1,d4
    move.l  #SCORE_FILE_SIZE,d3
    move.l  #high_score_buffer,d2
    jsr (_LVORead,a6)
    move.l  d4,d1
    jsr (_LVOClose,a6)   
	st.b	highscore_loaded
1:
    rts

save_highscores:
	tst.l	_resload
	bne.b	1f
    tst.b   highscore_needs_saving
    beq.b   1f
    move.l  _dosbase(pc),a6
	bsr.b		get_hiscore_name
    move.l  a0,d1
    move.l  #1006,d2
    jsr     (_LVOOpen,a6)
    move.l  d0,d1
    beq.b   1f
    move.l  d1,d4
    move.l  #SCORE_FILE_SIZE,d3
    move.l  #high_score_buffer,d2
    jsr (_LVOWrite,a6)
    move.l  d4,d1
    jsr (_LVOClose,a6)   
1:	
    rts
    
	
* To get the core to run, you just need to jump to galaxian_reset after
* you've initialised the platform (Amiga) stuff. That essentially does a
* Z80 reset. You also need to call galaxian_im1_irq from the Amiga vblank
* routine. They are the only 2 entry points required for the core to run,
* even if there's no other I/O.


demo_game:
		move		#0x4000,_custom+intena						| disable interrupts
		move		#0x7FFF,_custom+intreq						| ack all interrupts
		bsr			platform_init					| amiga-specific init
		move.l	cheat_flags(pc),d0
		btst	#0,D0
		sne		invincible_flag
		btst	#1,D0
		sne		infinite_lives_flag
		
0:	
		jmp			galaxian_reset					| pass control to the galaxian core
		
title_display:
* we're not doing things the NeoGeo way
    rts

_player_start:
* we're not doing things the NeoGeo way
		rts
				
_demo_end:
* we're not doing things the NeoGeo way
		rts
	
				
_vblank:
    movem.l d0-d7/a0-a6,-(a7)
	move.w	_custom+intreqr,d0
	btst	#5,d0
	beq.b		1f

	move.l	_joypad_state(pc),d1
	moveq	#1,d0
	jsr	_read_joystick
	move.l	d0,_joypad_state
	
	* CD32 "play" is disabled but it's free to read
	* 3rd button on a Sega 3-button so 3rd button is pause
	btst	#JPB_BTN_PLAY,d0
	beq.b	0f
	btst	#JPB_BTN_PLAY,d1
	bne.b	0f
	bsr		toggle_pause
0:


	move.w	#0x20,_custom+intreq	
	bra.b	3f
1:
	* has to be copper
	* we're going to ack copper interrupt now
	move.w	#0x10,_custom+intreq
	
	moveq	#ONE_TICK,d1
    move.w  vbl_counter(pc),d0
    addq.w  #1,d0
    cmp.w   #5,d0
    bne.b   22f
    * update a second time, simulate 60Hz
	moveq	#ONE_TICK*2,d1
	clr.w d0    
22:
	move.b	d1,vb_ticks_count
    move.w  d0,vbl_counter
	
	tst.b	pause_flag
	bne.b	23f
	* decrease intro sound lock until zero
	move.w	intro_sound_lock,d0
	beq.b	222f
	subq.w	#1,d0
	move.w	d0,intro_sound_lock
222:
	jbsr		scroll_stars
	jbsr		galaxian_irq
	.ifne  OPT_ENABLE_DOUBLE_BUFFERING_FG+OPT_ENABLE_DOUBLE_BUFFERING_BG
	bsr		switch_screen_buffers
	.endif
23:
	* now we check copper interrupt again
	move.w	_custom+intreqr,d0
	btst	#4,d0
	beq.b	3f		| clear: ok
	* copper interrupt has been called, which means that
	* rendering was so slow that we couldn't cope within a frame
	* skip a tick and ack again, we lose one update frame
	addq.b	#ONE_TICK,vb_ticks_count
	move.w	#0x10,_custom+intreq
3:
    movem.l (a7)+,d0-d7/a0-a6
	
    rte
	
osd_break:
	blitz
	rts
	
osd_calibrate_display:
	movem.l	a0/d0-d1,-(a7)
	move.l	bg_drawed_screen_ptr,a0
	move.w	#NB_LINES-1,d1
	clr		d0
0:
	st.b	(8,a0,d0.W)
	st.b	(9,a0,d0.W)
	st.b	(10,a0,d0.W)
	
	add.w	#NB_BYTES_PER_ROW,d0
	dbf		D1,0b
	movem.l	(a7)+,a0/d0-d1
	rts

	move.l	fg_drawed_screen_ptr,a0
	move.w	#NB_LINES-1,d1
	clr		d0
0:
	st.b	(14,a0,d0.W)
	st.b	(15,a0,d0.W)
	add.w	#NB_BYTES_PER_ROW,d0
	dbf		D1,0b
	movem.l	(a7)+,a0/d0-d1
	rts
	
* < D0.B 0->0xF frequency. 0xF makes the loop play to the max len
osd_play_swarm_loop:
	tst.w	intro_sound_lock
	bne.b	0f
	movem.l	d0/d1/a0/a6,-(a7)
	cmp.b	alien_swarm_loop_frequency,d0
	beq.b	1f			| same freq, don't play

	move.b	d0,alien_swarm_loop_frequency
	and.w	#0xFF,d0
	add.w	d0,d0
	lea		swarm_sound_offsets(pc),a0
	move.w	(a0,d0.w),d0		| sound offset for current freq
	lea		swarm_sound_table(pc),a0
	add.w	d0,a0

	lea		_custom,a6
	jsr		_mt_loopfx
	st.b	alien_swarm_loop_playing
1:
	movem.l	(a7)+,d0/d1/a0/a6
0:
	rts
	
osd_stop_swarm_loop:
	movem.l	d0/d1/a0/a6,-(a7)
	tst.b	alien_swarm_loop_playing
	beq.b	1f
	move.l	#0,d0		| channel
	lea		_custom,a6
	jsr		_mt_stopfx
	clr.b	alien_swarm_loop_playing
	move.b	#-1,alien_swarm_loop_frequency
1:
	movem.l	(a7)+,d0/d1/a0/a6
	rts
	
osd_stop_alien_attack_loop:
	movem.l	d0/d1/a0/a6,-(a7)
	move.l	#2,d0		| present on channel 2
	lea		_custom,a6
	jsr		_mt_stopfx
	clr.b	alien_attack_loop_playing
1:
	movem.l	(a7)+,d0/d1/a0/a6
	rts
	
osd_play_alien_attack_loop:
	movem.l	d0/d1/a0/a6,-(a7)
	tst.b	alien_attack_loop_playing
	bne.b	1f
	lea		_custom,a6
	move.w	#ATTACK_END_SND*8,d0	| present on channel 2
	lea		sound_table,a0
	move.w	(a0,d0.w),d1	| sound type
	beq.b	1f		| no sound

2:
	move.l	(4,a0,d0.w),a0
	lea		_custom,a6
	jsr		_mt_loopfx
	st.b	alien_attack_loop_playing
1:
	movem.l	(a7)+,d0/d1/a0/a6
	rts

	
osd_sound_start:
	movem.l	d0/d1/a0/a6,-(a7)

	cmp.w	#INTRO_SND,d0
	bne.b	0f
	* intro sound played: arm decrease counter: we can't start
	* swarm sound immediately
	move.w	#30,intro_sound_lock
0:
	lea		_custom,a6
	lsl.w	#3,d0
	lea		sound_table,a0
	move.w	(a0,d0.w),d1	| sound type
	beq.b	1f		| no sound

2:
	cmp.w	#1,d1
	bne.b	3f		| music module
	move.l	(4,a0,d0.w),a0
	lea		_custom,a6
	jsr		_mt_playfx
1:
	movem.l	(a7)+,d0/d1/a0/a6
	rts
3:
	* don't play if already playing
	* (music_tick value is not important for looped tunes
	* as long as it's not zero)
	tst.w	music_tick
	bne.b	4f
	* play the proper module pattern
	* load up the countdown if loop
	move.w	(2,a0,d0.w),d1	| pattern number in .mod file
	move.w	(4,a0,d0.w),d2
	move.b	(6,a0,d0.w),music_volume
	move.b	(7,a0,d0.w),music_loops
	move.w	d1,music_pattern
	move.w	d2,music_duration
	* since it's not zero, next vbl tick will play the music
	move.w	d2,music_tick
	move.w	d1,d0
	bsr		play_music
4:
	bra.b	1b

	

osd_sound_stop:
	movem.l	d0/a6,-(a7)
	lea		_custom,a6
    clr.w   music_tick   | not playing anymore
	clr.b	music_playing
	move.b	#-1,alien_swarm_loop_frequency
	clr.b	alien_swarm_loop_playing
    jsr		_mt_end
0:
	movem.l	(a7)+,d0/a6
	rts
	
* < D0: track start number
play_music:
	rts
	
	

	.ifne	OPT_ENABLE_DOUBLE_BUFFERING_FG+OPT_ENABLE_DOUBLE_BUFFERING_BG
switch_screen_buffers:	
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING_BG
	* let's switch screen buffers, background (chars)
	* toggle fg planes (double buffering)
	lea		bg_drawed_screen_ptr(pc),a0
	lea		bg_displayed_screen_ptr(pc),a4
	lea		bg_screen_data_1,a1
	lea		bg_screen_data_2,a5
	* also switch previous state memory
	cmp.l	(a0),a1
	bne.b	2f
	* screen data 1 is displayed screen
	* set it to drawn screen
	exg		a1,a5
2:
	move.l	a1,(a0)
	move.l	a5,(a4)
	jbsr		set_bg_bitplanes
	.endif
	
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING_FG
	* let's switch screen buffers, foreground (sprites)
	* toggle fg planes (double buffering)
	lea		fg_drawed_screen_ptr(pc),a0
	lea		fg_displayed_screen_ptr(pc),a4
	lea		fg_screen_data_1,a1
	lea		fg_screen_data_2,a5
	* also switch previous state memory
	lea		previous_sprite_state_1(pc),a3
	lea		previous_sprite_state_ptr(pc),a2
	cmp.l	(a0),a1
	bne.b	2f
	* screen data 1 is displayed screen
	* set it to drawn screen
	exg		a1,a5
	lea		previous_sprite_state_2(pc),a3
2:
	move.l	a3,(a2)
	move.l	a1,(a0)
	move.l	a5,(a4)
	jra		set_fg_bitplanes
	.endif
	rts
	.endif
	
store_system:
	tst.l	_resload
	beq.b	0f
	rts
0:
	* system copper
	
	move.l	4.W,a6
	move.w	AttnFlags(a6),d0
	btst	#AFB_68010,d0
	beq.b	1f
	lea	get_vbr,a5
	jsr		_LVOSupervisor(a6)
	move.l	d0,system_vbr
1:
	
	move.w	AttnFlags(a6),d0
	btst	#AFB_68020,d0
	bne.b	1f
	* no whdload, no 68020: assume slow
	* if running on PiStorm, well, too bad use whdload
	st.b	slow_machine
1:
	lea	_custom,a6
	move.w	intenar(a6),old_intena
	move.w	dmaconr(a6),old_dmacon
	lea		old_sysvectors,a0
	move.l	system_vbr(pc),a1
	move.l	(0x64,a1),(a0)+
	move.l	(0x68,a1),(a0)+
	move.l	(0x6c,a1),(a0)+
	move.l	(0x70,a1),(a0)+
	move.l	(0x74,a1),(a0)+
	move.l	(0x78,a1),(a0)+
	rts

restore_system:
	lea	_custom,a6
	jsr		_mt_remove_cia

	move.w	#0x4000,intena(a6)	| ints off
	lea		old_sysvectors,a0
	move.l	system_vbr(pc),a1
	move.l	(a0)+,(0x0064,a1)
	move.l	(a0)+,(0x0068,a1)
	move.l	(a0)+,(0x006c,a1)
	move.l	(a0)+,(0x0070,a1)
	move.l	(a0)+,(0x0074,a1)
	move.l	(a0)+,(0x0078,a1)


	bclr	#6,0xbfee01


	lea	_custom,a6
	move.w	old_intena,d0			| get old val
	and.w	#0x3fff,d0
	eor.w	#0x3fff,d0
	move.w	d0,intena(a6)		| clr bits
	eor.w	#0x3fff,d0
	or.w	#0xc000,d0		
	move.w	d0,intena(a6)		| set bits and main

	move.w	old_dmacon,d0			| get old val
	and.w	#0x3fff,d0
	eor.w	#0x3fff,d0

***		and.w	#0xfff0,d0		| preserve sound dma for now

	move.w	d0,dmacon(a6)		| clr bits



	eor.w	#0x3fff,d0
	or.w	#0xc000,d0		
	move.w	d0,dmacon(a6)		| set bits and main

	move.l	old_syscoplist,cop1lc(a6)
	move.l	_gfxbase,a6
	move.l	old_actiview,a1
	jsr	_LVOLoadView(a6)


	moveq	#0,d0
	rts

quit_to_os:
	bsr		restore_system
	move.w	#0,SR
	move.l	old_stack(pc),a7
	bsr		save_highscores
	moveq	#0,d0
	rts
	

platform_init:
	bsr		store_system
	
	lea		_custom,a5
	move.w	#0x7FFF,dmacon(a5)
	move.w	#0x7FFF,intena(a5)
	* set blitter parameters once and for all
	.ifndef	VARIABLE_BLITTER_MASKS_AND_MODS
    move.l  #-1,bltafwm(a5)
	.endif
	
	* restrict borders: we don't see bobs on the borders!
    move.w #0x1C99,diwstrt(a5)
    move.w #0x1C81-8,diwstop(a5)
    move.w #0x0038,ddfstrt(a5)
    move.w #0x00D0,ddfstop(a5)
    move.w #0x6600,bplcon0(a5) | 6 bitplanes, dual playfield
    move.w #0x0048,bplcon2(a5)     | sprite starfield behind, pf2 has priority
	* AGA-compatible ECS default values
    move.w #0x0C00,bplcon3(a5)     | no AGA specificities, default ECS
    move.w #0x0011,bplcon4(a5)     | ECS default for sprite colors
    move.w #0,fmode(a5)			
	

	* screen with galaxian bg/fg tiles
    **move.w #2<<4,bplcon1(a5)    | foreground tiles shifted by 2 pixels
    move.w #0,bplcon1(a5)    | foreground tiles
	move.w	#0,d0
    move.w d0,bpl1mod(a5)
    move.w d0,bpl2mod(a5)

	* allocate sprite zero for player shot
	* and set other sprites to blank
	move.l		#player_shot_sprite,d0
	moveq	#7,d1
	lea		sprites,a1
0:
    move.w	d0,(6,a1)
	swap	d0
    move.w	d0,(2,a1)
	swap	d0
	move.l		#blank_sprite,d0
	addq.w	#8,a1
	dbf		d1,0b
		
	* yellow
	lea		sprite_cols,a1		| color 17
	move.w	#0xFF0,d0
	move.w	d0,(2,a1)
	move.w	d0,(6,a1)
	move.w	d0,(10,a1)
	
	
	bsr		set_fg_bitplanes
	bsr		set_bg_bitplanes

	* stars
	bsr		show_stars
	
	* load palette
	bsr		load_palette_in_copperlist
	* set copperlist
	move.l	#copperlist,cop1lc(a5)

	* wait 300 lines
	move.w	#100,d0
	bsr	beamdelay
	move.w	#100,d0
	bsr	beamdelay
	move.w	#100,d0
	bsr	beamdelay
	
    * init sprite, bitplane, whatever dma

    move.w #0x83E0,dmacon(a5)
    *move.w #0x20,dmacon(a5)

	* install keyboard and vblank/copper handler
	pea		level2_interrupt(pc)
	move.l	system_vbr(pc),a1
	move.l	(a7)+,(0x68,a1)
	pea		_vblank(pc)
	move.l	(a7)+,(0x6C,a1)

	* soundfx lib
	lea		_custom,a6
	lea		blank_sound,a0
	move.l	a0,(0xA0,a6)
	move.l	a0,(0xB0,a6)
	move.l	a0,(0xC0,a6)
	move.l	a0,(0xD0,a6)
	move.l	system_vbr(pc),a0
	moveq	#1,d0	| PAL
	jsr		_mt_install_cia

	.ifne	OPT_ENABLE_PROFILING
	* init profiling if enabled
	lea		0x180000,a0
	move.l	#0x20000,d0
	lea		0x100,a1
	bsr		init_fixed_address
	bsr		install_profiler_vbl_hook
	.endif

	
    rts

	
load_palette_in_copperlist:
	movem.l	d0-d1/a1,-(a7)
	lea		palette,a0
	move.w	#TOTAL_NB_COLORS-1,d0
	lea		copperlist_colors+2,a1
1:
	move.w	(a0)+,(a1)+
	add.w	#2,a1
	dbf		d0,1b
	movem.l	(a7)+,d0-d1/a1
	rts
	

* 60Hz VBLANK interrupt (also keyboard)
osd_enable_vblank_interrupt:
	move.w	#0xC038,_custom+intena
	rts

osd_ack_vblank_interrupt:
	move.w	#0x30,_custom+intreq
 	rts
		
osd_disable_vblank_interrupt:
	move.w	#0x0030,_custom+intena
	rts
		

* 32 couple of values.
* 2 bytes: offset 0: scroll value, 1: palette clut

osd_reset_attributes:
    .ifeq OPT_DISABLE_BG_LAYER
	movem.l	d0-d2/a0-a4,-(a7)
	lea		bg_color_table,a1
	lea		bg_cluts,a2
	lea		bg_colorram,a5
	move.w	#32-1,d0
	moveq	#0,d2
0:
	clr.w	d1
	clr.w	(a5)+
	move.b	d1,d2
	lsl.w	#3,d2				| offset of clut
	lea		(2,a2,d2.w),a3		| skip first black color
	* now change copperlist for this line
	move.l	(a1)+,a4
	move.w	(a3)+,(2,a4)
	move.w	(a3)+,(6,a4)
	move.w	(a3)+,(10,a4)
	dbf		d0,0b
	movem.l	(a7)+,d0-d2/a0-a4
   .endif | OPT_DISABLE_BG_LAYER
	rts

* < A0: pointer on attributes/sprites/bullets
* 32 couple of values.
* 2 bytes: offset 0: scroll value, 1: palette clut
* 5800-583F   01011AAAAAAAAAAA R/W DDDDDDDD   !OBJRAM Screen attributes
* 5840-585F   01011AAAAAAAAAAA R/W DDDDDDDD   !OBJRAM Sprites
* 5860-5880   01011AAAAAAAAAAA R/W DDDDDDDD   !OBJRAM Bullets
* so pointer points to
* - 0x40 bytes of attributes (2 byte per "column" - actually a row)
* - 0x20 bytes of sprites
* - 0x20 bytes of bullets

osd_update_graphics:
	movem.l	d0-d7/a0-a6,-(a7)
    .ifeq OPT_DISABLE_BG_LAYER
	lea		bg_color_table,a1
	lea		bg_cluts,a2
	lea		bg_colorram,a5
	lea		scroll_and_dirty_rows_values(pc),a6
	
	move.w	#32-1,d0
	moveq	#0,d2
0:
	move.w	(a0)+,d1
	move.w	d1,(a5)+
	move.b	d1,d2
	lsl.w	#3,d2				| offset of clut
	lsr.w	#8,d1
	
	cmp.b	(1,a6),d1			| check previous scroll value
	beq.b	1f
	move.b	#2,(a6)				| mark row as dirty
	move.b	d1,(1,a6)			| store scroll values
1:
	addq.w	#2,a6
	lea		(2,a2,d2.w),a3		| skip first black color
	* now change copperlist for this line
	move.l	(a1)+,a4
	move.w	(a3)+,(2,a4)
	move.w	(a3)+,(6,a4)
	move.w	(a3)+,(10,a4)
	dbf		d0,0b
	* update dirty lines
	tst.w	slow_machine
	beq.b	10f
	* on a slow machine, side scrolling (swarm, characters)
	* is updated only 50% of the time. This (and blocked stars scroll)
	* allows lowly A500 to run the game perfectly
	eor.b	#1,flip_flop
	beq.b	11f
10:
	bsr		update_rows
11:
	.else
	lea		(0x40,a0),a0
   .endif | OPT_DISABLE_BG_LAYER
	
	.ifeq OPT_DISABLE_SPRITES
	* load previous sprite state base
	* (depending on screen buffer, double buffering)
	
	move.l		previous_sprite_state_ptr(pc),a4

	jbsr		delete_sprites
	jbsr		delete_enemy_bullets
	
	* now A0 contains sprite/bullet data

	move.l	a0,-(a7)		| save it
	**lea		test_sprite_data(pc),a0
	
	move.l		previous_sprite_state_ptr(pc),a4
	jbsr		draw_sprites
	
	* now A0 contains bullet data
	jbsr		draw_enemy_bullets
	* restore a0 from the start
	move.l	(a7),a0
	jbsr		draw_player_bullet
		
	bsr		delete_old_hw_sprites

	* restore a0 from the start

	move.l	(a7)+,a0

	* save previous state for HW sprites now (we needed the "previous" data earlier)
	lea		previous_sprite_state_3(pc),a5
	move.l	#(SPRITE_MEM_SIZE*NB_SPRITES_TOTAL)/4-1,d0
0:
	move.l	(a0)+,(a5)+		| for sprites (immediate previous, no double buffering)
	dbf		d0,0b
	.endif
	
	
	movem.l	(a7)+,d0-d7/a0-a6
	rts

	.macro	CONVERT_BULLET_Y
	neg.b	d1
	add.w	#256-6,d1
	and.w	#0xFF,d1
	.endm
	.macro	CONVERT_BULLET_Y_MUL
	CONVERT_BULLET_Y
	add.w	d1,d1
	move.w	(a2,d1.w),d1	| Y times 40
	.endm
	
* < A0: bullet table
* < A4: previous positions
* all registers potentially trashed
draw_enemy_bullets:
	moveq	#6,d7
	moveq	#0,d0
	moveq	#0,d1
	lea		mulNB_BYTES_PER_ROW_table(pc),a2
	move.l	bg_drawed_screen_ptr(pc),a3
	add.l	#BG_SCREEN_PLANE_SIZE*2,a3		| third plane
0:
	| is the position legal?
	move.l	(a0)+,d4
	move.l	d4,d0
	swap	d0
	move.b	d4,d1
	bne.b	1f
	tst.b	d0
	beq.b	2f
1:
	cmp.b	#0xFE,d1
	beq.b	2f
	CONVERT_BULLET_Y_MUL
	addq.w	#SPRITE_X_OFFSET,d0
	move.w	d0,d2
	lsr.w	#3,d2		| X in bytes
	and.b	#7,d0		| pixel shift
	neg.b	d0
	addq.b	#7,d0		| bit 0 means left position so bit 7
	add.w	d1,d2		| Y*40+Xbytes
	lea		(a3,d2.w),a5
	| draw 3 pixels vertically
	bset	d0,(a5)
	bset	d0,(NB_BYTES_PER_ROW,a5)
	bset	d0,(NB_BYTES_PER_ROW*2,a5)
	bset	d0,(NB_BYTES_PER_ROW*3,a5)

2:
	move.l	d4,(a4)+		| save for next time
	dbf		D7,0b
	rts
	
* < A0: sprite table
draw_player_bullet:
	* +0x1D: player bullet Y (amiga: x)
	* +0x1D: player bullet X (amiga: y)
	lea		(0x1D+0x20,a0),a1
	
	moveq	#0,d0
	moveq	#0,d1
	* get X and Y
	move.b	(a1),d0
	move.b	(2,a1),d1
	CONVERT_BULLET_Y
	lea		HW_SpriteYTable_8,a1	
	bsr		store_sprite_pos
	lea		player_shot_sprite,a1
	* set X/Y coords for sprite
	move.l	d0,(a1)
	rts
	
* hide hw sprite if no longer a real sprite in slot 
* check current sprite state vs hw_sprite_slots in the end

delete_old_hw_sprites:
	lea		hw_sprite_flag_table,a4
 	lea		previous_sprite_state_3(pc),a5
	lea		hw_sprite_slots(pc),a2
	lea		amiga_sprite_slots(pc),a3

	moveq	#0,d0
0:
	move.w	(a0),d1
	move.b	d1,d3	| get sprite code
	and.w	#0x3F,d3
	tst.b	(a4,d3.w)
	beq.b	1f			| is not a HW sprite
	lsr.w	#8,d1
	beq.b	1f		| not active
	cmp.b	#0xF8,d1
	bne.b	2f	| current position is a sprite, active
	
1:
	* current sprite no longer active / replaced by BOB
	* now check if was previously a sprite
	move.w	(a5),d2
	move.b	d2,d3	| get sprite code
	and.w	#0x3F,d3
	tst.b	(a4,d3.w)
	beq.b	2f			| was not a HW sprite
	* it was a sprite
	move.l	(a2,d0.w),a1
	clr.l	(a1)		| clear control word: undisplay sprite
	move.w	(4,a2,d0.w),d7		| now get amiga hw sprite index
	clr.b	(a3,d7.w)	| unreserve from amiga sprite table
2:
	addq.w	#4,a0
	addq.w	#4,a5
	addq.w	#8,d0
	cmp.w	#NB_SPRITES_TOTAL*8,d0
	bne.b	0b
	rts
	
* < a0: sprite structures (4 bytes)
* < a4: backup previous data (A4 is updated to previous bullets on exit)
draw_sprites:
	movem.l	a2-a3,-(a7)
	moveq	#0,d6
	moveq	#0,d5
	* start by the end, sprite 0 has max priority, draw it last
	moveq	#NB_SPRITES_TOTAL-1,d3
	lea		(4*NB_SPRITES_TOTAL,a0),a2
	lea		(4*NB_SPRITES_TOTAL,a4),a4
2:
	* d0 and d1 are changed at each loop
	* make sure that their bits 8-15 are cleared
	moveq	#0,d0
	moveq	#0,d1
	* get sprite x,y,clut,index
	move.l	-(a2),d4
	move.l	d4,-(a4)		| save for next time
	move.l	d4,d7
	jeq		11f
	and.l	#0xFF0000FF,d7
	cmp.l	#0xF80000F8,d7	| X=Y=0xF8: means disabled
	beq.w	11f
	
	bsr		decode_sprite_data

	
	lea		sprite_table,a1
	move.b	d6,d2		| save attributes xflip/yflip
	and.w	#0x3F,d6	| mask attributes
	add.w	d6,d6
	add.w	d6,d6
	move.l	(a1,d6.w),d7
	jeq	11f			| invalid sprite
	move.l	d7,a1
	and.w	#7,d5		| mask attributes
	add.w	d5,d5
	add.w	d5,d5
	move.l	(a1,d5.w),d7
	jbeq	11f			| invalid clut index
	move.l	d7,a1
	move.w	(a1)+,d7	| type
	bne.b	4f			| sprite
	* BOB
	btst	#7,d2
	beq.b	3f
	* YFlip: get mirrored version
	addq.w	#4,a1
3:
	move.l	(a1),a0		| BOB data
	.ifne	SPRITE_X_OFFSET
	addq.w	#SPRITE_X_OFFSET,d0
	.endif
	.ifne	SPRITE_Y_OFFSET
	addq.w	#SPRITE_Y_OFFSET,d0
	.endif
	jbsr		blit_16x16_bob
	jra			11f
4:
	* sprite: memorize pointer on palette
	move.l	a1,current_sprite_palette
	* skip to sprite frames
	addq.w	#8,a1
	move.l	(a1)+,a0		| memorize sprite frame table in a0
	* now was the sprite active in the previous occurrence?
	lea		previous_sprite_state_3(pc),a6
	move.w	d3,d7
	lsl.w	#2,d7		| because SPRITE_MEM_SIZE=4
	cmp.b	#0xF8,(a6,d7.w)
	beq.b	5f			| was not active
	* active: was it a hw sprite?
	move.b	(1,a6,d7.w),d7	| get previous sprite code
	and.w	#0x3F,d7
	lea		hw_sprite_flag_table,a5
	tst.b	(a5,d7.w)
	beq.b	5f			| was not a HW sprite
	st.b	d2
	* already active: reuse current slot as it is the same hardware
	* sprite on the emulated display too

	bra.b	10f
5:
	lea		amiga_sprite_slots(pc),a3
	moveq	#0,d2
6:
	* sprite just appeared in the playfield: find free slot
	move.b	(a1)+,d2	| index of the amiga sprite
	bmi.b	11f			| no slot available
	* check if that slot is available
	tst.b	(a3,d2.w)
	bne.b	6b
	* slot is available: amiga hardware sprite d2 is free
	st.b	(a3,d2.w)		| reserve it
10:
	* update hw sprite table
	move.w	d3,d7
	lsl.w	#3,d7
	lea		hw_sprite_slots,a5
	add.w	d7,a5		| select proper slot
	tst.b	d2
	bmi.b	100f
	* new sprite: must set amiga sprite index value
	move.w	d2,(4,a5)
	bra.b	101f
100:
	* get previous value
	* issue: if another sprite type follows and the
	* slot list is not compatible, this will fail
	move.w	(4,a5),d2
	* if it's zero, it means that
	* all slots were previously taken (sprite 0 is reserved)
	* so don't display anything
	beq.b	11f
101:
	* set palette
	add.w	d2,d2
	add.w	d2,d2		| d2 *= 4
	move.w	d2,d4		| save d2
	add.w	d2,d2		| d2 *= 8
	bclr	#3,d2		| same palette for 2 sprites
	lea		sprite_cols,a1
	add.w	d2,a1
	move.l	current_sprite_palette(pc),a3
	* copy 4 no 3 colors
	addq	#2,a3
	*move.w	(a3)+,(2,a1)
	move.w	(a3)+,(6,a1)
	move.w	(a3)+,(10,a1)
	move.w	(a3)+,(14,a1)

	move.w	d4,d2	| restore d2*4
	
	* get sprite frame for current amiga hw sprite
	move.l	(a0,d2.w),a0
	* and store it in hw_sprite_slots table
	
	move.l	a0,(a5)

	* set sprite X,Y
	.ifne	SPRITE_X_OFFSET
	addq.w	#SPRITE_X_OFFSET,d0
	.endif
	.ifne	SPRITE_Y_OFFSET
	addq.w	#SPRITE_Y_OFFSET,d0
	.endif
	bsr		store_sprite_pos_16
	move.l	d0,(a0)
	
	* set in copperlist at the proper location
	lea		sprites,a5
	add.w	d2,d2		| hw sprite index times 8
	add.w	d2,a5
	move.l	a0,d2		| sprite pointer
	
	move.w	d2,(6,a5)
	swap	d2
	move.w	d2,(2,a5)

11:
	dbf	d3,2b
	lea		(4*NB_SPRITES_TOTAL,a2),a0		| restore A0 pointing to the end
	lea		(4*NB_SPRITES_TOTAL,a4),a4	
	movem.l	(a7)+,a2-a3
	rts


	
* < A4: previous bullets
* most registers are trashed

delete_enemy_bullets:
	moveq	#0,d0	| make sure .W value is correct
	moveq	#0,d1
	moveq	#7-1,d2	| 7 bullets
	lea		mulNB_BYTES_PER_ROW_table(pc),a2
	move.l	bg_drawed_screen_ptr(pc),a3
	add.l	#BG_SCREEN_PLANE_SIZE*2,a3		| third plane
0:
	move.b	(1,a4),d0
	move.b	(3,a4),d1
	bne.b	1f
	tst.b	d0
	beq.b	2f
1:
	cmp.b	#0xFE,d1
	beq.b	2f
	CONVERT_BULLET_Y_MUL
	addq.w	#SPRITE_X_OFFSET,d0	
	lsr.w	#3,d0
	lea		(a3,d0.w),a6
	lea		(a6,d1.w),a6
	clr.b	(a6)
	clr.b	(NB_BYTES_PER_ROW,a6)
	clr.b	(NB_BYTES_PER_ROW*2,a6)
	clr.b	(NB_BYTES_PER_ROW*3,a6)
2:
	addq.w	#4,a4
	dbf		d2,0b
	rts
	
* < A4: previous sprite data (updated on exit)

delete_sprites:
	movem.l	a0-a3,-(a7)

	lea		hw_sprite_flag_table,a3
    lea _custom,a5
	
	move.w	#NB_SPRITES_TOTAL-1,d5
2:
	move.l	(a4)+,d4
	move.l	d4,d7
	beq.w	11f				| 0 means not used yet (bootup)
	and.l	#0xFF0000FF,d7
	cmp.l	#0xF80000F8,d7	| X=Y=0xF8: means disabled
	beq.w	11f
	* get data
* < D4: sprite properties
*     Y code+attrs clut X
* > D0,D1: X,Y.W
* > D6: sprite index.W

	moveq	#0,d0	| make sure .W value is correct
	moveq	#0,d1
	moveq	#0,d6
	move.b	d4,d1	| sprite X (aka Y on amiga)
	swap	d4
	move.b	d4,d6	| sprite index
	and.b	#0x3F,d6  | only sprite code
	lsr.l	#8,d4	
	move.b	d4,d0	| sprite Y (aka X on amiga)

	* is it a hw sprite?
	tst.b	(a3,d6.w)
	jne		11f		| real sprite: skip erase
	
	* erase previous sprite position (but not if sprite type
	* is hardware sprite)

	moveq	#4,d2	| width
    move.w  #16,d4		| max single size height

	move.l	fg_drawed_screen_ptr(pc),a1
	.ifne	SPRITE_X_OFFSET
	addq.w	#SPRITE_X_OFFSET,d0
	.endif
	.ifne	SPRITE_Y_OFFSET
	addq.w	#SPRITE_Y_OFFSET,d0
	.endif
	moveq	#NB_PLAYFIELD_PLANES,d3
	jbsr		clear_planes_any_blitter_internal
11:
	dbf		d5,2b
	movem.l	(a7)+,a0-a3
	rts
	
* < D4: sprite properties
*     Y code+attrs clut X
* > D0,D1: X,Y.B
* > D5: clut index
* > D6: sprite index + attributes
* 
decode_sprite_data:
	move.b	d4,d1	| sprite X (aka Y on amiga)
	lsr.l	#8,d4
	move.b	d4,d5	| clut index
	lsr.l	#8,d4
	move.b	d4,d6	| sprite index
	lsr.l	#8,d4	
	move.b	d4,d0	| sprite Y (aka X on amiga)
	rts


	
* sprite structure: 4 bytes: X,sprite_id (with attributes),clut_index,Y

test_sprite_data:
	.byte	0xF8,0x00,0x00,0xF8,0xF8,0x00,0x00,0xF8,0xF8,0x00,0x00,0xF8,0xF8,0x00,0x00,0xF8
	.byte	0x40,0x11,0x04,0x10,0xF8,0x00,0x00,0xF8,0xF8,0x00,0x00,0xF8,0xF8,0x00,0x00,0xF8
	.byte	0x2F,0x11,0x04,0xC4,0x2F,0x11,0x03,0xB4,0x2F,0x11,0x02,0xA4,0x2F,0x29,0x01,0x94

* d6=screen address (preserved), d0=tile (preserved)
* d6 starts at 0x5000 ends at 0x57FF
* should preserve all registers

osd_w_bg_videoram:
    .ifeq OPT_DISABLE_BG_LAYER
	movem.l	d0-d3/d6/a0-a2,-(a7)
	sub.w	#SCREEN_ADDRESS,d6
	cmp.w	#0x800,d6
	bcs.b	1f
	* should not happen
	move.w	#0,d6
1:
	lea		bg_videoram,a1
	add.w	d6,a1
	cmp.b	(a1),d0
	beq.b	0f		| already the proper value
	move.b	d0,(a1)	| update logical grid
	jbsr		update_bg_tile
0:
	movem.l	(a7)+,d0-d3/d6/a0-a2
    .endif | OPT_DISABLE_BG_LAYER
	rts

	
	
update_rows:
    movem.l d0-d7/a0-a6,-(a7)
    lea _custom,A5
	
	clr.w	d6
	lea		scroll_and_dirty_rows_values(pc),a4
	lea		bg_screen_backbuffer,a3
	move.l	bg_drawed_screen_ptr(pc),a6
0:
	move.b	(a4,d6.w),d0
	jeq		5f
	subq.b	#1,d0
	move.b	d0,(a4,d6.w)	| dec counter, eventually ack as clean
	* now blit the dirty row
	* we should first clear the left or right part depending on scroll value
	* but that's only necessary at player ship level, and only when player is killed
	* so ship position "jumps" from left/right to center. When jumping from left
	* the ship is not properly cleared. Cornercase, so a little hack is preferred, that
	* will also save blitter time
	
	* now blit the dirty row
	moveq	#0,d0
	move.l	a3,a0		| source (current row)
	move.l	a6,a1		| dest (current row)
	
	* issue only on player ship because when player is killed,
	* game clears and resets scroll immediately, not leaving enough
	* time for character clear to be applied on other buffer
	cmp.b	#0x34,d6
	jne		1f				| only for first player ship row
	
	moveq	#0,d0
	moveq	#0,d1
	move.b	(1,a4,d6.w),d1	| scroll offset: as signed byte
	move.b	previous_ship_scroll(pc),d0
	jbsr	erase_previous_ship
	move.b	previous_previous_ship_scroll(pc),d0
	move.b	previous_ship_scroll(pc),d1
	jbsr	erase_previous_ship
	
	move.b	previous_ship_scroll,previous_previous_ship_scroll
	moveq	#0,d0
	move.b	(1,a4,d6.w),d0	| scroll offset: as signed byte
	move.b	d0,previous_ship_scroll
	bpl.b	2f
1:
	move.b	(1,a4,d6.w),d0	| scroll offset: as signed byte
	bpl.b	2f
	* negative: for instance for player ship pseudosprite
	* at startup, value is 0xFF (-1)
	* <0 is half left of the screen
	* >0 is half right of the screen
	* make up for that in the source & width
	
	move.w	d0,d3
	and.w	#0xF,d0		| shifting 0-15 is not signed
	neg.b	d3			| absolute value of bytes to shift to source
	lsr.w	#3,d3		| divide by 8 to get source byte shift
	tst		d0
	beq.b	1f
	* if there's some shifting we need to make up for it
	addq.w	#2,d3
1:
	* round on even byte
	bclr	#0,d3
	add.w	d3,a0		| X-offset source plane position
	bra.b	3f
2:
	* positive
	move.w	d0,d3
	lsr.w	#3,d3		| divide by 8 to get destination byte shift
	bclr	#0,d3
    add.w   d3,a1       | X-offset destination plane position
3:
	move.w	#NB_BYTES_PER_ROW,d2
	sub.w	d3,d2		| change width depending on scroll offset

	moveq	#8,d4		| height

    move.l  #0x09f00000,d3    | A->D copy, ascending mode

	move.w	#NB_BYTES_PER_ROW,d1

    sub.w   d2,d1       | blit modulo
    lsl.w   #6,d4
    lsr.w   #1,d2		| blit width
    add.w   d2,d4       | blit height

	* insert shifting in D3 bltcon config
	and.w	#0xF,d0		| shifting 0-15
	* apply to bltcon (destination)
    swap    d0
    clr.w   d0
    lsl.l   #8,d0
    lsl.l   #4,d0
    or.l    d0,d3
	
    * always the same settings

    * now just wait for blitter ready to write all registers
	WAIT_BLIT
    
    * blitter registers set

	move.l d3,bltcon0(a5)	| sets con0 and con1

    move.w  d1,bltamod(a5)	|A modulo
    move.w  d1,bltdmod(a5)	|D modulo
							
	move.l a0,bltapt(a5)	|source graphic top left corner
	move.l a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	
	lea	(BG_SCREEN_PLANE_SIZE,a0),a0
	lea	(BG_SCREEN_PLANE_SIZE,a1),a1

	WAIT_BLIT
	* second bitplane
	move.l a0,bltapt(a5)	|source graphic top left corner
	move.l a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit

5:
	add.w	#NB_BYTES_PER_ROW*8,a3	| 2 planes
	add.w	#NB_BYTES_PER_ROW*8,a6	| 2 planes
	addq.w	#2,d6
	cmp.w	#NB_LINES/4,d6
	jne		0b
	

	movem.l	(a7)+,d0-d7/a0-a6
	rts

* < D0: previous ship row scroll
* < D1: current ship row scroll
* < A6: plane ptr
	
erase_previous_ship:
	ext.w	d0
	ext.w	d1
	sub.w	d0,d1
	bpl.b	1f
	neg.w	d1		| abs value
1:
	cmp.w	#3,d1
	bcs.b	3f
	* discontinuity on ship X: this is going to leave unerased chars on screen
	* handle this (D0: previous ship Y aka X on amiga), use CPU to clear
	* (not critical, done once)
	lea	(8*NB_BYTES_PER_ROW,a6),a1
	move.l	a6,a1
	add.w	#0x80,d0
	lsr.w	#3,d0
	bclr	#0,d0
	subq.w	#2,d0
	add.w	d0,a1
	moveq	#1,d2
	WAIT_BLIT
0:
	move.l	a1,a2
	move.w	#31,d1
2:
	clr.l	(a2)+
	clr.l	(a2)
	add.w	#NB_BYTES_PER_ROW-4,a2
	dbf	d1,2b
	lea		(BG_SCREEN_PLANE_SIZE,a1),a1
	dbf		d2,0b
3:
	rts
	
* d6: screen offset
* d0: tile code
* d1: attribute
update_bg_tile:
	* compute Y
	and.w	#0xFF,d0	| mask up to 255
	move.w	d6,d3
	lsr.w	#5,d6		| this is X
	neg.w	d6
	add.w	#32,d6
	and.w	#0x1F,d3	| this is Y
	* mark row as dirty
	lea		scroll_and_dirty_rows_values(pc),a1
	add.w	d3,d3
	move.b	#2,(a1,d3.w)	| 2 refreshes needed (double buffering)
	* multiply by 240
	lea		mulNB_BYTES_PER_ROW_table(pc),a0

	lea		bg_screen_backbuffer,a1

	move.w	(a0,d3.w),d3
	lsl.w	#3,d3		| times 8
	add.w	d3,a1
	add.w	d6,a1
	* optimization when a well-known
	* empty character is passed
	cmp.b	#0x10,d0	| empty character
	jeq	1f
	cmp.b	#0x2C,d0	| empty characters (0x2C-0x2F)
	jcs	0f
	cmp.b	#0x30,d0
	jcs	1f
0:
	lea		character_table,a0
	add.w	d0,d0
	add.w	d0,d0
	move.l	(a0,d0.w),d0
	jeq	1f
	move.l	d0,a0
	.set	offset,0
	.rept	8
	move.b	(a0)+,(offset,a1)	
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	.set	offset,0
	.rept	8
	move.b	(a0)+,(offset+BG_SCREEN_PLANE_SIZE,a1)
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
0:
	rts
1:
	.set	offset,0
	.rept	8
	clr.b	(offset,a1)
	clr.b	(offset+BG_SCREEN_PLANE_SIZE,a1)
	.set	offset,offset+NB_BYTES_PER_ROW
	.endr
	rts
		


			
store_sprite_pos_16:
	move.l	a1,-(a7)
	lea		HW_SpriteYTable_16,a1
	bsr		store_sprite_pos
	move.l	(a7)+,a1
	rts
	
* < d0.w: x
* < d1.w: y
* < a1: sprite pos table (depending on height)
* > d0.L: control word
store_sprite_pos:
    move.l  a0,-(a7)

    lea	HW_SpriteXTable(pc),a0
	
	.ifdef	NO68020
    add.w	d0,d0
    add.w	d0,d0
    move.l	(a0,d0.w),d0
	move.w	d1,-(a7)
    add.w	d1,d1
    add.w	d1,d1
    or.l	(a1,d1.w),d0
	move.w	(a7)+,d1
	.else
    move.l	(a0,d0.w*4),d0
    or.l	(a1,d1.w*4),d0	
	.endc
    move.l  (a7)+,a0
    rts
	
HW_SpriteXTable:
	.set	reptn,0
	.rept 320
	.set	x,reptn+0x80
	.set reptn,reptn+1
    .byte  0,x>>1,0,x&1
  .endr

	.macro DEF_HW_SPRITE_Y_TABLE	height
HW_SpriteYTable_\height:
  .set	reptn,0
  .rept 288
	.set	ys,reptn+0x1c
	.set	ye,ys+\height
    .byte  ys&255, 0, ye&255, ((ys>>6)&4)+((ye>>7)&2)
	.set	reptn,reptn+1
  .endr
	.endm

	DEF_HW_SPRITE_Y_TABLE	0
	DEF_HW_SPRITE_Y_TABLE	8
	DEF_HW_SPRITE_Y_TABLE	16
	DEF_HW_SPRITE_Y_TABLE	32



	
* set_bitplanes
* what: sets bitplanes in copperlist

set_bg_bitplanes:
    move.l	bg_displayed_screen_ptr(pc),a0
    moveq #NB_PLAYFIELD_PLANES-1,d1
	move.l	a0,d0
    lea	bg_bitplanes+2,a0
1:
    swap d0
    move.w d0,(a0)
    swap d0
    move.w d0,(4,a0)    
    addq.w  #8,a0
    add.l #BG_SCREEN_PLANE_SIZE,d0
    dbf d1,1b
    rts

set_fg_bitplanes:
    move.l		fg_displayed_screen_ptr(pc),a0
    moveq #NB_PLAYFIELD_PLANES-1,d1
	move.l	a0,d0
    lea	fg_bitplanes+2,a0
1:
    swap d0
    move.w d0,(a0)
    swap d0
    move.w d0,(4,a0)    
    addq.w  #8,a0
    add.l #FG_SCREEN_PLANE_SIZE,d0
    dbf d1,1b
    rts
	

osd_debug_hook:
	rts
	

* 6000: in D0
*    bits 0-1: coin1 & coin2
*    bit  2: joy move left
*    bit  3: joy move right
* 6800: in D1
*    bits 7-6: if both set, means FREE PLAY
* 1 COIN = 1 PLAY               OFF           OFF
* 2 COINS = 1 PLAY              ON            OFF
* 1 COIN = 2 PLAYS              OFF           ON
* FREE PLAY                     ON            ON 

* 7000: in D2
*    bits 0-1: Values for BONUS GALIXIP. 7 = 7000, 10 = 10000, 12 =12000, 20 = 20000
*    bits 2: lives (0=2/1=3).
osd_read_dipswitches:
	move.b	#0x03,d0
	move.w	free_play_dsw(pc),d1
	move.w	start_lives_and_free_ship_dsw(pc),d2

	movem.l	d3/a0,-(a7)
	lea keyboard_table(pc),a0
	tst.b	(5,a0)		| "5" key like in MAME
	beq.b	0f
	bclr	#0,d0
0:
	tst.b	(6,a0)		| "6" key like in MAME
	beq.b	0f
	bclr	#1,d0
0:
	tst.b	(1,a0)		| "1" key like in MAME
	beq.b	0f
	bset	#0,d1
0:
	tst.b	(2,a0)		| "2" key like in MAME
	beq.b	0f
	bset	#1,d1
0:
	tst.b	(0x4F,a0)		| "<-" key
	beq.b	0f
	bset	#2,d0
0:
	tst.b	(0x4E,a0)		| "->" key
	beq.b	0f
	bset	#3,d0
0:
	tst.b	(0x63,a0)		| "ctrl" key
	beq.b	0f
	bset	#4,d0
0:
	move.l	_joypad_state(pc),d3
	btst	#JPB_BTN_LEFT,d3
	beq.b	0f
	bset	#2,d0
0:
	btst	#JPB_BTN_RIGHT,d3
	beq.b	0f
	bset	#3,d0
0:
	btst	#JPB_BTN_RED,d3
	beq.b	0f
	bset	#4,d0
0:
	tst.b	IS_GAME_IN_PLAY
	bne.b	2f
	* game not in play, accept start 1P game with "up"
	btst	#JPB_BTN_UP,d3
	beq.b	0f
	bset	#0,d1
0:
	* game not in play, accept start 2P game with "down"
	btst	#JPB_BTN_DOWN,d3
	beq.b	0f
	bset	#1,d1
0:
	btst	#JPB_BTN_RED,d3
	beq.b	2f
	* game not in play, accept insert coin with fire
	bclr	#0,d0
2:
	movem.l	(a7)+,d3/a0
	rts

		
osd_read_high_scores:
	movem.l	d0-d7/a0-a6,-(a7)
	move.l	a0,a4
	move.l	_resload(pc),d0
	beq.b	0f
	move.l	d0,a2
	move.l	a0,a3
	bsr		get_hiscore_name
 	jsr		resload_GetFileSize(a2)		
	tst.l	d0
	beq.b	1f
	bsr		get_hiscore_name
	move.l	a3,a1
	jsr		resload_LoadFile(a2)
	* set highest score entry
    move.b    (a3)+,(a4)+
    move.b    (a3)+,(a4)+
    move.b    (a3)+,(a4)+		
	bra.b	1f
0:
	tst.b	highscore_loaded
	beq.b	1f
	* from DOS: just copy buffer
	lea		high_score_buffer(pc),a1
	* set highest score entry
    move.b    (a1)+,(a4)+
    move.b    (a1)+,(a4)+
    move.b    (a1)+,(a4)+	
1:
	movem.l	(a7)+,d0-d7/a0-a6
	rts
	
osd_write_high_scores:
	movem.l	d0-d7/a0-a6,-(a7)
	tst.l	cheat_flags		| don't save score if cheat on
	bne.b	1f
	move.l	_resload(pc),d0
	beq.b	0f
	move.l	d0,a2
	move.l	#SCORE_FILE_SIZE,d0
	move.l	a0,a1
	bsr		get_hiscore_name
	jsr		resload_SaveFile(a2)
	bra.b	1f
0:
	* from DOS: just copy buffer
	lea		high_score_buffer(pc),a1

	move.b	(a0)+,(a1)+
	move.b	(a0)+,(a1)+
	move.b	(a0)+,(a1)+
	st.b	highscore_needs_saving
1:
	movem.l	(a7)+,d0-d7/a0-a6
	rts


level2_interrupt:
	movem.l	D0/A0/A5,-(a7)
	LEA	0x00BFD000,A5
	MOVEQ	#0x08,D0
	AND.B	0x1D01(A5),D0
	BEQ.b	1f
	MOVE.B	0x1C01(A5),D0
	NOT.B	D0
	ROR.B	#1,D0		| raw key code here
    
    lea keyboard_table(pc),a0
	
    bclr    #7,d0
    seq (a0,d0.w)       | updates keyboard table
    bne.b   0f     | we don't care about key release
    
    cmp.b   #0x19,d0	| "P" key
    bne.b   0f

    bsr	toggle_pause
0:
	tst.l	_resload
	bne.b	0f
	cmp.b	#0x45,d0	| "ESC" key
	bne.b	0f
	BSET	#0x06,0x1E01(A5)
	moveq	#2,d0
	bsr	beamdelay
	BCLR	#0x06,0x1E01(A5)	| acknowledge key
	bra		quit_to_os
0:
	BSET	#0x06,0x1E01(A5)
	moveq	#2,d0
	bsr	beamdelay
	BCLR	#0x06,0x1E01(A5)	| acknowledge key

1:
	movem.l	(a7)+,d0/a0/a5
	move.w	#8,_custom+intreq
	rte
	
toggle_pause:
	* pause only within game
	*tst.b	ingame_palette_loaded
	*beq.b	0f
	eor.b   #1,pause_flag
0:
	rts
	
    
* < D0: numbers of vertical positions to wait
beamdelay:
0:
	move.w  d0,-(a7)
    move.b	0xdff006,d0	| VPOS
1:
	cmp.b	0xdff006,d0
	beq.s	1b
	move.w	(a7)+,d0
	dbf	d0,0b
	rts
	
* < A5: custom
* < D0,D1: x,y
* < A1: plane pointer
* < D2: width in bytes (inc. 2 extra for shifting)
* < D4: blit height
* trashes D0-D6
* > A1: even address where blit was done
clear_plane_any_blitter_internal:
	moveq	#1,d3
* < A5: custom
* < D0,D1: x,y
* < A1: foreground plane pointer (often first plane!)
* < D2: width in bytes (inc. 2 extra for shifting)
* < D3: number of planes to clear
* < D4: blit height
* < D7: mask (disabled, -1 set at start)
* trashes D0-D6, A1,A2
clear_planes_any_blitter_internal:
    * pre-compute the maximum of shit here
	move.w	d1,d6
    beq.b   1f    | optim
	* check if y start + height > Y_MAX
	* (ignores case where y = 0, no risk)
	add.w	d4,d6
	sub.w	#Y_MAX,d6
	bmi.b	0f
	* y start + height > Y_MAX: clip height
	sub.w	d6,d4
	beq.b	10f
	bpl.b	0f
10:
	* null or negative height after clipping: out
	rts
0:
    lea mulNB_BYTES_PER_ROW_table(pc),a2
    add.w   d1,d1
    move.w  (a2,d1.w),d1
1:
    tst    d0
    beq.b   2f
	* no need to compute shifting to delete data
    and.w   #0x1F0,d0
    lsr.w   #3,d0
    add.w   d0,d1
2:   
    add.w   d1,a1       | plane position (always even)

	move.w #NB_BYTES_PER_ROW,d0
    sub.w   d2,d0       | blit width

    lsl.w   #6,d4
    lsr.w   #1,d2
    add.w   d2,d4       | blit height

    * now just wait for blitter ready to write all registers
	WAIT_BLIT
    
    * blitter registers set
	.ifdef	VARIABLE_BLITTER_MASKS_AND_MODS
    move.l  d7,bltafwm(a5)
	.endif
	
	move.l #0x01000000,bltcon0(a5)	 | minterm useD & rect clear (0xA) 
    move.w  d0,bltdmod(a5)	|D modulo
	
	subq	#1,d3
	beq.b	4f
	subq	#1,d3
3:
	move.l a1,bltdpt(a5)	|destination top left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	lea		(FG_SCREEN_PLANE_SIZE,a1),a1
	WAIT_BLIT
	dbf		d3,3b
4:
	move.l a1,bltdpt(a5)	|destination top left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	
    rts



	
* what: blits 16x16 data on fg planes, cookie cut
* args:
* < A0: data (16 pixels wide, 2+1 planes)
* < D0: X
* < D1: Y
* < D2: bit 6: 0: direct, 1: flip
* trashes: D0-D1

blit_16x16_bob:
	movem.l	d2-d6/a0-a5,-(a7)
	move.w	#16,d3		| height = 16 (fixed)
	* first check if Y is positive
	moveq	#0,d6	| bitmap offset
	tst		d1
	bpl.b	10f
	* Y is negative, handle the Y-clipping 
	* or completely zap the blit
	add.w	d1,d3
	bmi.b	2f
	beq.b	2f		| no need to blit if height <= 0
	* compute offset to add to bitmap
	neg		d1    | make it positive
	* add a 4-byte offset per line (16 pixels = 32 bits)
	move.w	d1,d3
	add.w	d3,d3
	add.w	d3,d3
	add.w	d3,a0
	moveq	#0,d1	| draw from Y=0
10:
	move.l	fg_drawed_screen_ptr(pc),a1
	lea		blit_planes_cookie_cut_16x(pc),a5
	btst	#6,d2
	beq.b	0f
	lea		blit_planes_cookie_cut_16x_flipped(pc),a5	
0:
	lea		(3*BOB_16X16_PLANE_SIZE,a0),a3		| mask is the last plane, only 2 planes for BOBs
	jsr		(a5)

2:
	movem.l	(a7)+,d2-d6/a0-a5
	rts
	

* what: blits 16x16 data on one plane, cookie cut, flip
* args:
* < A0: data (16x16)
* < A1: plane  (40 rows) & background (40 rows) to mix with cookie cut
* < A3: source mask for cookie cut (16x16)
* < D0: X
* < D1: Y
* < D3: height
* trashes: a lot!

blit_planes_cookie_cut_16x_flipped:
    lea _custom,A5
	move.w	d3,d4
	neg.w	d4
	moveq	#3,d3		| 3 planes
    moveq  #4,d2       | 16 pixels + 2 shift bytes
    jra blit_planes_any_internal_cookie_cut

* what: blits 16x16 data on one plane, cookie cut
* args:
* < A0: data (16x16)
* < A1: plane  (40 rows)& background (40 rows) to mix with cookie cut
* < A3: source mask for cookie cut (16x16)
* < D0: X
* < D1: Y
* < D3: height
* trashes: D0-D1

blit_planes_cookie_cut_16x:
    lea _custom,A5
	move.w	d3,d4
	moveq	#3,d3		| 3 planes
    moveq  #4,d2       | 16 pixels + 2 shift bytes
* < A5: custom
* < D0.W,D1.W: x,y
* < A0: source
* < A1: destination plane, also background to mix with cookie cut fg plane
* < A3: source mask for cookie cut
* < D2: width in bytes (inc. 2 extra for shifting)
* < D3: number of planes
* < D4: height. If negative, source is copied with negative modulo (flip)
* < D7: blit mask (not considered, optim, -1 all through the game)
       
* blit mask set

blit_planes_any_internal_cookie_cut:
    movem.l d0-d7/a0-a4,-(a7)
	
    * pre-compute the maximum of shit here
	tst.w	d4
	bpl.b	1f
	sub.w	d4,d1	| pre-add height to d1
	subq.w	#1,d1	| minus one
1:	
	tst	d1
    beq.b   2f    | optim
    lea		mulNB_BYTES_PER_ROW_table(pc),a4
	.ifdef	NO68020
	add.w	d1,d1
    move.w  (a4,d1.w),d1	| y times 40
	.else
    move.w  (a4,d1.w*2),d1	| y times 40
	.endif
2:
	move.l  #0x0fca0000,d5    | B+C-A->D cookie cut   

    move    d0,d6
    beq.b   4f
    lsr.w   #3,d0
	bclr	#0,d0
    and.w   #0xF,d6
	beq.b	3f

    lsl.l   #8,d6
    lsl.l   #4,d6
    or.w    d6,d5            | add shift to mask (bplcon1)
    swap    d6
    clr.w   d6
    or.l    d6,d5            | add shift
3:   
    add.w   d0,d1
    
4:
    * make offset even. Blitter will ignore odd address
    * but a 68000 CPU doesn't and since we RETURN A1...
    bclr    #0,d1
    add.w   d1,a1       | plane position (D1 < 0x7FFF, 288*40=0x2D00)

	move.w	#NB_BYTES_PER_ROW,d0
	tst.w	d4
	bpl.b	5f
	neg.w	d0
	neg.w	d4    | make d4 positive again
5:
    sub.w   d2,d0       | blit width
    lsl.w   #6,d4
    lsr.w   #1,d2
    add.w   d2,d4       | blit height

    * always the same settings (ATM)

    * now just wait for blitter ready to write all registers
	WAIT_BLIT
    
    * blitter registers set

	.ifdef	VARIABLE_BLITTER_MASKS_AND_MODS
    move.l  d7,bltafwm(a5)
	.endif
	move.l d5,bltcon0(a5)	| sets con0 and con1
	clr.w bltamod(a5)		|A modulo=bytes to skip between lines
	clr.w bltbmod(a5)		|B modulo=bytes to skip between lines
	
    move.w  d0,bltcmod(a5)	|C modulo
    move.w  d0,bltdmod(a5)	|D modulo
					
	subq	#1,d3
	beq.b	7f
	subq	#1,d3
6:
	move.l	a3,bltapt(a5)	|source graphic top left corner (mask)
	move.l	a0,bltbpt(a5)	|source graphic top left corner
	move.l	a1,bltcpt(a5)	|pristine background top (bottom) left corner
	move.l	a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	lea		(FG_SCREEN_PLANE_SIZE,a1),a1
	lea		(BOB_16X16_PLANE_SIZE,a0),a0
	WAIT_BLIT
	dbf		d3,6b
7:
	move.l	a3,bltapt(a5)	|source graphic top left corner (mask)
	move.l	a0,bltbpt(a5)	|source graphic top left corner
	move.l	a1,bltcpt(a5)	|pristine background top (bottom) left corner
	move.l	a1,bltdpt(a5)	|destination top (bottom) left corner
	move.w  d4,bltsize(a5)	|rectangle size, starts blit
	
    movem.l (a7)+,d0-d7/a0-a4
    rts

NB_STAR_ROWS = 32		| height: 256

show_stars:
	move.l	a5,-(a7)
	lea	bg_color_table,a3
	lea	stars_palette_rgb4,a2
	lea	stars_copper_row_pointers(pc),a5
	
	clr.w	d7		| 8-row counter
	clr.w	d2		| palette index
2:
	* get address for the next 8 rows
	move.l	(a3)+,a1
	add.w	#copper_stars_offset,a1

	moveq	#8-1,d6
	cmp.w	#28,d7
	bne.b	3f
	moveq	#3-1,d6		| special row
3:
	move.l	a1,(a5)+
4:
	* pick random x
	bsr		random
	btst	#15,d0
	beq.b	1f	| 50% chance of displaying a star
	and.w	#0xFF,d0
	cmp.w	#240,d0		| empiric
	bcc.b	4b
	add.w	#6*8,d0	| add 48 offset because of screen centering
	move.w	#0,d1	| max Y, else glitchy stars
	move.l	a1,-(a7)
	lea		HW_SpriteYTable_0,a1	
	bsr		store_sprite_pos
	move.l	(a7)+,a1
	* store color
	move.w	(a2,d2.w),(2,a1)		| change offset if copper sprite struct changes
	addq.w	#2,d2
	cmp.w	#128,d2		| 64 colors?
	bne.b	0f
	clr.w	d2			| wrap
0:

	* D0 is the sprite pos/control word
	move.w	d0,(10,a1)		| change offset if struct changes
	swap	d0
	move.w	d0,(6,a1)		| change offset if struct changes

	add.w	#32,a1
	dbf		d6,3b
	addq.w	#1,d7
	cmp.w	#NB_STAR_ROWS,d7
	jne		2b
	sub.l	#stars_copper_row_pointers,a5
	move.w	A5,d0
	lsr.w	#2,d0
	move.w	d0,stars_copper_pointers_count
	move.l	(a7)+,a5
	tst.w	slow_machine
	bne.b	3f
	st.b	enable_star_scroll
3:
	rts
1:
	clr.l	d0
	bra.b	0b
	
scroll_stars:
	tst.b	enable_star_scroll
	bne.b	0f
	rts
0:
	lea		stars_copper_row_pointers(pc),a5
	move.w	stars_copper_pointers_count(pc),d7
	move.w	d7,d6
	add.w	d6,d6
	add.w	d6,d6
	add.w	d6,a5		| point at the end of the row pointers
	subq.w	#1,d7
	* save last line first

	
	lea		temp_copper_buffer(pc),a3
	move.l	-(a5),a4
	move.w	(2,a4),(a3)+
	move.w	(10,a4),(a3)+
	move.w	(6,a4),(a3)
	subq	#1,d7
	* then overwrite each next line with previous one
0:
	move.l	(a5),a4	| destination
	move.l	-(a5),a3	| source
	move.w	(2,a3),(2,a4)
	move.w	(10,a3),(10,a4)
	move.w	(6,a3),(6,a4)

	dbf	d7,0b
	* restore last line into the first one
	move.l		stars_copper_row_pointers(pc),a4	| first item
	lea		temp_copper_buffer(pc),a3
	move.w	(a3)+,(2,a4)
	move.w	(a3)+,(10,a4)
	move.w	(a3),(6,a4)
	
	rts


	
random:
    move.l  previous_random(pc),d0
	* EAB simple random generator
    * thanks meynaf
    mulu #0xa57b,d0
    addi.l #0xbb40e62d,d0
    rol.l #6,d0
    move.l  d0,previous_random
    rts
	
	MUL_TABLE	NB_BYTES_PER_ROW,288

current_sprite_state:
	ds.b	SPRITE_SAVE_BUFFER_SIZE
previous_sprite_state_ptr:
	dc.l	previous_sprite_state_1
previous_sprite_state_1:
	ds.b	SPRITE_SAVE_BUFFER_SIZE
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING_FG
previous_sprite_state_2:
	ds.b	SPRITE_SAVE_BUFFER_SIZE
	.endif
* dedicated for hardware sprites, doesn't contain bullets either
previous_sprite_state_3:
	ds.b	SPRITE_MEM_SIZE*NB_SPRITES_TOTAL
	
rdargs_struct:
	dc.l	0
program_args:
	ds.l	40,0	
read_args_string:
	.ascii	"STARTLIVES/K/N,SKILL/K/N,STARTAREA/K/N,"
	.ascii	"INVINCIBLE/S,INFLIVES/S"
	.byte	0
	.align	2

intro_sound_lock:
	.word	0
previous_random:
	.long	0

* 8 slots (indexed with the target sprite index, not
* the amiga sprite index) with
* - 4 bytes for the sprite actual address
* - 2 bytes amiga sprite index
* - 2 bytes??
hw_sprite_slots:
	ds.b	8*8
* 8 slots (indexed with the amiga sprite index)
amiga_sprite_slots:
	ds.b	8

alien_attack_loop_playing:
	.word	0
alien_swarm_loop_playing:
	.word	0
alien_swarm_loop_frequency:
	.word	0
old_intena:
	.long	0
old_dmacon:
	.long	0
old_sysvectors:
	ds.l	8
old_vbr:
	.long	0
old_syscoplist:
	.long	0
old_actiview:
	.long	0
old_stack:
	.long	0

	
_tag:
		.long	WHDLTAG_CUSTOM1_GET
cheat_flags:
		.long	0
		.long	WHDLTAG_CUSTOM3_GET
		.word
slow_machine:
		.word	0
		.long	WHDLTAG_CUSTOM4_GET
dip_switch_bonus_ship:
		.long	0
		.long	WHDLTAG_CUSTOM5_GET
dip_switches:
		.long	0
	.long	0

system_vbr:
	.long	0
	
start_lives_and_free_ship_dsw:
	.word	4
free_play_dsw:
	.word	0
previous_ship_scroll:
	.byte	0
previous_previous_ship_scroll:
	.byte	0
	

current_sprite_palette:
	.long	0
current_sprite_frame_table:
	.long	0	
temp_copper_buffer:
	ds.w	3
stars_copper_pointers_count:
	.word	0
enable_star_scroll:
	.word	0
stars_copper_row_pointers:
	ds.l	NB_LINES+32
	
high_score_buffer:
	ds.b	SCORE_FILE_SIZE

highscore_needs_saving:
	.byte	0
highscore_loaded:
	.byte	0
flip_flop:
	.byte	0
	.align	2
	
keyboard_table:
	ds.b	0x100
scroll_and_dirty_rows_values:
	ds.w	0x20
	
pause_flag:
	dc.w	0

	* sound variables
sound_lock:
	.word	0
music_duration:
	.word	0
music_loops:
	.byte	0
music_volume:
	.byte	0
music_track_start_number:
	.word	0
music_playing:
	.byte	0
music_muted:
	.byte	0
music_pattern:
	.word	0
music_tick:
	.word	0
sound_muted:
	.word	0
intro_music_counter:
	.word	0
vbl_counter:
	.word	0
_resload:
	.long	0
_joypad_state:
	.long	0
_previous_joypad_state:
	.long	0
_previous_joypad_state_2:
	.long	0
_gfxbase:
	.long	0
_dosbase:
	.long	0
bg_drawed_screen_ptr:
	.long	bg_screen_data_1
fg_drawed_screen_ptr:
	.long	fg_screen_data_1
bg_displayed_screen_ptr:
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING_BG
	.long	bg_screen_data_2
	.else
	.long	bg_screen_data_1
	.endif
fg_displayed_screen_ptr:
	.ifne	OPT_ENABLE_DOUBLE_BUFFERING_FG
	.long	fg_screen_data_2
	.else
	.long	fg_screen_data_1
	.endif


	.include	"sound_entries.68k"
* extra sound entries for swarm at different loop periods
swarm_1_len = 10273
swarm_1_freq = 22050
swarm_1_volume = 16

    .macro    SWARM_ENTRY    size
    .long    swarm_1_raw
    .word   \size
    .word   FXFREQBASE/swarm_1_freq,swarm_1_volume
    .byte    0
    .byte    1
    .endm

swarm_sound_table:
	* fastest swarm sound loop freq not so high as len/16
	SWARM_ENTRY (swarm_1_len*3)/32
	.set	idx,2
	.rept	15
    SWARM_ENTRY (swarm_1_len*idx)/16
	.set	idx,idx+1
	.endr
swarm_sound_offsets:
	.set	idx,0
	.rept	16
	.word	idx*12	| 12 is size of sound entry
	.set	idx,idx+1
	.endr
	
dosname:
	.ascii	"dos.library"
	.byte	0
graphicsname:
	.ascii	"graphics.library"
	.byte	0
normal_hiscorename:
	.asciz	"galaxian.high"
floppy_file:
	.ascii	"floppy"
	.byte	0
_end_of_ng_code:
		
		.text
	.align 2
palette:
	.include "palette.68k"

		.bss

		.align 4
	

.align 2
irq_cnt:											ds.w		1
		.data


* 32 rows = 256 pixels
* table of the colors for fg tiles in the copperlist
	.set	row_offset,0
bg_color_table:
	.rept	28
	.long	color_row_0+row_offset
	* warning: this offset increase depends on what's in color_row_0
	* 16=4 colors to change, 32 bytes per star pattern * 8 patterns per row
	.set	row_offset,row_offset+copper_8x8_row_size
	.endr
	.long	color_row_28
	.long	color_row_29
	.set	row_offset,0
	.rept	2
	.long	color_row_30_plus+row_offset
	.set	row_offset,row_offset+copper_8x8_row_size
	.endr

		.section .bsschip
	* some space to write tiles slightly outside screen
	* (scrolling requires it so it's seamless)
	ds.b	NB_BYTES_PER_ROW*12
bg_screen_backbuffer:
	ds.b	BG_SCREEN_SIZE
	ds.b	NB_BYTES_PER_ROW*12*3
bg_screen_data_1:
	ds.b	BG_SCREEN_SIZE
	ds.b	NB_BYTES_PER_ROW*12*3
	.ifne  OPT_ENABLE_DOUBLE_BUFFERING_BG
bg_screen_data_2:
	ds.b	BG_SCREEN_SIZE
	ds.b	NB_BYTES_PER_ROW*12*3
	.endif
fg_screen_data_1:
	ds.b	FG_SCREEN_SIZE
	
	* small margin (I suspect that gas is buggy with ds directive)
	* plus fg plane shifting can write one byte too far
	ds.b	100
	.ifne  OPT_ENABLE_DOUBLE_BUFFERING_FG

fg_screen_data_2:
	ds.b	FG_SCREEN_SIZE
	
fg_tile_layer:
	ds.b	FG_SCREEN_PLANE_SIZE
	ds.b	NB_BYTES_PER_ROW*16
	* small margin (I suspect that gas is buggy with ds directive)
	* plus fg plane shifting can write one byte too far
	ds.b	100
	.endif
	.section	.datachip
	
.macro	DECL_3_BITPLANES	bpoff_start
	.set	bpoff,\bpoff_start
	.rept	NB_PLAYFIELD_PLANES
	dc.w  0xe0+bpoff,0
	dc.w  0xe2+bpoff,0
	.set	bpoff,bpoff+8
	.endr
	.endm

.macro	DECL_16_COLORS	offset
	.set	colidx,\offset
	.rept	16
	dc.w	color+(colidx*2),0
	.set	colidx,colidx+1
	.endr
	.endm

blank_sound:
	ds.l	4
	
debug_copperlist:
	dc.w	color
debug_color:
	dc.w	0
	dc.l	-2
	
blank_sprite:
	.rept	32
	.long	0
	.endr
	
player_shot_sprite:
	.long	0
	.long	0x00800000
	.long	0x00800000
	.long	0x00800000
	.long	0x00800000
	.long	0x00800000
	.long	0x00800000
	.long	0x00800000
	.long	0x00800000
	.rept	22
	.long	0
	.endr
	.long	0
	
	.macro STAR_COPPER_ROW
    * we use sprite #7 (last) for the stars, multiplexing it
	.word	STAR_SPRITE_COLOR_REG,0xF00	   | 4
    .word    spr+sd_SIZEOF*STAR_SPRITE_INDEX+sd_pos,0   | 8
    .word    spr+sd_SIZEOF*STAR_SPRITE_INDEX+sd_ctl,0   | 12
	* sprite pattern
    .word    spr+sd_SIZEOF*STAR_SPRITE_INDEX+sd_dataB,0x0000	| 16
    .word    spr+sd_SIZEOF*STAR_SPRITE_INDEX+sd_dataa,0x8000	| 20
	.word	beampos,0xFFFE              | 24
    .word    spr+sd_SIZEOF*STAR_SPRITE_INDEX+sd_dataB,0	| 28
    .word    spr+sd_SIZEOF*STAR_SPRITE_INDEX+sd_dataa,0	| 32	
	
	.endm
	.macro FAKE_STAR_COPPER_ROW
    * we use sprite #7 (last) for the stars, multiplexing it
	.word	STAR_SPRITE_COLOR_REG,0xF00	   | 4
	.word	STAR_SPRITE_COLOR_REG,0xF00	   | 4
	.word	STAR_SPRITE_COLOR_REG,0xF00	   | 4
	* sprite pattern
	.word	STAR_SPRITE_COLOR_REG,0xF00	   | 4
	.word	STAR_SPRITE_COLOR_REG,0xF00	   | 4
	.word	beampos,0xFFFE              | 24
	.word	STAR_SPRITE_COLOR_REG,0xF00	   | 4
	.word	STAR_SPRITE_COLOR_REG,0xF00	   | 4
	
	.endm
	
	* main copperlist
copperlist:
    *.word   0x1801,0xFFFE	

fg_bitplanes:
	DECL_3_BITPLANES	4
bg_bitplanes:
	DECL_3_BITPLANES	0
copperlist_colors:
	DECL_16_COLORS	0
sprite_cols:
	DECL_16_COLORS	16
sprites:
    * #0
    .word    sprpt+0,0
    .word    sprpt+2,0
    * #1
    .word    sprpt+4,0
    .word    sprpt+6,0
    * #2
    .word    sprpt+8,0
    .word    sprpt+10,0
    * #3
    .word    sprpt+12,0
    .word    sprpt+14,0   
    * #4
    .word    sprpt+16,0
    .word    sprpt+18,0
    * #5
    .word    sprpt+20,0
    .word    sprpt+22,0
    * #6
    .word    sprpt+24,0
    .word    sprpt+26,0
    * #7
    .word    sprpt+28,0
    .word    sprpt+30,0
end_color_copper:
   * dynamic colors for fg tile color each 8 lines
	.set    beampos,0x1C01
	.set	start_color,color
	.word	beampos,0xFFFE
color_row_0:
	.rept	28
	* set 4 colors for that 8-high row: 16 bytes
	.word	start_color+2,0 
	.word	start_color+4,0 
	.word	start_color+6,0   
	* set sprite slots for stars: 32*8 bytes
	.rept	8
	.set	beampos,beampos+0x100
	STAR_COPPER_ROW
	.endr
	.endr
color_row_28:
	.word	start_color+2,0 
	.word	start_color+4,0 
	.word	start_color+6,0   
	.rept	3
	.set	beampos,beampos+0x100
	STAR_COPPER_ROW
	.endr

	* pal limit
    .word  0xFFDF,0xFFFE       | PAL wait (should be 0xFFDF but probably fmode=3 changes it)
    .word  0x0401,0xFFFE

	.set    beampos,0x0401
    .word   beampos,0xFFFE	
	
color_row_29:
	.word	start_color+2,0 
	.word	start_color+4,0 
	.word	start_color+6,0
	.rept	8
	.set	beampos,beampos+0x100
	STAR_COPPER_ROW
	.endr
	
	.set    beampos,0x0c01
	
color_row_30_plus:
	.rept	4
	.word	start_color+2,0 
	.word	start_color+4,0 
	.word	start_color+6,0   
	.rept	8
	.set	beampos,beampos+0x100
	STAR_COPPER_ROW
	.endr
	.endr

 	.word	beampos+0x400,0xFFFE   | wait before interrupt, avoid losing last bobs lines
    .word	 intreq,0x8010
    .long    -2					
	.ascii	"ENDCPLST"

	* aligning on 8 bytes so .align will work
	* in the next datachip sections
	.align	8
	
_end_of_ng_data:
		